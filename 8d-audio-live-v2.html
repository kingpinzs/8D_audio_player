<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8D Audio Player - Live Streaming Edition</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-gradient-start: #667eea;
            --bg-gradient-end: #764ba2;
            --card-bg: white;
            --text-primary: #333;
            --text-secondary: #666;
            --text-inverse: white;
            --control-bg: #f8f9fa;
            --border-color: #e9ecef;
            --shadow: rgba(0,0,0,0.3);
            --success: #43e97b;
            --playing: #667eea;
        }

        body.dark-mode {
            --bg-gradient-start: #1a1a2e;
            --bg-gradient-end: #16213e;
            --card-bg: #0f3460;
            --text-primary: #e9e9e9;
            --text-secondary: #b0b0b0;
            --text-inverse: white;
            --control-bg: #1a2332;
            --border-color: #2a3f5f;
            --shadow: rgba(0,0,0,0.6);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            min-height: 100vh;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: var(--text-inverse);
            margin-bottom: 30px;
            position: relative;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px var(--shadow);
        }

        .dark-mode-toggle {
            position: absolute;
            top: 0;
            right: 0;
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 20px;
            padding: 10px 20px;
            color: white;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s ease;
        }

        .dark-mode-toggle:hover {
            background: rgba(255,255,255,0.3);
        }

        .main-layout {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
        }

        @media (max-width: 1200px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
        }

        .main-card {
            background: var(--card-bg);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px var(--shadow);
            color: var(--text-primary);
        }

        .player-section {
            margin-bottom: 30px;
        }

        .now-playing {
            background: linear-gradient(135deg, var(--playing) 0%, #764ba2 100%);
            padding: 30px;
            border-radius: 15px;
            color: white;
            text-align: center;
            margin-bottom: 20px;
        }

        .now-playing h2 {
            font-size: 1.8rem;
            margin-bottom: 10px;
        }

        .now-playing .track-name {
            font-size: 1.3rem;
            opacity: 0.9;
        }

        .player-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }

        .player-btn {
            width: 60px;
            height: 60px;
            border: none;
            border-radius: 50%;
            background: white;
            color: var(--playing);
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .player-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 15px var(--shadow);
        }

        .player-btn.play {
            width: 80px;
            height: 80px;
            font-size: 2rem;
        }

        .progress-container {
            margin: 20px 0;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255,255,255,0.3);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: white;
            border-radius: 4px;
            transition: width 0.1s linear;
        }

        .time-display {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .control-group {
            background: var(--control-bg);
            padding: 20px;
            border-radius: 10px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: var(--border-color);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        .control-group select {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 2px solid var(--border-color);
            background: var(--card-bg);
            color: var(--text-primary);
            font-size: 1rem;
        }

        .control-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .value-display {
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            color: #667eea;
            margin-top: 5px;
        }

        .preset-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        .preset-btn {
            flex: 1;
            min-width: 120px;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
        }

        .preset-btn.focus {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
        }

        .preset-btn.energy {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }

        .preset-btn.relax {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
        }

        .preset-btn:hover {
            transform: translateY(-2px);
        }

        .playlist-card {
            background: var(--card-bg);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px var(--shadow);
            color: var(--text-primary);
            max-height: 80vh;
            overflow-y: auto;
        }

        .playlist-header {
            margin-bottom: 20px;
        }

        .playlist-header h2 {
            font-size: 1.5rem;
            margin-bottom: 10px;
        }

        .add-source {
            margin-bottom: 20px;
        }

        .add-source h3 {
            font-size: 1.1rem;
            margin-bottom: 10px;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .input-group input {
            flex: 1;
            padding: 10px;
            border-radius: 8px;
            border: 2px solid var(--border-color);
            background: var(--control-bg);
            color: var(--text-primary);
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-danger {
            background: #fa709a;
            color: white;
        }

        .drop-zone {
            border: 3px dashed #667eea;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            background: var(--control-bg);
            cursor: pointer;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .drop-zone:hover {
            background: var(--border-color);
        }

        .playlist-items {
            margin-top: 20px;
        }

        .playlist-item {
            background: var(--control-bg);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .playlist-item:hover {
            background: var(--border-color);
        }

        .playlist-item.playing {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .playlist-item .icon {
            font-size: 1.5rem;
            flex-shrink: 0;
        }

        .playlist-item .info {
            flex: 1;
        }

        .playlist-item .name {
            font-weight: 600;
            margin-bottom: 3px;
        }

        .playlist-item .source {
            font-size: 0.85rem;
            opacity: 0.7;
        }

        .playlist-item .actions {
            display: flex;
            gap: 5px;
        }

        .playlist-item .actions button {
            padding: 5px 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.85rem;
            background: rgba(255,255,255,0.2);
            color: inherit;
        }

        .playlist-stats {
            margin-top: 20px;
            padding: 15px;
            background: var(--control-bg);
            border-radius: 10px;
            text-align: center;
        }

        .visualizer {
            margin: 20px 0;
        }

        canvas {
            width: 100%;
            height: 150px;
            background: var(--control-bg);
            border-radius: 10px;
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .info-badge {
            display: inline-block;
            padding: 4px 10px;
            background: #667eea;
            color: white;
            border-radius: 12px;
            font-size: 0.8rem;
            margin-left: 10px;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .playing-indicator {
            animation: pulse 2s infinite;
        }

        .warning-banner {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            color: #333;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .warning-banner h3 {
            margin-bottom: 10px;
            font-size: 1.2rem;
        }

        .warning-banner code {
            background: rgba(0,0,0,0.1);
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
        }

        .warning-banner button {
            margin-top: 10px;
            padding: 8px 16px;
            background: rgba(0,0,0,0.2);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }

        .warning-banner button:hover {
            background: rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        function App() {
            const [playlist, setPlaylist] = useState([]);
            const [currentTrackIndex, setCurrentTrackIndex] = useState(null);
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentTime, setCurrentTime] = useState(0);
            const [duration, setDuration] = useState(0);
            const [volume, setVolume] = useState(0.7);
            const [showFileWarning, setShowFileWarning] = useState(false);
            
            // 8D Effect Controls
            const [speed, setSpeed] = useState(0.5);
            const [intensity, setIntensity] = useState(0.8);
            const [spatialDepth, setSpatialDepth] = useState(0.6);
            const [movementPattern, setMovementPattern] = useState('circle');
            
            // Additional Effects
            const [binauralEnabled, setBinauralEnabled] = useState(false);
            const [binauralFreq, setBinauralFreq] = useState(14);
            const [noiseType, setNoiseType] = useState('none');
            const [noiseVolume, setNoiseVolume] = useState(0.1);
            
            // UI
            const [darkMode, setDarkMode] = useState(false);
            const [urlInput, setUrlInput] = useState('');
            const [showVisualizer, setShowVisualizer] = useState(true);
            
            // Refs
            const audioContextRef = useRef(null);
            const sourceNodeRef = useRef(null);
            const pannerLeftRef = useRef(null);
            const pannerRightRef = useRef(null);
            const gainNodeRef = useRef(null);
            const audioElementRef = useRef(null);
            const fileInputRef = useRef(null);
            const canvasRef = useRef(null);
            const analyserRef = useRef(null);
            const animationFrameRef = useRef(null);
            const oscillatorLeftRef = useRef(null);
            const oscillatorRightRef = useRef(null);
            const noiseNodeRef = useRef(null);
            const rotationIntervalRef = useRef(null);

            useEffect(() => {
                // Initialize Audio Context
                audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
                
                // Check if opened from file:// protocol
                if (window.location.protocol === 'file:') {
                    setShowFileWarning(true);
                }
                
                // Load preferences
                const savedDarkMode = localStorage.getItem('darkMode');
                if (savedDarkMode === 'true') {
                    setDarkMode(true);
                    document.body.classList.add('dark-mode');
                }
                
                const savedPlaylist = localStorage.getItem('playlist');
                if (savedPlaylist) {
                    try {
                        const parsed = JSON.parse(savedPlaylist);
                        // Filter out tracks with blob URLs since they won't work on reload
                        const filtered = parsed.filter(t => t.source !== 'local' || !t.url);
                        setPlaylist(filtered);
                    } catch (e) {
                        console.error('Error loading saved playlist:', e);
                    }
                }
                
                return () => {
                    if (audioContextRef.current) {
                        audioContextRef.current.close();
                    }
                    if (animationFrameRef.current) {
                        cancelAnimationFrame(animationFrameRef.current);
                    }
                    if (rotationIntervalRef.current) {
                        clearInterval(rotationIntervalRef.current);
                    }
                };
            }, []);

            useEffect(() => {
                // Save playlist to localStorage (without file objects)
                const playlistToSave = playlist.map(track => ({
                    id: track.id,
                    name: track.name,
                    source: track.source,
                    url: track.source === 'url' ? track.url : null,
                    originalUrl: track.originalUrl
                }));
                localStorage.setItem('playlist', JSON.stringify(playlistToSave));
            }, [playlist]);

            useEffect(() => {
                // Update audio time
                if (audioElementRef.current) {
                    const updateTime = () => {
                        setCurrentTime(audioElementRef.current.currentTime);
                        setDuration(audioElementRef.current.duration || 0);
                    };
                    const interval = setInterval(updateTime, 100);
                    return () => clearInterval(interval);
                }
            }, [currentTrackIndex]);

            const toggleDarkMode = () => {
                setDarkMode(!darkMode);
                document.body.classList.toggle('dark-mode');
                localStorage.setItem('darkMode', !darkMode);
            };

            const setupAudioGraph = (audioElement) => {
                const context = audioContextRef.current;
                
                // Resume context if suspended
                if (context.state === 'suspended') {
                    context.resume();
                }
                
                // Clean up existing nodes
                if (sourceNodeRef.current) {
                    sourceNodeRef.current.disconnect();
                }
                if (oscillatorLeftRef.current) {
                    oscillatorLeftRef.current.stop();
                    oscillatorLeftRef.current.disconnect();
                }
                if (oscillatorRightRef.current) {
                    oscillatorRightRef.current.stop();
                    oscillatorRightRef.current.disconnect();
                }
                if (noiseNodeRef.current) {
                    noiseNodeRef.current.stop();
                    noiseNodeRef.current.disconnect();
                }
                if (rotationIntervalRef.current) {
                    clearInterval(rotationIntervalRef.current);
                }
                
                // Create audio source
                const source = context.createMediaElementSource(audioElement);
                sourceNodeRef.current = source;
                
                // Create splitter to separate stereo channels
                const splitter = context.createChannelSplitter(2);
                const merger = context.createChannelMerger(2);
                
                // Create gain nodes for MANUAL 8D panning (much more aggressive)
                const leftToLeftGain = context.createGain();
                const leftToRightGain = context.createGain();
                const rightToLeftGain = context.createGain();
                const rightToRightGain = context.createGain();
                
                // Store references for rotation
                window.leftToLeftGain = leftToLeftGain;
                window.leftToRightGain = leftToRightGain;
                window.rightToLeftGain = rightToLeftGain;
                window.rightToRightGain = rightToRightGain;
                
                // Create delay nodes for spatial depth
                const delayLeft = context.createDelay();
                const delayRight = context.createDelay();
                delayLeft.delayTime.value = 0.05;
                delayRight.delayTime.value = 0.05;
                
                const delayGainLeft = context.createGain();
                const delayGainRight = context.createGain();
                // Drastically reduced to 0.05 to prevent clipping
                delayGainLeft.gain.value = 0.05 * spatialDepth;
                delayGainRight.gain.value = 0.05 * spatialDepth;
                
                // Create cross-channel delays for depth
                const crossDelayLeft = context.createDelay();
                const crossDelayRight = context.createDelay();
                crossDelayLeft.delayTime.value = 0.03;
                crossDelayRight.delayTime.value = 0.03;
                
                const crossGainLeft = context.createGain();
                const crossGainRight = context.createGain();
                // Drastically reduced to 0.03 to prevent clipping
                crossGainLeft.gain.value = 0.03 * spatialDepth;
                crossGainRight.gain.value = 0.03 * spatialDepth;
                
                // Connect audio graph for AGGRESSIVE 8D effect
                source.connect(splitter);
                
                // Left input channel routes
                splitter.connect(leftToLeftGain, 0);
                splitter.connect(leftToRightGain, 0);
                
                // Right input channel routes
                splitter.connect(rightToLeftGain, 1);
                splitter.connect(rightToRightGain, 1);
                
                // Connect to output channels with delays
                leftToLeftGain.connect(merger, 0, 0);
                leftToRightGain.connect(merger, 0, 1);
                rightToLeftGain.connect(merger, 0, 0);
                rightToRightGain.connect(merger, 0, 1);
                
                // Add echo/reverb for spatial depth
                leftToLeftGain.connect(delayLeft);
                delayLeft.connect(delayGainLeft);
                delayGainLeft.connect(merger, 0, 0);
                
                rightToRightGain.connect(delayRight);
                delayRight.connect(delayGainRight);
                delayGainRight.connect(merger, 0, 1);
                
                // Add cross-channel delays
                leftToLeftGain.connect(crossDelayRight);
                crossDelayRight.connect(crossGainRight);
                crossGainRight.connect(merger, 0, 1);
                
                rightToRightGain.connect(crossDelayLeft);
                crossDelayLeft.connect(crossGainLeft);
                crossGainLeft.connect(merger, 0, 0);
                
                // Create main gain and analyzer
                const mainGain = context.createGain();
                // Reduce master volume to 60% of user setting for extra headroom
                mainGain.gain.value = volume * 0.6;
                gainNodeRef.current = mainGain;
                
                const analyser = context.createAnalyser();
                analyser.fftSize = 2048;
                analyserRef.current = analyser;
                
                // Add a compressor to prevent clipping and distortion
                const compressor = context.createDynamicsCompressor();
                compressor.threshold.value = -24; // Start compressing even earlier
                compressor.knee.value = 20; // Very smooth compression curve
                compressor.ratio.value = 20; // Very strong compression
                compressor.attack.value = 0.003; // Fast attack
                compressor.release.value = 0.25; // Longer release for smoother sound
                
                // Add a final limiter to absolutely prevent clipping
                const limiter = context.createDynamicsCompressor();
                limiter.threshold.value = -6; // Hard ceiling
                limiter.knee.value = 0; // Hard knee for brick-wall limiting
                limiter.ratio.value = 20; // Maximum ratio
                limiter.attack.value = 0.001; // Instant attack
                limiter.release.value = 0.1; // Fast release
                
                // Connect to output with compressor AND limiter for maximum safety
                merger.connect(mainGain);
                mainGain.connect(compressor);
                compressor.connect(limiter);
                limiter.connect(analyser);
                analyser.connect(context.destination);
                
                // Setup binaural beats if enabled
                if (binauralEnabled) {
                    setupBinauralBeats(context, mainGain);
                }
                
                // Setup noise if enabled
                if (noiseType !== 'none') {
                    setupNoise(context, mainGain);
                }
                
                // Start 8D rotation
                startRotation();
                
                // Start visualization
                if (showVisualizer) {
                    visualize();
                }
            };

            const startRotation = () => {
                if (rotationIntervalRef.current) {
                    clearInterval(rotationIntervalRef.current);
                }
                
                let time = 0;
                rotationIntervalRef.current = setInterval(() => {
                    // Check if gain nodes exist
                    if (!window.leftToLeftGain || !window.leftToRightGain || 
                        !window.rightToLeftGain || !window.rightToRightGain) return;
                    
                    const angle = 2 * Math.PI * speed * time;
                    let panPosition = 0;
                    
                    // Calculate pan position based on movement pattern
                    switch(movementPattern) {
                        case 'circle':
                            panPosition = Math.sin(angle);
                            break;
                        case 'figure8':
                            panPosition = Math.sin(angle) * Math.cos(angle / 2);
                            break;
                        case 'leftright':
                            panPosition = Math.sin(angle);
                            break;
                        case 'frontback':
                            panPosition = Math.cos(angle) * 0.5;
                            break;
                        case 'random':
                            if (Math.random() > 0.9) {
                                panPosition = (Math.random() * 2 - 1);
                            }
                            break;
                    }
                    
                    // Apply intensity to pan position
                    panPosition *= intensity;
                    
                    // SMOOTHED GAIN CHANGES - prevents crackling from instant changes
                    const safetyFactor = 0.35; // Further reduced from 0.5 to 0.35
                    const targetLeftGain = Math.max(0.001, Math.min(1, (1 - panPosition) * 0.5)) * safetyFactor;
                    const targetRightGain = Math.max(0.001, Math.min(1, (1 + panPosition) * 0.5)) * safetyFactor;
                    
                    // Use linearRampToValueAtTime for smooth transitions (prevents clicks)
                    const ctx = audioContextRef.current;
                    if (!ctx) return;
                    
                    const now = ctx.currentTime;
                    const rampTime = now + 0.05;
                    
                    window.leftToLeftGain.gain.setValueAtTime(window.leftToLeftGain.gain.value, now);
                    window.leftToLeftGain.gain.linearRampToValueAtTime(targetLeftGain, rampTime);
                    
                    window.rightToRightGain.gain.setValueAtTime(window.rightToRightGain.gain.value, now);
                    window.rightToRightGain.gain.linearRampToValueAtTime(targetRightGain, rampTime);
                    
                    // Cross-channel gains - drastically reduced
                    const targetLeftToRight = Math.max(0.001, (1 - targetLeftGain) * 0.05 * safetyFactor);
                    const targetRightToLeft = Math.max(0.001, (1 - targetRightGain) * 0.05 * safetyFactor);
                    
                    window.leftToRightGain.gain.setValueAtTime(window.leftToRightGain.gain.value, now);
                    window.leftToRightGain.gain.linearRampToValueAtTime(targetLeftToRight, rampTime);
                    
                    window.rightToLeftGain.gain.setValueAtTime(window.rightToLeftGain.gain.value, now);
                    window.rightToLeftGain.gain.linearRampToValueAtTime(targetRightToLeft, rampTime);
                    
                    time += 0.05;
                }, 50);
            };

            const setupBinauralBeats = (context, destination) => {
                const baseFreq = 200;
                
                const oscillatorLeft = context.createOscillator();
                const oscillatorRight = context.createOscillator();
                const merger = context.createChannelMerger(2);
                const gainNode = context.createGain();
                
                oscillatorLeft.frequency.value = baseFreq;
                oscillatorRight.frequency.value = baseFreq + binauralFreq;
                
                // Drastically reduced to 0.008 to prevent clipping
                gainNode.gain.value = 0.008;
                
                // Connect left oscillator to left channel
                oscillatorLeft.connect(merger, 0, 0);
                // Connect right oscillator to right channel
                oscillatorRight.connect(merger, 0, 1);
                
                merger.connect(gainNode);
                gainNode.connect(context.destination);
                
                oscillatorLeft.start();
                oscillatorRight.start();
                
                oscillatorLeftRef.current = oscillatorLeft;
                oscillatorRightRef.current = oscillatorRight;
            };

            const setupNoise = (context, destination) => {
                const bufferSize = 2 * context.sampleRate;
                const noiseBuffer = context.createBuffer(1, bufferSize, context.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                
                if (noiseType === 'white') {
                    for (let i = 0; i < bufferSize; i++) {
                        output[i] = Math.random() * 2 - 1;
                    }
                } else if (noiseType === 'pink') {
                    let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
                    for (let i = 0; i < bufferSize; i++) {
                        const white = Math.random() * 2 - 1;
                        b0 = 0.99886 * b0 + white * 0.0555179;
                        b1 = 0.99332 * b1 + white * 0.0750759;
                        b2 = 0.96900 * b2 + white * 0.1538520;
                        b3 = 0.86650 * b3 + white * 0.3104856;
                        b4 = 0.55000 * b4 + white * 0.5329522;
                        b5 = -0.7616 * b5 - white * 0.0168980;
                        output[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                        output[i] *= 0.11;
                        b6 = white * 0.115926;
                    }
                }
                
                const noise = context.createBufferSource();
                noise.buffer = noiseBuffer;
                noise.loop = true;
                
                const noiseGain = context.createGain();
                noiseGain.gain.value = noiseVolume;
                
                noise.connect(noiseGain);
                noiseGain.connect(context.destination);
                noise.start();
                
                noiseNodeRef.current = noise;
            };

            const visualize = () => {
                if (!analyserRef.current || !canvasRef.current) return;
                
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const analyser = analyserRef.current;
                
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                const draw = () => {
                    animationFrameRef.current = requestAnimationFrame(draw);
                    
                    analyser.getByteFrequencyData(dataArray);
                    
                    ctx.fillStyle = darkMode ? '#1a2332' : '#f8f9fa';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const barWidth = (canvas.width / bufferLength) * 2.5;
                    let x = 0;
                    
                    for (let i = 0; i < bufferLength; i++) {
                        const barHeight = (dataArray[i] / 255) * canvas.height;
                        
                        const hue = (i / bufferLength) * 360;
                        ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                        ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                        
                        x += barWidth + 1;
                    }
                };
                
                draw();
            };

            const addLocalFiles = (files) => {
                const newTracks = Array.from(files).map((file, index) => {
                    // Store the file object directly instead of creating blob URL
                    return {
                        id: Date.now() + index,
                        name: file.name.replace('.mp3', ''),
                        source: 'local',
                        file: file, // Store file object
                        url: null // We'll create URL when needed
                    };
                });
                setPlaylist(prev => [...prev, ...newTracks]);
            };

            const handleDrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                const files = e.dataTransfer.files;
                if (files && files.length > 0) {
                    addLocalFiles(files);
                }
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                e.stopPropagation();
            };

            const handleDragEnter = (e) => {
                e.preventDefault();
                e.stopPropagation();
            };

            const handleDragLeave = (e) => {
                e.preventDefault();
                e.stopPropagation();
            };

            const addUrl = () => {
                if (!urlInput.trim()) return;
                
                let source = 'url';
                let name = 'Remote Track';
                
                if (urlInput.includes('youtube.com') || urlInput.includes('youtu.be')) {
                    source = 'youtube';
                    name = 'YouTube Track';
                }
                
                const newTrack = {
                    id: Date.now(),
                    name: name,
                    source: source,
                    url: urlInput,
                    originalUrl: urlInput
                };
                
                setPlaylist(prev => [...prev, newTrack]);
                setUrlInput('');
            };

            const playTrack = (index) => {
                const track = playlist[index];
                if (!track) return;
                
                // Create or reuse audio element
                if (!audioElementRef.current) {
                    audioElementRef.current = new Audio();
                }
                
                const audio = audioElementRef.current;
                
                // Handle track ended
                audio.onended = () => {
                    playNext();
                };
                
                // Handle different track sources
                if (track.source === 'local' && track.file) {
                    // For local files, create blob URL on-demand
                    try {
                        const blobUrl = URL.createObjectURL(track.file);
                        audio.src = blobUrl;
                    } catch (err) {
                        console.error('Error creating blob URL:', err);
                        alert('Error loading file. Please serve this HTML from a web server (see console for instructions).\n\nQuick fix: Run "python3 -m http.server 8000" in this folder, then open http://localhost:8000/8d-player-live.html');
                        return;
                    }
                } else if (track.source === 'youtube') {
                    alert('YouTube playback requires a backend server or YouTube API. Please use direct MP3 URLs or local files.');
                    return;
                } else if (track.url) {
                    // For URL sources
                    audio.src = track.url;
                } else {
                    alert('Invalid track source');
                    return;
                }
                
                audio.load();
                
                setCurrentTrackIndex(index);
                
                // Setup audio graph after loading
                audio.addEventListener('loadedmetadata', () => {
                    setupAudioGraph(audio);
                    audio.play().then(() => {
                        setIsPlaying(true);
                    }).catch(err => {
                        console.error('Playback error:', err);
                        alert('Playback error. If you opened this from file://, please run a local web server.\n\nQuick fix: Run "python3 -m http.server 8000" in this folder');
                    });
                }, { once: true });
            };

            const togglePlayPause = () => {
                if (!audioElementRef.current) {
                    if (playlist.length > 0) {
                        playTrack(0);
                    }
                    return;
                }
                
                const audio = audioElementRef.current;
                
                if (isPlaying) {
                    audio.pause();
                    setIsPlaying(false);
                } else {
                    audio.play().then(() => {
                        setIsPlaying(true);
                    });
                }
            };

            const playNext = () => {
                if (currentTrackIndex === null) return;
                const nextIndex = (currentTrackIndex + 1) % playlist.length;
                playTrack(nextIndex);
            };

            const playPrevious = () => {
                if (currentTrackIndex === null) return;
                const prevIndex = currentTrackIndex === 0 ? playlist.length - 1 : currentTrackIndex - 1;
                playTrack(prevIndex);
            };

            const removeFromPlaylist = (id) => {
                setPlaylist(prev => prev.filter(track => track.id !== id));
                if (currentTrackIndex !== null && playlist[currentTrackIndex]?.id === id) {
                    setCurrentTrackIndex(null);
                    if (audioElementRef.current) {
                        audioElementRef.current.pause();
                        setIsPlaying(false);
                    }
                }
            };

            const seekTo = (e) => {
                if (!audioElementRef.current || !duration) return;
                const rect = e.currentTarget.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const percentage = x / rect.width;
                audioElementRef.current.currentTime = percentage * duration;
            };

            const applyPreset = (preset) => {
                switch(preset) {
                    case 'focus':
                        setSpeed(0.4);
                        setIntensity(0.7);
                        setSpatialDepth(0.5);
                        setBinauralEnabled(true);
                        setBinauralFreq(14);
                        break;
                    case 'energy':
                        setSpeed(1.0);
                        setIntensity(0.9);
                        setSpatialDepth(0.8);
                        setBinauralEnabled(true);
                        setBinauralFreq(40);
                        break;
                    case 'relax':
                        setSpeed(0.3);
                        setIntensity(0.6);
                        setSpatialDepth(0.4);
                        setBinauralEnabled(true);
                        setBinauralFreq(8);
                        break;
                }
                
                // Restart rotation with new settings
                if (isPlaying) {
                    startRotation();
                }
            };

            // Update effects in real-time
            useEffect(() => {
                if (isPlaying) {
                    startRotation();
                }
            }, [speed, intensity, movementPattern]);

            useEffect(() => {
                if (gainNodeRef.current) {
                    // Apply same 60% reduction for extra headroom
                    gainNodeRef.current.gain.value = volume * 0.6;
                }
            }, [volume]);

            const formatTime = (seconds) => {
                if (!seconds || isNaN(seconds)) return '0:00';
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            };

            const getTotalDuration = () => {
                return playlist.length * 3.5; // Estimate 3.5 minutes per track
            };

            const getBinauralDescription = (freq) => {
                if (freq <= 4) return 'Delta (Sleep)';
                if (freq <= 8) return 'Theta (Meditation)';
                if (freq <= 14) return 'Alpha (Relaxation)';
                if (freq <= 30) return 'Beta (Focus)';
                return 'Gamma (Peak Focus)';
            };

            return (
                <div className="container">
                    <div className="header">
                        <button className="dark-mode-toggle" onClick={toggleDarkMode}>
                            {darkMode ? '‚òÄÔ∏è' : 'üåô'}
                        </button>
                        <h1>üéß 8D Audio Player - Live</h1>
                        <p>Real-time 8D Processing ‚Ä¢ Playlist Builder ‚Ä¢ Stream for Hours</p>
                    </div>

                    {showFileWarning && (
                        <div className="warning-banner">
                            <h3>‚ö†Ô∏è Please Run a Local Web Server</h3>
                            <p>For best results, serve this file from a local web server instead of opening directly.</p>
                            <p style={{marginTop: '10px'}}>
                                <strong>Quick Fix:</strong> Open terminal in this folder and run:
                            </p>
                            <p style={{marginTop: '5px'}}>
                                <code>python3 -m http.server 8000</code>
                            </p>
                            <p style={{marginTop: '5px'}}>
                                Then open: <code>http://localhost:8000/8d-player-live.html</code>
                            </p>
                            <button onClick={() => setShowFileWarning(false)}>Dismiss (Try Anyway)</button>
                        </div>
                    )}

                    <div className="main-layout">
                        <div className="main-card">
                            <div className="player-section">
                                <div className="now-playing">
                                    <h2>Now Playing</h2>
                                    <div className="track-name">
                                        {currentTrackIndex !== null ? playlist[currentTrackIndex]?.name : 'No track selected'}
                                    </div>
                                    {isPlaying && <div className="playing-indicator">üéµ</div>}
                                </div>

                                <div className="player-controls">
                                    <button className="player-btn" onClick={playPrevious}>‚èÆÔ∏è</button>
                                    <button className="player-btn play" onClick={togglePlayPause}>
                                        {isPlaying ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è'}
                                    </button>
                                    <button className="player-btn" onClick={playNext}>‚è≠Ô∏è</button>
                                </div>

                                <div className="progress-container">
                                    <div className="progress-bar" onClick={seekTo}>
                                        <div 
                                            className="progress-fill" 
                                            style={{width: `${duration ? (currentTime / duration) * 100 : 0}%`}}
                                        />
                                    </div>
                                    <div className="time-display">
                                        <span>{formatTime(currentTime)}</span>
                                        <span>{formatTime(duration)}</span>
                                    </div>
                                </div>

                                <div className="control-group" style={{marginTop: '20px'}}>
                                    <label>Volume</label>
                                    <input 
                                        type="range" 
                                        min="0" 
                                        max="1" 
                                        step="0.05"
                                        value={volume}
                                        onChange={(e) => setVolume(parseFloat(e.target.value))}
                                    />
                                    <div className="value-display">{(volume * 100).toFixed(0)}%</div>
                                </div>
                            </div>

                            {showVisualizer && (
                                <div className="visualizer">
                                    <canvas ref={canvasRef} width="800" height="150"></canvas>
                                </div>
                            )}

                            <div className="preset-buttons">
                                <button className="preset-btn focus" onClick={() => applyPreset('focus')}>
                                    üéØ Focus
                                </button>
                                <button className="preset-btn energy" onClick={() => applyPreset('energy')}>
                                    ‚ö° Energy
                                </button>
                                <button className="preset-btn relax" onClick={() => applyPreset('relax')}>
                                    üòå Relax
                                </button>
                            </div>

                            <div className="controls">
                                <div className="control-group">
                                    <label>Rotation Speed</label>
                                    <input 
                                        type="range" 
                                        min="0.1" 
                                        max="2.0" 
                                        step="0.1"
                                        value={speed}
                                        onChange={(e) => setSpeed(parseFloat(e.target.value))}
                                    />
                                    <div className="value-display">{speed.toFixed(1)}x</div>
                                </div>

                                <div className="control-group">
                                    <label>Effect Intensity</label>
                                    <input 
                                        type="range" 
                                        min="0.0" 
                                        max="1.0" 
                                        step="0.1"
                                        value={intensity}
                                        onChange={(e) => setIntensity(parseFloat(e.target.value))}
                                    />
                                    <div className="value-display">{(intensity * 100).toFixed(0)}%</div>
                                </div>

                                <div className="control-group">
                                    <label>Spatial Depth</label>
                                    <input 
                                        type="range" 
                                        min="0.0" 
                                        max="1.0" 
                                        step="0.1"
                                        value={spatialDepth}
                                        onChange={(e) => setSpatialDepth(parseFloat(e.target.value))}
                                    />
                                    <div className="value-display">{(spatialDepth * 100).toFixed(0)}%</div>
                                </div>

                                <div className="control-group">
                                    <label>Movement Pattern</label>
                                    <select value={movementPattern} onChange={(e) => setMovementPattern(e.target.value)}>
                                        <option value="circle">üîÑ Circle</option>
                                        <option value="figure8">‚àû Figure-8</option>
                                        <option value="leftright">‚ÜîÔ∏è Left-Right</option>
                                        <option value="frontback">‚ÜïÔ∏è Front-Back</option>
                                        <option value="random">üé≤ Random</option>
                                    </select>
                                </div>

                                <div className="control-group">
                                    <label>
                                        Binaural Beats
                                        {binauralEnabled && <span className="info-badge">{getBinauralDescription(binauralFreq)}</span>}
                                    </label>
                                    <div className="checkbox-wrapper">
                                        <input 
                                            type="checkbox" 
                                            checked={binauralEnabled}
                                            onChange={(e) => setBinauralEnabled(e.target.checked)}
                                        />
                                        <span>Enable</span>
                                    </div>
                                    {binauralEnabled && (
                                        <>
                                            <input 
                                                type="range" 
                                                min="1" 
                                                max="40" 
                                                step="1"
                                                value={binauralFreq}
                                                onChange={(e) => setBinauralFreq(parseInt(e.target.value))}
                                                style={{marginTop: '10px'}}
                                            />
                                            <div className="value-display">{binauralFreq}Hz</div>
                                        </>
                                    )}
                                </div>

                                <div className="control-group">
                                    <label>Background Noise</label>
                                    <select value={noiseType} onChange={(e) => setNoiseType(e.target.value)}>
                                        <option value="none">None</option>
                                        <option value="white">White Noise</option>
                                        <option value="pink">Pink Noise</option>
                                    </select>
                                    {noiseType !== 'none' && (
                                        <>
                                            <input 
                                                type="range" 
                                                min="0.0" 
                                                max="0.5" 
                                                step="0.05"
                                                value={noiseVolume}
                                                onChange={(e) => setNoiseVolume(parseFloat(e.target.value))}
                                                style={{marginTop: '10px'}}
                                            />
                                            <div className="value-display">{(noiseVolume * 100).toFixed(0)}%</div>
                                        </>
                                    )}
                                </div>
                            </div>
                        </div>

                        <div className="playlist-card">
                            <div className="playlist-header">
                                <h2>Playlist ({playlist.length} tracks)</h2>
                            </div>

                            <div className="add-source">
                                <h3>Add Local Files</h3>
                                <div 
                                    className="drop-zone"
                                    onClick={() => fileInputRef.current.click()}
                                    onDrop={handleDrop}
                                    onDragOver={handleDragOver}
                                    onDragEnter={handleDragEnter}
                                    onDragLeave={handleDragLeave}
                                >
                                    <div>üìÅ Click or Drop MP3 Files</div>
                                </div>
                                <input 
                                    ref={fileInputRef}
                                    type="file" 
                                    accept="audio/mpeg,.mp3"
                                    multiple
                                    style={{display: 'none'}}
                                    onChange={(e) => addLocalFiles(e.target.files)}
                                />

                                <h3 style={{marginTop: '20px'}}>Add from URL</h3>
                                <div className="input-group">
                                    <input 
                                        type="text"
                                        placeholder="MP3 URL (YouTube needs backend)"
                                        value={urlInput}
                                        onChange={(e) => setUrlInput(e.target.value)}
                                        onKeyPress={(e) => e.key === 'Enter' && addUrl()}
                                    />
                                    <button className="btn btn-primary" onClick={addUrl}>
                                        Add
                                    </button>
                                </div>
                            </div>

                            <div className="playlist-items">
                                {playlist.length === 0 ? (
                                    <div style={{textAlign: 'center', padding: '40px', color: 'var(--text-secondary)'}}>
                                        <p>No tracks yet</p>
                                        <p style={{marginTop: '10px', fontSize: '0.9rem'}}>
                                            Add local MP3s or URLs to get started!
                                        </p>
                                    </div>
                                ) : (
                                    playlist.map((track, index) => (
                                        <div 
                                            key={track.id}
                                            className={`playlist-item ${currentTrackIndex === index ? 'playing' : ''}`}
                                            onClick={() => playTrack(index)}
                                        >
                                            <div className="icon">
                                                {track.source === 'local' && 'üéµ'}
                                                {track.source === 'url' && 'üåê'}
                                                {track.source === 'youtube' && 'üì∫'}
                                            </div>
                                            <div className="info">
                                                <div className="name">{track.name}</div>
                                                <div className="source">{track.source}</div>
                                            </div>
                                            <div className="actions">
                                                <button onClick={(e) => {
                                                    e.stopPropagation();
                                                    removeFromPlaylist(track.id);
                                                }}>
                                                    üóëÔ∏è
                                                </button>
                                            </div>
                                        </div>
                                    ))
                                )}
                            </div>

                            {playlist.length > 0 && (
                                <div className="playlist-stats">
                                    <div>Total Tracks: {playlist.length}</div>
                                    <div>Est. Duration: ~{Math.floor(getTotalDuration())} min</div>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>