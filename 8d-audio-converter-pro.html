<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8D Audio Converter Pro - ADHD Focus Edition</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-gradient-start: #667eea;
            --bg-gradient-end: #764ba2;
            --card-bg: white;
            --text-primary: #333;
            --text-secondary: #666;
            --text-inverse: white;
            --control-bg: #f8f9fa;
            --border-color: #e9ecef;
            --shadow: rgba(0,0,0,0.3);
        }

        body.dark-mode {
            --bg-gradient-start: #1a1a2e;
            --bg-gradient-end: #16213e;
            --card-bg: #0f3460;
            --text-primary: #e9e9e9;
            --text-secondary: #b0b0b0;
            --text-inverse: white;
            --control-bg: #1a2332;
            --border-color: #2a3f5f;
            --shadow: rgba(0,0,0,0.6);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            min-height: 100vh;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: var(--text-inverse);
            margin-bottom: 30px;
            position: relative;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px var(--shadow);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.95;
        }

        .dark-mode-toggle {
            position: absolute;
            top: 0;
            right: 0;
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 20px;
            padding: 10px 20px;
            color: white;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s ease;
        }

        .dark-mode-toggle:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.05);
        }

        .main-card {
            background: var(--card-bg);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px var(--shadow);
            color: var(--text-primary);
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--border-color);
            flex-wrap: wrap;
        }

        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .tab:hover {
            color: #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .drop-zone {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 60px 20px;
            text-align: center;
            background: var(--control-bg);
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 30px;
        }

        .drop-zone:hover, .drop-zone.drag-over {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: white;
            color: white;
            transform: scale(1.02);
        }

        .drop-zone-icon {
            font-size: 4rem;
            margin-bottom: 15px;
        }

        .drop-zone h3 {
            font-size: 1.5rem;
            margin-bottom: 10px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: var(--control-bg);
            padding: 20px;
            border-radius: 10px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: var(--border-color);
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }

        .control-group select {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 2px solid var(--border-color);
            background: var(--card-bg);
            color: var(--text-primary);
            font-size: 1rem;
            cursor: pointer;
        }

        .control-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .value-display {
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            color: #667eea;
            margin-top: 5px;
        }

        .preset-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .preset-btn {
            flex: 1;
            min-width: 150px;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
        }

        .preset-btn.focus {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
        }

        .preset-btn.energy {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }

        .preset-btn.relax {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
        }

        .preset-btn.custom {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .preset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px var(--shadow);
        }

        .custom-presets {
            margin-top: 20px;
            padding: 20px;
            background: var(--control-bg);
            border-radius: 10px;
        }

        .custom-preset-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            margin-bottom: 10px;
            background: var(--card-bg);
            border-radius: 8px;
        }

        .custom-preset-name {
            flex: 1;
            font-weight: 600;
        }

        .queue {
            margin-top: 30px;
        }

        .queue h2 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: var(--text-primary);
        }

        .queue-item {
            background: var(--control-bg);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
            transition: all 0.3s ease;
        }

        .queue-item:hover {
            background: var(--border-color);
        }

        .queue-item.processing {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .queue-item.completed {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            color: white;
        }

        .queue-icon {
            font-size: 2rem;
            flex-shrink: 0;
        }

        .queue-info {
            flex: 1;
        }

        .queue-name {
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 5px;
        }

        .queue-status {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 8px;
        }

        .progress-fill {
            height: 100%;
            background: white;
            transition: width 0.3s ease;
        }

        .queue-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #43e97b;
            color: white;
        }

        .btn-success:hover {
            background: #38d66a;
        }

        .btn-danger {
            background: #fa709a;
            color: white;
        }

        .btn-danger:hover {
            background: #e95e87;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .process-all-btn {
            width: 100%;
            padding: 20px;
            font-size: 1.2rem;
            margin-top: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .process-all-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px var(--shadow);
        }

        .process-all-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .empty-queue {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }

        canvas {
            width: 100%;
            height: 200px;
            background: var(--control-bg);
            border-radius: 10px;
            margin-top: 10px;
        }

        .visualizer-container {
            margin-top: 20px;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .spinning {
            animation: spin 2s linear infinite;
        }

        .info-badge {
            display: inline-block;
            padding: 4px 10px;
            background: #667eea;
            color: white;
            border-radius: 12px;
            font-size: 0.8rem;
            margin-left: 10px;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .input-group input {
            flex: 1;
            padding: 10px;
            border-radius: 8px;
            border: 2px solid var(--border-color);
            background: var(--card-bg);
            color: var(--text-primary);
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        function App() {
            const [files, setFiles] = useState([]);
            const [speed, setSpeed] = useState(0.5);
            const [intensity, setIntensity] = useState(0.8);
            const [spatialDepth, setSpatialDepth] = useState(0.6);
            const [movementPattern, setMovementPattern] = useState('circle');
            const [binauralEnabled, setBinauralEnabled] = useState(false);
            const [binauralFreq, setBinauralFreq] = useState(14);
            const [noiseType, setNoiseType] = useState('none');
            const [noiseVolume, setNoiseVolume] = useState(0.1);
            const [loopEnabled, setLoopEnabled] = useState(false);
            const [outputFormat, setOutputFormat] = useState('wav');
            const [darkMode, setDarkMode] = useState(false);
            const [processing, setProcessing] = useState(false);
            const [dragOver, setDragOver] = useState(false);
            const [activeTab, setActiveTab] = useState('upload');
            const [customPresets, setCustomPresets] = useState([]);
            const [newPresetName, setNewPresetName] = useState('');
            const [showVisualizer, setShowVisualizer] = useState(false);
            
            const fileInputRef = useRef(null);
            const audioContextRef = useRef(null);
            const waveformCanvasRef = useRef(null);
            const frequencyCanvasRef = useRef(null);

            useEffect(() => {
                audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
                
                // Load custom presets from localStorage
                const savedPresets = localStorage.getItem('customPresets');
                if (savedPresets) {
                    setCustomPresets(JSON.parse(savedPresets));
                }
                
                // Check for dark mode preference
                const savedDarkMode = localStorage.getItem('darkMode');
                if (savedDarkMode === 'true') {
                    setDarkMode(true);
                    document.body.classList.add('dark-mode');
                }
                
                return () => {
                    if (audioContextRef.current) {
                        audioContextRef.current.close();
                    }
                };
            }, []);

            const toggleDarkMode = () => {
                setDarkMode(!darkMode);
                document.body.classList.toggle('dark-mode');
                localStorage.setItem('darkMode', !darkMode);
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                setDragOver(true);
            };

            const handleDragLeave = () => {
                setDragOver(false);
            };

            const handleDrop = (e) => {
                e.preventDefault();
                setDragOver(false);
                const droppedFiles = Array.from(e.dataTransfer.files).filter(
                    f => f.type === 'audio/mpeg' || f.name.endsWith('.mp3')
                );
                addFilesToQueue(droppedFiles);
            };

            const handleFileSelect = (e) => {
                const selectedFiles = Array.from(e.target.files);
                addFilesToQueue(selectedFiles);
            };

            const addFilesToQueue = (newFiles) => {
                const fileObjects = newFiles.map((file, index) => ({
                    id: Date.now() + index,
                    file: file,
                    name: file.name,
                    status: 'pending',
                    progress: 0,
                    outputUrl: null
                }));
                setFiles(prev => [...prev, ...fileObjects]);
            };

            const removeFile = (id) => {
                setFiles(prev => prev.filter(f => f.id !== id));
            };

            const applyPreset = (preset) => {
                switch(preset) {
                    case 'focus':
                        setSpeed(0.4);
                        setIntensity(0.7);
                        setSpatialDepth(0.5);
                        setBinauralEnabled(true);
                        setBinauralFreq(14);
                        setMovementPattern('circle');
                        break;
                    case 'energy':
                        setSpeed(1.0);
                        setIntensity(0.9);
                        setSpatialDepth(0.8);
                        setBinauralEnabled(true);
                        setBinauralFreq(40);
                        setMovementPattern('figure8');
                        break;
                    case 'relax':
                        setSpeed(0.3);
                        setIntensity(0.6);
                        setSpatialDepth(0.4);
                        setBinauralEnabled(true);
                        setBinauralFreq(8);
                        setMovementPattern('circle');
                        break;
                }
            };

            const saveCustomPreset = () => {
                if (!newPresetName.trim()) return;
                
                const preset = {
                    id: Date.now(),
                    name: newPresetName,
                    speed,
                    intensity,
                    spatialDepth,
                    movementPattern,
                    binauralEnabled,
                    binauralFreq,
                    noiseType,
                    noiseVolume
                };
                
                const newPresets = [...customPresets, preset];
                setCustomPresets(newPresets);
                localStorage.setItem('customPresets', JSON.stringify(newPresets));
                setNewPresetName('');
            };

            const loadCustomPreset = (preset) => {
                setSpeed(preset.speed);
                setIntensity(preset.intensity);
                setSpatialDepth(preset.spatialDepth);
                setMovementPattern(preset.movementPattern);
                setBinauralEnabled(preset.binauralEnabled);
                setBinauralFreq(preset.binauralFreq);
                setNoiseType(preset.noiseType);
                setNoiseVolume(preset.noiseVolume);
            };

            const deleteCustomPreset = (id) => {
                const newPresets = customPresets.filter(p => p.id !== id);
                setCustomPresets(newPresets);
                localStorage.setItem('customPresets', JSON.stringify(newPresets));
            };

            const generateNoise = (type, length, sampleRate) => {
                const buffer = new Float32Array(length);
                
                if (type === 'white') {
                    for (let i = 0; i < length; i++) {
                        buffer[i] = Math.random() * 2 - 1;
                    }
                } else if (type === 'pink') {
                    let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
                    for (let i = 0; i < length; i++) {
                        const white = Math.random() * 2 - 1;
                        b0 = 0.99886 * b0 + white * 0.0555179;
                        b1 = 0.99332 * b1 + white * 0.0750759;
                        b2 = 0.96900 * b2 + white * 0.1538520;
                        b3 = 0.86650 * b3 + white * 0.3104856;
                        b4 = 0.55000 * b4 + white * 0.5329522;
                        b5 = -0.7616 * b5 - white * 0.0168980;
                        buffer[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                        buffer[i] *= 0.11;
                        b6 = white * 0.115926;
                    }
                }
                
                return buffer;
            };

            const generateBinauralBeat = (frequency, length, sampleRate, baseFreq = 200) => {
                const leftChannel = new Float32Array(length);
                const rightChannel = new Float32Array(length);
                
                for (let i = 0; i < length; i++) {
                    const t = i / sampleRate;
                    leftChannel[i] = Math.sin(2 * Math.PI * baseFreq * t) * 0.1;
                    rightChannel[i] = Math.sin(2 * Math.PI * (baseFreq + frequency) * t) * 0.1;
                }
                
                return { leftChannel, rightChannel };
            };

            const calculatePanning = (time, pattern, speed, intensity) => {
                const angle = 2 * Math.PI * speed * time;
                let panPosition = 0;
                
                switch(pattern) {
                    case 'circle':
                        panPosition = Math.sin(angle) * intensity;
                        break;
                    case 'figure8':
                        panPosition = Math.sin(angle) * Math.cos(angle / 2) * intensity;
                        break;
                    case 'leftright':
                        panPosition = Math.sin(angle) * intensity;
                        break;
                    case 'frontback':
                        // Simulate front-back by varying volume
                        panPosition = Math.cos(angle) * intensity * 0.5;
                        break;
                    case 'random':
                        if (Math.floor(time * 10) % 10 === 0) {
                            panPosition = (Math.random() * 2 - 1) * intensity;
                        }
                        break;
                    default:
                        panPosition = Math.sin(angle) * intensity;
                }
                
                return panPosition;
            };

            const process8DAudio = async (fileObj) => {
                return new Promise(async (resolve) => {
                    const audioContext = audioContextRef.current;
                    const reader = new FileReader();

                    reader.onload = async (e) => {
                        try {
                            const arrayBuffer = e.target.result;
                            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                            const sampleRate = audioBuffer.sampleRate;
                            const channels = audioBuffer.numberOfChannels;
                            const leftChannel = audioBuffer.getChannelData(0);
                            const rightChannel = channels > 1 ? audioBuffer.getChannelData(1) : leftChannel;

                            // Create output buffer
                            const outputBuffer = audioContext.createBuffer(2, audioBuffer.length, sampleRate);
                            const outputLeft = outputBuffer.getChannelData(0);
                            const outputRight = outputBuffer.getChannelData(1);

                            // Generate binaural beats if enabled
                            let binauralLeft = null, binauralRight = null;
                            if (binauralEnabled) {
                                const binaural = generateBinauralBeat(binauralFreq, audioBuffer.length, sampleRate);
                                binauralLeft = binaural.leftChannel;
                                binauralRight = binaural.rightChannel;
                            }

                            // Generate noise if enabled
                            let noiseBuffer = null;
                            if (noiseType !== 'none') {
                                noiseBuffer = generateNoise(noiseType, audioBuffer.length, sampleRate);
                            }

                            // Apply 8D effect with selected pattern
                            const numSamples = audioBuffer.length;

                            for (let i = 0; i < numSamples; i++) {
                                const time = i / sampleRate;
                                const panPosition = calculatePanning(time, movementPattern, speed, intensity);
                                
                                // MUCH MORE AGGRESSIVE panning for stronger effect
                                const leftGain = Math.max(0, (1 - panPosition) / 2);
                                const rightGain = Math.max(0, (1 + panPosition) / 2);
                                
                                const monoSignal = (leftChannel[i] + rightChannel[i]) / 2;
                                
                                // Apply stronger intensity boost
                                const intensityBoost = 1.5;
                                outputLeft[i] = monoSignal * leftGain * 2 * intensityBoost;
                                outputRight[i] = monoSignal * rightGain * 2 * intensityBoost;

                                // Update progress
                                if (i % 44100 === 0) {
                                    const progress = (i / numSamples) * 100;
                                    setFiles(prev => prev.map(f => 
                                        f.id === fileObj.id ? {...f, progress} : f
                                    ));
                                }
                            }

                            // Add STRONGER echo effect for spatial depth
                            const delaySamples = Math.floor(0.05 * sampleRate);
                            const echoStrength = 0.4 * spatialDepth; // Increased from 0.25

                            for (let i = delaySamples; i < numSamples; i++) {
                                outputLeft[i] += outputLeft[i - delaySamples] * echoStrength;
                                outputRight[i] += outputRight[i - delaySamples] * echoStrength;
                            }

                            // Add STRONGER cross-channel delay for more depth
                            const crossDelay = Math.floor(0.03 * sampleRate); // Increased from 0.02
                            const crossStrength = 0.2 * spatialDepth; // Doubled from 0.1
                            for (let i = crossDelay; i < numSamples; i++) {
                                outputLeft[i] += outputRight[i - crossDelay] * crossStrength;
                                outputRight[i] += outputLeft[i - crossDelay] * crossStrength;
                            }
                            
                            // Add second echo layer for MAXIMUM spatial depth when > 50%
                            if (spatialDepth > 0.5) {
                                const delay2 = Math.floor(0.1 * sampleRate);
                                const strength2 = 0.2 * spatialDepth;
                                for (let i = delay2; i < numSamples; i++) {
                                    outputLeft[i] += outputLeft[i - delay2] * strength2;
                                    outputRight[i] += outputRight[i - delay2] * strength2;
                                }
                            }

                            // Normalize the main 8D audio first (before adding binaural/noise)
                            let maxSample = 0;
                            for (let i = 0; i < numSamples; i++) {
                                maxSample = Math.max(maxSample, Math.abs(outputLeft[i]), Math.abs(outputRight[i]));
                            }
                            const normalizationFactor = maxSample > 0 ? 0.9 / maxSample : 1;
                            for (let i = 0; i < numSamples; i++) {
                                outputLeft[i] *= normalizationFactor;
                                outputRight[i] *= normalizationFactor;
                            }
                            
                            // NOW add binaural beats and noise (won't dilute the 8D effect)
                            for (let i = 0; i < numSamples; i++) {
                                if (binauralEnabled && binauralLeft && binauralRight) {
                                    // Mix in binaural beats subtly
                                    outputLeft[i] = outputLeft[i] * 0.9 + binauralLeft[i] * 0.1;
                                    outputRight[i] = outputRight[i] * 0.9 + binauralRight[i] * 0.1;
                                }

                                if (noiseBuffer) {
                                    // Mix in noise based on volume setting
                                    outputLeft[i] = outputLeft[i] * (1 - noiseVolume) + noiseBuffer[i] * noiseVolume;
                                    outputRight[i] = outputRight[i] * (1 - noiseVolume) + noiseBuffer[i] * noiseVolume;
                                }
                            }
                            
                            // Final gentle normalization to prevent any clipping
                            maxSample = 0;
                            for (let i = 0; i < numSamples; i++) {
                                maxSample = Math.max(maxSample, Math.abs(outputLeft[i]), Math.abs(outputRight[i]));
                            }
                            if (maxSample > 0.95) {
                                const finalNorm = 0.95 / maxSample;
                                for (let i = 0; i < numSamples; i++) {
                                    outputLeft[i] *= finalNorm;
                                    outputRight[i] *= finalNorm;
                                }
                            }

                            // Draw waveform if visualizer is enabled
                            if (showVisualizer && waveformCanvasRef.current) {
                                drawWaveform(outputLeft, outputRight);
                            }

                            // Convert to selected format
                            let blob;
                            if (outputFormat === 'wav') {
                                blob = bufferToWave(outputBuffer, sampleRate);
                            } else {
                                // For now, export as WAV (MP3/FLAC encoding requires additional libraries)
                                blob = bufferToWave(outputBuffer, sampleRate);
                            }
                            
                            const url = URL.createObjectURL(blob);

                            resolve({ success: true, url });
                        } catch (error) {
                            console.error('Processing error:', error);
                            resolve({ success: false, error: error.message });
                        }
                    };

                    reader.readAsArrayBuffer(fileObj.file);
                });
            };

            const drawWaveform = (leftChannel, rightChannel) => {
                const canvas = waveformCanvasRef.current;
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.fillStyle = darkMode ? '#1a2332' : '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                const step = Math.ceil(leftChannel.length / width);
                const amp = height / 4;
                
                // Draw left channel (top half)
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < width; i++) {
                    const min = Math.min(...Array.from(leftChannel.slice(i * step, (i + 1) * step)));
                    const max = Math.max(...Array.from(leftChannel.slice(i * step, (i + 1) * step)));
                    ctx.lineTo(i, height / 4 - min * amp);
                }
                ctx.stroke();
                
                // Draw right channel (bottom half)
                ctx.strokeStyle = '#764ba2';
                ctx.beginPath();
                for (let i = 0; i < width; i++) {
                    const min = Math.min(...Array.from(rightChannel.slice(i * step, (i + 1) * step)));
                    const max = Math.max(...Array.from(rightChannel.slice(i * step, (i + 1) * step)));
                    ctx.lineTo(i, 3 * height / 4 - min * amp);
                }
                ctx.stroke();
            };

            const bufferToWave = (abuffer, sampleRate) => {
                const numOfChan = abuffer.numberOfChannels;
                const length = abuffer.length * numOfChan * 2 + 44;
                const buffer = new ArrayBuffer(length);
                const view = new DataView(buffer);
                const channels = [];
                let i, sample, offset = 0, pos = 0;

                const setUint16 = (data) => {
                    view.setUint16(pos, data, true);
                    pos += 2;
                };

                const setUint32 = (data) => {
                    view.setUint32(pos, data, true);
                    pos += 4;
                };

                setUint32(0x46464952);
                setUint32(length - 8);
                setUint32(0x45564157);
                setUint32(0x20746d66);
                setUint32(16);
                setUint16(1);
                setUint16(numOfChan);
                setUint32(sampleRate);
                setUint32(sampleRate * 2 * numOfChan);
                setUint16(numOfChan * 2);
                setUint16(16);
                setUint32(0x61746164);
                setUint32(length - pos - 4);

                for (i = 0; i < abuffer.numberOfChannels; i++)
                    channels.push(abuffer.getChannelData(i));

                while (pos < length) {
                    for (i = 0; i < numOfChan; i++) {
                        sample = Math.max(-1, Math.min(1, channels[i][offset]));
                        sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0;
                        view.setInt16(pos, sample, true);
                        pos += 2;
                    }
                    offset++;
                }

                return new Blob([buffer], { type: 'audio/wav' });
            };

            const processAllFiles = async () => {
                setProcessing(true);
                
                for (let i = 0; i < files.length; i++) {
                    const fileObj = files[i];
                    
                    if (fileObj.status === 'completed') continue;

                    setFiles(prev => prev.map(f => 
                        f.id === fileObj.id ? {...f, status: 'processing', progress: 0} : f
                    ));

                    const result = await process8DAudio(fileObj);

                    setFiles(prev => prev.map(f => 
                        f.id === fileObj.id 
                            ? {...f, status: 'completed', progress: 100, outputUrl: result.url}
                            : f
                    ));
                }

                setProcessing(false);
            };

            const downloadFile = (fileObj) => {
                if (fileObj.outputUrl) {
                    const a = document.createElement('a');
                    a.href = fileObj.outputUrl;
                    const extension = outputFormat === 'wav' ? 'wav' : 'wav';
                    a.download = fileObj.name.replace('.mp3', `_8d.${extension}`);
                    a.click();
                }
            };

            const getBinauralDescription = (freq) => {
                if (freq <= 4) return 'Delta (Deep Sleep)';
                if (freq <= 8) return 'Theta (Meditation)';
                if (freq <= 14) return 'Alpha (Relaxation)';
                if (freq <= 30) return 'Beta (Focus)';
                return 'Gamma (Peak Focus)';
            };

            return (
                <div className="container">
                    <div className="header">
                        <button className="dark-mode-toggle" onClick={toggleDarkMode}>
                            {darkMode ? '‚òÄÔ∏è' : 'üåô'}
                        </button>
                        <h1>üéß 8D Audio Converter Pro</h1>
                        <p>Advanced ADHD Focus Audio ‚Ä¢ Binaural Beats ‚Ä¢ Custom Presets ‚Ä¢ Real-time Processing</p>
                    </div>

                    <div className="main-card">
                        <div className="tabs">
                            <button 
                                className={`tab ${activeTab === 'upload' ? 'active' : ''}`}
                                onClick={() => setActiveTab('upload')}
                            >
                                üìÅ Upload & Process
                            </button>
                            <button 
                                className={`tab ${activeTab === 'settings' ? 'active' : ''}`}
                                onClick={() => setActiveTab('settings')}
                            >
                                ‚öôÔ∏è Advanced Settings
                            </button>
                            <button 
                                className={`tab ${activeTab === 'presets' ? 'active' : ''}`}
                                onClick={() => setActiveTab('presets')}
                            >
                                üíæ Custom Presets
                            </button>
                            <button 
                                className={`tab ${activeTab === 'visualizer' ? 'active' : ''}`}
                                onClick={() => setActiveTab('visualizer')}
                            >
                                üìä Visualizer
                            </button>
                        </div>

                        <div className={`tab-content ${activeTab === 'upload' ? 'active' : ''}`}>
                            <div 
                                className={`drop-zone ${dragOver ? 'drag-over' : ''}`}
                                onDragOver={handleDragOver}
                                onDragLeave={handleDragLeave}
                                onDrop={handleDrop}
                                onClick={() => fileInputRef.current.click()}
                            >
                                <div className="drop-zone-icon">üéµ</div>
                                <h3>Drop MP3 files here or click to browse</h3>
                                <p>Add multiple files at once</p>
                            </div>
                            <input 
                                ref={fileInputRef}
                                type="file" 
                                accept="audio/mpeg,.mp3"
                                multiple
                                style={{display: 'none'}}
                                onChange={handleFileSelect}
                            />

                            <div className="preset-buttons">
                                <button className="preset-btn focus" onClick={() => applyPreset('focus')}>
                                    üéØ Focus Mode
                                </button>
                                <button className="preset-btn energy" onClick={() => applyPreset('energy')}>
                                    ‚ö° Energy Boost
                                </button>
                                <button className="preset-btn relax" onClick={() => applyPreset('relax')}>
                                    üòå Relaxation
                                </button>
                            </div>

                            <div className="controls">
                                <div className="control-group">
                                    <label>Rotation Speed</label>
                                    <input 
                                        type="range" 
                                        min="0.1" 
                                        max="2.0" 
                                        step="0.1"
                                        value={speed}
                                        onChange={(e) => setSpeed(parseFloat(e.target.value))}
                                    />
                                    <div className="value-display">{speed.toFixed(1)}x</div>
                                </div>

                                <div className="control-group">
                                    <label>Effect Intensity</label>
                                    <input 
                                        type="range" 
                                        min="0.0" 
                                        max="1.0" 
                                        step="0.1"
                                        value={intensity}
                                        onChange={(e) => setIntensity(parseFloat(e.target.value))}
                                    />
                                    <div className="value-display">{(intensity * 100).toFixed(0)}%</div>
                                </div>

                                <div className="control-group">
                                    <label>Spatial Depth</label>
                                    <input 
                                        type="range" 
                                        min="0.0" 
                                        max="1.0" 
                                        step="0.1"
                                        value={spatialDepth}
                                        onChange={(e) => setSpatialDepth(parseFloat(e.target.value))}
                                    />
                                    <div className="value-display">{(spatialDepth * 100).toFixed(0)}%</div>
                                </div>
                            </div>
                        </div>

                        <div className={`tab-content ${activeTab === 'settings' ? 'active' : ''}`}>
                            <div className="controls">
                                <div className="control-group">
                                    <label>Movement Pattern</label>
                                    <select value={movementPattern} onChange={(e) => setMovementPattern(e.target.value)}>
                                        <option value="circle">üîÑ Circle (Classic 8D)</option>
                                        <option value="figure8">‚àû Figure-8</option>
                                        <option value="leftright">‚ÜîÔ∏è Left-Right Only</option>
                                        <option value="frontback">‚ÜïÔ∏è Front-Back</option>
                                        <option value="random">üé≤ Random Movement</option>
                                    </select>
                                </div>

                                <div className="control-group">
                                    <label>
                                        Binaural Beats
                                        <span className="info-badge">{getBinauralDescription(binauralFreq)}</span>
                                    </label>
                                    <div className="checkbox-wrapper">
                                        <input 
                                            type="checkbox" 
                                            checked={binauralEnabled}
                                            onChange={(e) => setBinauralEnabled(e.target.checked)}
                                        />
                                        <span>Enable {binauralFreq}Hz</span>
                                    </div>
                                    {binauralEnabled && (
                                        <>
                                            <input 
                                                type="range" 
                                                min="1" 
                                                max="40" 
                                                step="1"
                                                value={binauralFreq}
                                                onChange={(e) => setBinauralFreq(parseInt(e.target.value))}
                                                style={{marginTop: '10px'}}
                                            />
                                            <div className="value-display">{binauralFreq}Hz</div>
                                        </>
                                    )}
                                </div>

                                <div className="control-group">
                                    <label>Background Noise</label>
                                    <select value={noiseType} onChange={(e) => setNoiseType(e.target.value)}>
                                        <option value="none">üö´ None</option>
                                        <option value="white">‚ö™ White Noise</option>
                                        <option value="pink">üå∏ Pink Noise</option>
                                    </select>
                                    {noiseType !== 'none' && (
                                        <>
                                            <label style={{marginTop: '10px'}}>Noise Volume</label>
                                            <input 
                                                type="range" 
                                                min="0.0" 
                                                max="0.5" 
                                                step="0.05"
                                                value={noiseVolume}
                                                onChange={(e) => setNoiseVolume(parseFloat(e.target.value))}
                                            />
                                            <div className="value-display">{(noiseVolume * 100).toFixed(0)}%</div>
                                        </>
                                    )}
                                </div>

                                <div className="control-group">
                                    <label>Output Format</label>
                                    <select value={outputFormat} onChange={(e) => setOutputFormat(e.target.value)}>
                                        <option value="wav">üéµ WAV (Best Quality)</option>
                                        <option value="mp3">üé∂ MP3 (Coming Soon)</option>
                                        <option value="flac">üíø FLAC (Coming Soon)</option>
                                    </select>
                                </div>

                                <div className="control-group">
                                    <label>Audio Options</label>
                                    <div className="checkbox-wrapper">
                                        <input 
                                            type="checkbox" 
                                            checked={loopEnabled}
                                            onChange={(e) => setLoopEnabled(e.target.checked)}
                                        />
                                        <span>Enable Looping (for continuous playback)</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div className={`tab-content ${activeTab === 'presets' ? 'active' : ''}`}>
                            <h2>Save Your Perfect Settings</h2>
                            <div className="input-group">
                                <input 
                                    type="text"
                                    placeholder="Preset name (e.g., 'Deep Work Mode')"
                                    value={newPresetName}
                                    onChange={(e) => setNewPresetName(e.target.value)}
                                />
                                <button className="btn btn-primary" onClick={saveCustomPreset}>
                                    üíæ Save Current Settings
                                </button>
                            </div>

                            <div className="custom-presets">
                                <h3>Your Custom Presets</h3>
                                {customPresets.length === 0 ? (
                                    <p style={{color: 'var(--text-secondary)', textAlign: 'center', padding: '20px'}}>
                                        No custom presets yet. Create one above!
                                    </p>
                                ) : (
                                    customPresets.map(preset => (
                                        <div key={preset.id} className="custom-preset-item">
                                            <div className="custom-preset-name">{preset.name}</div>
                                            <button 
                                                className="btn btn-primary"
                                                onClick={() => loadCustomPreset(preset)}
                                            >
                                                Load
                                            </button>
                                            <button 
                                                className="btn btn-danger"
                                                onClick={() => deleteCustomPreset(preset.id)}
                                            >
                                                Delete
                                            </button>
                                        </div>
                                    ))
                                )}
                            </div>
                        </div>

                        <div className={`tab-content ${activeTab === 'visualizer' ? 'active' : ''}`}>
                            <div className="visualizer-container">
                                <h2>Audio Visualizer</h2>
                                <div className="checkbox-wrapper" style={{marginBottom: '20px'}}>
                                    <input 
                                        type="checkbox" 
                                        checked={showVisualizer}
                                        onChange={(e) => setShowVisualizer(e.target.checked)}
                                    />
                                    <span>Enable waveform visualization during processing</span>
                                </div>
                                
                                <h3>Waveform</h3>
                                <canvas ref={waveformCanvasRef} width="800" height="200"></canvas>
                                
                                <h3 style={{marginTop: '20px'}}>Frequency Analyzer</h3>
                                <canvas ref={frequencyCanvasRef} width="800" height="200"></canvas>
                                <p style={{color: 'var(--text-secondary)', marginTop: '10px', fontSize: '0.9rem'}}>
                                    Visualizations appear when processing audio files
                                </p>
                            </div>
                        </div>

                        {files.length > 0 && (
                            <div className="queue">
                                <h2>Processing Queue ({files.length} files)</h2>
                                {files.map(fileObj => (
                                    <div 
                                        key={fileObj.id} 
                                        className={`queue-item ${fileObj.status}`}
                                    >
                                        <div className={`queue-icon ${fileObj.status === 'processing' ? 'spinning' : ''}`}>
                                            {fileObj.status === 'pending' && '‚è±Ô∏è'}
                                            {fileObj.status === 'processing' && 'üîÑ'}
                                            {fileObj.status === 'completed' && '‚úÖ'}
                                        </div>
                                        <div className="queue-info">
                                            <div className="queue-name">{fileObj.name}</div>
                                            <div className="queue-status">
                                                {fileObj.status === 'pending' && 'Waiting to process...'}
                                                {fileObj.status === 'processing' && `Processing... ${fileObj.progress.toFixed(0)}%`}
                                                {fileObj.status === 'completed' && 'Ready to download!'}
                                            </div>
                                            {fileObj.status === 'processing' && (
                                                <div className="progress-bar">
                                                    <div 
                                                        className="progress-fill" 
                                                        style={{width: `${fileObj.progress}%`}}
                                                    />
                                                </div>
                                            )}
                                        </div>
                                        <div className="queue-actions">
                                            {fileObj.status === 'completed' && (
                                                <>
                                                    <button 
                                                        className="btn btn-success"
                                                        onClick={() => downloadFile(fileObj)}
                                                    >
                                                        Download
                                                    </button>
                                                    {fileObj.outputUrl && (
                                                        <audio 
                                                            controls 
                                                            src={fileObj.outputUrl}
                                                            loop={loopEnabled}
                                                            style={{maxWidth: '200px'}}
                                                        />
                                                    )}
                                                </>
                                            )}
                                            {fileObj.status === 'pending' && (
                                                <button 
                                                    className="btn btn-danger"
                                                    onClick={() => removeFile(fileObj.id)}
                                                >
                                                    Remove
                                                </button>
                                            )}
                                        </div>
                                    </div>
                                ))}
                                
                                <button 
                                    className="process-all-btn"
                                    onClick={processAllFiles}
                                    disabled={processing || files.every(f => f.status === 'completed')}
                                >
                                    {processing ? '‚è≥ Processing...' : 'üöÄ Process All Files'}
                                </button>
                            </div>
                        )}

                        {files.length === 0 && activeTab === 'upload' && (
                            <div className="empty-queue">
                                <p style={{fontSize: '1.2rem'}}>No files in queue yet</p>
                                <p style={{marginTop: '10px'}}>Add MP3 files above to get started!</p>
                            </div>
                        )}
                    </div>

                    <div style={{color: 'var(--text-inverse)', textAlign: 'center', marginTop: '30px', opacity: '0.9'}}>
                        <p>üí° Pro Tip: Use headphones for the full 8D experience!</p>
                        <p style={{marginTop: '10px', fontSize: '0.9rem'}}>
                            All processing happens in your browser ‚Ä¢ No uploads ‚Ä¢ 100% private ‚Ä¢ {customPresets.length} custom presets saved
                        </p>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>