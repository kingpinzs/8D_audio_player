<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8D Audio Player - Live Streaming Edition</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="./audio-engine.js"></script>
    <style>
        :root {
            --bg-1: #f4f6ff;
            --bg-2: #dfe7ff;
            --card-bg: rgba(255, 255, 255, 0.95);
            --card-border: rgba(15, 27, 68, 0.08);
            --surface: rgba(255, 255, 255, 0.7);
            --text-primary: #0c1440;
            --text-secondary: rgba(12, 20, 64, 0.7);
            --shadow-soft: 0 30px 60px rgba(15, 21, 56, 0.2);
            --accent-focus: #6d8bff;
            --accent-calm: #4edbc6;
            --accent-energize: #ffb562;
            --accent-default: #6d8bff;
            --chip-accent: var(--accent-default);
            --danger: #f05d7b;
            --positive: #3ad8a7;
            --grid-gap: 24px;
        }

        body.dark-mode {
            --bg-1: #05071c;
            --bg-2: #0c122d;
            --card-bg: rgba(7, 10, 30, 0.95);
            --card-border: rgba(255, 255, 255, 0.08);
            --surface: rgba(255, 255, 255, 0.04);
            --text-primary: #f5f7ff;
            --text-secondary: rgba(245, 247, 255, 0.7);
            --shadow-soft: 0 40px 90px rgba(0, 0, 0, 0.65);
        }

        /* High-contrast mode: WCAG AA compliant (‚â•4.5:1 normal text, ‚â•3:1 large text) */
        body.high-contrast {
            --bg-1: #ffffff;
            --bg-2: #f0f0f0;
            --card-bg: #ffffff;
            --card-border: #000000;
            --surface: #ffffff;
            --text-primary: #000000;
            --text-secondary: #000000;
            --shadow-soft: 0 2px 8px rgba(0, 0, 0, 0.3);
            --accent-focus: #0000ee;
            --accent-calm: #006060;
            --accent-energize: #cc5500;
            --accent-default: #0000ee;
            --danger: #cc0000;
            --positive: #008800;
        }

        /* High-contrast dark mode combination */
        body.dark-mode.high-contrast {
            --bg-1: #000000;
            --bg-2: #1a1a1a;
            --card-bg: #000000;
            --card-border: #ffffff;
            --surface: #000000;
            --text-primary: #ffffff;
            --text-secondary: #ffffff;
            --shadow-soft: 0 2px 8px rgba(255, 255, 255, 0.3);
            --accent-focus: #6699ff;
            --accent-calm: #00ffff;
            --accent-energize: #ffaa00;
            --accent-default: #6699ff;
            --danger: #ff6666;
            --positive: #00ff00;
        }

        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
            min-height: 100vh;
            background-image:
                radial-gradient(circle at 20% 20%, rgba(109, 139, 255, 0.25), transparent 45%),
                radial-gradient(circle at 80% 0%, rgba(255, 175, 123, 0.22), transparent 40%),
                linear-gradient(135deg, var(--bg-1), var(--bg-2));
            color: var(--text-primary);
            transition: background 0.35s ease, color 0.35s ease;
        }

        button, input, select, textarea {
            font: inherit;
        }

        .screen {
            max-width: 1440px;
            margin: 0 auto;
            padding: 32px clamp(16px, 4vw, 64px) 64px;
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .app-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 16px;
        }

        .app-header h1 {
            font-size: clamp(1.85rem, 3vw, 2.8rem);
            margin: 6px 0 8px;
        }

        .eyebrow {
            text-transform: uppercase;
            letter-spacing: 0.2em;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .header-actions {
            display: flex;
            gap: 12px;
        }

        .header-actions button {
            min-height: 48px;
            border-radius: 999px;
            padding: 0 20px;
            border: 1px solid var(--card-border);
            background: var(--surface);
            color: var(--text-primary);
            cursor: pointer;
            transition: transform 0.2s ease, border 0.2s ease;
        }

        .header-actions button:focus-visible {
            outline: 3px solid rgba(109, 139, 255, 0.7);
            outline-offset: 2px;
        }

        .primary-btn {
            background: linear-gradient(120deg, var(--accent-focus), #9f9bff);
            color: #fff;
            border: none;
            box-shadow: 0 20px 40px rgba(109, 139, 255, 0.35);
        }

        .ghost-btn {
            background: transparent;
            border: 1px dashed var(--card-border);
            color: var(--text-primary);
        }

        /* Design spec ¬ß3: Three-column grid layout for desktop ‚â•1280px (Ritual/Preset | Playback | Insights) */
        .main-grid {
            display: grid;
            grid-template-columns: minmax(280px, 360px) minmax(420px, 1fr) minmax(260px, 320px);
            gap: var(--grid-gap);
        }

        .column-card {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .panel {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 24px;
            padding: 24px;
            box-shadow: var(--shadow-soft);
        }

        /* Design spec ¬ß3: Mode tabs (Focus/Calm/Energize) with roving tabindex */
        .mode-tabs {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .mode-chip {
            flex: 1 1 140px;
            min-height: 56px;
            border-radius: 18px;
            border: 1px solid var(--card-border);
            padding: 12px 16px;
            background: var(--surface);
            color: var(--text-primary);
            cursor: pointer;
            text-align: left;
            transition: transform 0.2s ease, border 0.2s ease, box-shadow 0.2s ease;
        }

        .mode-chip[data-selected="true"] {
            border-color: var(--chip-accent);
            box-shadow: 0 10px 30px rgba(109, 139, 255, 0.25);
            background: linear-gradient(135deg, var(--chip-accent), rgba(255,255,255,0.1));
            color: #fff;
        }

        .mode-chip span {
            display: block;
            font-size: 1rem;
            font-weight: 600;
        }

        .mode-chip small {
            font-size: 0.78rem;
            opacity: 0.85;
        }

        /* Story 3-2: Advanced Controls Drawer */
        .advanced-controls {
            background: var(--surface-1);
            border: 2px solid var(--border-subtle);
            border-radius: 12px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .advanced-controls summary {
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            list-style: none;
            user-select: none;
        }

        .advanced-controls summary::-webkit-details-marker {
            display: none;
        }

        .advanced-controls summary::after {
            content: '‚ñº';
            transition: transform 0.2s ease;
            font-size: 0.85rem;
            opacity: 0.6;
        }

        .advanced-controls[open] summary::after {
            transform: rotate(180deg);
        }

        .advanced-controls summary:hover {
            background: var(--surface-2);
            border-radius: 8px;
        }

        .advanced-controls kbd {
            font-size: 0.75rem;
            background: var(--surface-2);
            padding: 0.125rem 0.375rem;
            border-radius: 4px;
            border: 1px solid var(--border-subtle);
            font-family: monospace;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
            margin-top: 1rem;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .checkbox-group {
            flex-direction: row;
            align-items: center;
            gap: 0.5rem;
        }

        .checkbox-group input[type="checkbox"] {
            width: 24px;
            height: 24px;
            cursor: pointer;
        }

        .control-label {
            font-weight: 500;
            color: var(--text-1);
            font-size: 0.95rem;
        }

        .control-input {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .control-input input[type="range"] {
            flex: 1;
            height: 8px;
            border-radius: 4px;
            appearance: none;
            background: var(--surface-3);
            outline: none;
        }

        .control-input input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-focus);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.1s ease;
        }

        .control-input input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .control-input input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-focus);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.1s ease;
        }

        .control-input input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.1);
        }

        .control-input input[type="range"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .control-input input[type="range"]:disabled::-webkit-slider-thumb {
            cursor: not-allowed;
        }

        .control-input input[type="range"]:disabled::-moz-range-thumb {
            cursor: not-allowed;
        }

        .control-input select {
            flex: 1;
            padding: 0.5rem;
            border-radius: 6px;
            background: var(--surface-2);
            border: 2px solid var(--border-subtle);
            color: var(--text-1);
            font-size: 0.9rem;
            cursor: pointer;
        }

        .control-input select:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .control-input output {
            font-variant-numeric: tabular-nums;
            min-width: 3.5rem;
            text-align: right;
            font-weight: 600;
            color: var(--text-2);
            font-size: 0.9rem;
        }

        .freq-band {
            font-size: 0.8rem;
            color: var(--text-3);
            font-weight: 400;
            margin-left: 0.25rem;
        }

        .control-hint {
            font-size: 0.85rem;
            color: var(--text-3);
            font-style: italic;
            line-height: 1.3;
        }

        .sensor-lock-notice {
            background: var(--warning-bg, #fff3cd);
            border: 2px solid var(--warning-border, #ffc107);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .lock-icon {
            font-size: 1.5rem;
        }

        .lock-message {
            flex: 1;
            font-weight: 500;
            color: var(--warning-text, #664d03);
        }

        .unlock-btn {
            padding: 0.5rem 1rem;
            border-radius: 6px;
            background: var(--surface-1);
            border: 2px solid var(--border);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-1);
        }

        .unlock-btn:hover {
            background: var(--accent-focus);
            color: white;
            border-color: var(--accent-focus);
            transform: translateY(-1px);
        }

        .unlock-btn:active {
            transform: translateY(0);
        }

        .hero-card {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .hero-card h2 {
            margin: 0;
            font-size: 1.6rem;
        }

        .hero-message {
            min-height: 48px;
            border-radius: 16px;
            padding: 12px 16px;
            background: var(--surface);
            color: var(--text-primary);
            display: flex;
            align-items: center;
        }

        .hero-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        .hero-actions button {
            flex: 1;
            min-width: 140px;
            min-height: 54px;
        }

        .hero-countdown {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .hero-animation {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            border: 3px solid rgba(109, 139, 255, 0.3);
            position: relative;
        }

        .hero-animation::after {
            content: '';
            position: absolute;
            inset: 8px;
            border-radius: 50%;
            border: 3px solid rgba(109, 139, 255, 0.8);
            animation: breathe424 6s ease-in-out infinite;
        }

        /* 4-2-4 breathing animation: 2s inhale, 1s hold, 2s exhale, 1s hold = 6s cycle */
        @keyframes breathe424 {
            0% {
                transform: scale(0.85);
                opacity: 0.6;
            }
            /* Inhale: 0-33.33% (2s of 6s) */
            33.33% {
                transform: scale(1.15);
                opacity: 1;
            }
            /* Hold inhale: 33.33-50% (1s of 6s) */
            50% {
                transform: scale(1.15);
                opacity: 1;
            }
            /* Exhale: 50-83.33% (2s of 6s) */
            83.33% {
                transform: scale(0.85);
                opacity: 0.6;
            }
            /* Hold exhale: 83.33-100% (1s of 6s) */
            100% {
                transform: scale(0.85);
                opacity: 0.6;
            }
        }

        .hero-countdown__value {
            font-size: 2rem;
            font-weight: 600;
        }

        .preset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
        }

        .preset-card {
            border-radius: 16px;
            border: 1px solid var(--card-border);
            padding: 14px;
            background: var(--surface);
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .hero-support {
            color: var(--text-secondary);
            margin: 0;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 16px;
        }

        .value-display {
            text-align: right;
            font-weight: 600;
            color: var(--accent-focus);
            margin-top: 8px;
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .now-playing-card canvas {
            width: 100%;
            height: 120px;
            border-radius: 16px;
            border: 1px solid var(--card-border);
            background: #050915;
        }

        .status-pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 999px;
            font-size: 0.8rem;
            border: 1px solid var(--card-border);
        }

        .transport-controls {
            display: flex;
            gap: 12px;
            justify-content: space-between;
            align-items: center;
        }

        .transport-button {
            min-width: 64px;
            min-height: 64px;
            border-radius: 20px;
            border: none;
            background: var(--surface);
            color: var(--text-primary);
            font-size: 1.4rem;
            cursor: pointer;
        }

        .transport-button.play {
            flex: 1;
            background: linear-gradient(135deg, var(--accent-focus), #9f9bff);
            color: #fff;
            font-size: 1.6rem;
            box-shadow: 0 20px 40px rgba(109, 139, 255, 0.35);
        }

        .timeline {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .timeline input[type="range"] {
            width: 100%;
            accent-color: var(--accent-focus);
        }

        .timeline-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .intake-tabs {
            display: inline-flex;
            border-radius: 999px;
            border: 1px solid var(--card-border);
            overflow: hidden;
        }

        .intake-tab {
            border: none;
            background: transparent;
            padding: 12px 20px;
            min-height: 48px;
            cursor: pointer;
            color: var(--text-primary);
        }

        .intake-tab[aria-selected="true"] {
            background: linear-gradient(135deg, rgba(109, 139, 255, 0.18), rgba(109, 139, 255, 0));
            color: var(--text-primary);
        }

        .drop-zone {
            margin-top: 16px;
            border: 2px dashed rgba(109, 139, 255, 0.45);
            border-radius: 20px;
            padding: 28px 20px;
            text-align: center;
            background: var(--surface);
            min-height: 160px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            justify-content: center;
            cursor: pointer;
            transition: border 0.2s ease, box-shadow 0.2s ease;
        }

        .drop-zone--attention {
            border-color: var(--danger);
            box-shadow: 0 0 0 3px rgba(240, 93, 123, 0.2);
        }

        .drop-zone--hover {
            border-color: var(--accent-focus);
            box-shadow: 0 0 0 3px rgba(109, 139, 255, 0.25);
        }

        .playlist-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .playlist-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .playlist-button {
            width: 100%;
            border-radius: 18px;
            border: 1px solid var(--card-border);
            padding: 14px 18px;
            background: var(--surface);
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            gap: 12px;
            text-align: left;
            cursor: pointer;
            min-height: 64px;
        }

        .playlist-button[aria-current="true"] {
            border-color: var(--accent-focus);
            box-shadow: 0 0 0 2px rgba(109, 139, 255, 0.25);
        }

        .playlist-meta {
            display: flex;
            gap: 8px;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .badge {
            border-radius: 999px;
            padding: 3px 10px;
            font-size: 0.75rem;
            border: 1px solid var(--card-border);
        }

        .remove-btn {
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 1.2rem;
            min-width: 48px;
            min-height: 48px;
            border-radius: 12px;
            display: grid;
            place-items: center;
        }

        .advanced-controls .control-group {
            background: var(--surface);
            border-radius: 16px;
            padding: 18px;
        }

        .advanced-controls label {
            font-weight: 600;
            font-size: 0.95rem;
        }

        .advanced-controls input[type="range"],
        .advanced-controls select {
            width: 100%;
            margin-top: 8px;
        }

        .pill {
            border-radius: 12px;
            padding: 4px 10px;
            font-size: 0.8rem;
        }

        .insights-grid {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .insight-card,
        .sensor-card {
            border-radius: 20px;
            border: 1px solid var(--card-border);
            background: var(--card-bg);
            padding: 20px;
        }

        .insight-value {
            font-size: 2rem;
            font-weight: 600;
        }

        .sensor-card strong {
            display: block;
            margin-bottom: 8px;
        }

        .alert-inline {
            border-radius: 16px;
            padding: 12px 16px;
            background: rgba(240, 93, 123, 0.12);
            color: var(--danger);
            border: 1px solid rgba(240, 93, 123, 0.35);
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        button:focus-visible,
        .mode-chip:focus-visible,
        .intake-tab:focus-visible,
        .playlist-button:focus-visible {
            outline: 3px solid rgba(109, 139, 255, 0.7);
            outline-offset: 2px;
        }

        /* Design spec ¬ß3: Responsive grid breakpoints */
        /* Three-column layout ‚â•1280px (default above) */
        /* Two-column layout 768-1279px */
        @media (min-width: 768px) and (max-width: 1279px) {
            .main-grid {
                grid-template-columns: repeat(2, minmax(280px, 1fr));
            }
            .insights-column {
                grid-column: 1 / -1;
            }
        }

        /* Single-column layout ‚â§767px (mobile) */
        @media (max-width: 767px) {
            .app-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .main-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .hero-actions button {
                flex: 1 1 100%;
            }

            .mode-tabs {
                position: sticky;
                top: 0;
                padding: 12px 0;
                background: linear-gradient(180deg, var(--bg-1), rgba(255, 255, 255, 0));
                z-index: 5;
            }

            /* Story 3-2: Mobile responsive */
            .controls-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .advanced-controls summary {
                font-size: 1rem;
            }

            .control-input {
                flex-direction: column;
                align-items: stretch;
            }

            .control-input output {
                text-align: left;
            }

            .sensor-lock-notice {
                flex-direction: column;
                text-align: center;
            }

            .unlock-btn {
                width: 100%;
            }
        }

        @keyframes breathe {
            0% { transform: scale(0.8); opacity: 0.6; }
            50% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0.6; }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .toast {
            pointer-events: none;
        }

        /* Story 3-3: Dialog Overlay Styles */
        .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.2s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .dialog-content {
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        const MODE_LIBRARY = [
            {
                id: 'focus',
                label: 'Focus',
                short: 'Deep work',
                description: 'Steady orbit + beta beats keep intrusive thoughts at bay.',
                heroCopy: 'Steady pulses to clear the mental slate in two breaths.',
                accent: 'var(--accent-focus)',
                preset: {
                    speed: 0.55,
                    intensity: 0.85,
                    spatialDepth: 0.45,
                    movement: 'circle',
                    binaural: { enabled: true, freq: 14 },
                    noise: { type: 'pink', volume: 0.08 }
                },
                highlights: ['Beta 14‚ÄØHz pulses', 'Low drift orbit', 'Pink noise cushion']
            },
            {
                id: 'calm',
                label: 'Calm',
                short: 'Breathing companion',
                description: 'Longer arcs, theta beats, and softer noise for co-regulation.',
                heroCopy: 'Elongated orbit with theta support for family wind-downs.',
                accent: 'var(--accent-calm)',
                preset: {
                    speed: 0.35,
                    intensity: 0.6,
                    spatialDepth: 0.6,
                    movement: 'figure8',
                    binaural: { enabled: true, freq: 8 },
                    noise: { type: 'white', volume: 0.05 }
                },
                highlights: ['Theta 8‚ÄØHz support', 'Figure-eight drift', 'Gentle white noise']
            },
            {
                id: 'energize',
                label: 'Energize',
                short: 'Quick reset',
                description: 'Fast arcs + brighter stereo swing for playful bursts.',
                heroCopy: 'Hyper-clear panning for a quick dopamine reset.',
                accent: 'var(--accent-energize)',
                preset: {
                    speed: 0.95,
                    intensity: 0.9,
                    spatialDepth: 0.7,
                    movement: 'random',
                    binaural: { enabled: true, freq: 30 },
                    noise: { type: 'pink', volume: 0.12 }
                },
                highlights: ['Gamma 30‚ÄØHz spark', 'Randomized orbit', 'Louder pink noise']
            }
        ];

        const HERO_BREATH_DURATION = 20;

        // Story 3-3: Custom Preset Storage Keys
        const CUSTOM_PRESETS_KEY = 'mpe_8d_custom_presets';

        // Supported MIME types for file intake validation
        const SUPPORTED_MIME_TYPES = [
            'audio/mpeg',      // .mp3
            'audio/wav',       // .wav
            'audio/wave',      // .wav (alternate)
            'audio/ogg',       // .ogg
            'audio/x-wav'      // .wav (legacy)
        ];

        // Story 3-2: Parameter range constants
        const PARAM_RANGES = {
            speed: { min: 0, max: 1, step: 0.05 },
            intensity: { min: 0, max: 1, step: 0.05 },
            spatialDepth: { min: 0, max: 1, step: 0.05 },
            binauralFreq: { min: 0, max: 40, step: 1 },
            noiseVolume: { min: 0, max: 0.3, step: 0.01 }
        };

        // Helper: Get binaural frequency band name
        const getBinauralBand = (freq) => {
            if (freq < 4) return 'Delta';
            if (freq < 8) return 'Theta';
            if (freq < 14) return 'Alpha';
            if (freq < 30) return 'Beta';
            return 'Gamma';
        };

        // Helper: Get binaural frequency hint
        const getBinauralHint = (freq) => {
            if (freq < 4) return 'Deep sleep, healing';
            if (freq < 8) return 'Deep relaxation, meditation';
            if (freq < 14) return 'Calm focus, learning';
            if (freq < 30) return 'Active focus, problem-solving';
            return 'Peak alertness, high energy';
        };

        // ============================================================
        // Story 3-3: Custom Preset CRUD Storage Helpers
        // ============================================================
        
        const loadCustomPresets = () => {
            try {
                const saved = localStorage.getItem(CUSTOM_PRESETS_KEY);
                return saved ? JSON.parse(saved) : {};
            } catch (err) {
                console.error('[PresetStorage] Failed to load custom presets:', err);
                return {};
            }
        };

        const saveCustomPreset = (presetData, showToastFn) => {
            try {
                const customPresets = loadCustomPresets();
                const id = `custom-preset-${Date.now()}`;
                
                customPresets[id] = {
                    id,
                    name: presetData.name,
                    description: presetData.description || '',
                    createdAt: Date.now(),
                    lastUsedAt: Date.now(),
                    preset: {
                        speed: presetData.speed,
                        intensity: presetData.intensity,
                        spatialDepth: presetData.spatialDepth,
                        movement: presetData.movement,
                        binaural: { 
                            enabled: presetData.binauralEnabled, 
                            freq: presetData.binauralFreq 
                        },
                        noise: { 
                            type: presetData.noiseType, 
                            volume: presetData.noiseVolume 
                        }
                    },
                    color: presetData.color || '#6366f1',
                    tags: presetData.tags || []
                };
                
                localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(customPresets));
                
                // Add to preset order
                const order = getPresetOrder();
                order.push(id);
                savePresetOrder(order);
                
                console.log(`[PresetStorage] Saved custom preset: ${id} - ${presetData.name}`);
                return id;
            } catch (err) {
                if (err.name === 'QuotaExceededError') {
                    if (showToastFn) showToastFn('Storage full. Please delete old presets.', 'error');
                } else {
                    console.error('[PresetStorage] Failed to save preset:', err);
                    if (showToastFn) showToastFn('Error saving preset.', 'error');
                }
                return null;
            }
        };

        const updateCustomPreset = (id, updates, showToastFn) => {
            try {
                const customPresets = loadCustomPresets();
                if (customPresets[id]) {
                    customPresets[id] = { 
                        ...customPresets[id], 
                        ...updates,
                        lastUsedAt: Date.now()
                    };
                    localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(customPresets));
                    console.log(`[PresetStorage] Updated custom preset: ${id}`);
                    return true;
                }
                console.warn(`[PresetStorage] Preset not found: ${id}`);
                return false;
            } catch (err) {
                console.error('[PresetStorage] Failed to update preset:', err);
                if (showToastFn) showToastFn('Error updating preset.', 'error');
                return false;
            }
        };

        const deleteCustomPreset = (id, showToastFn) => {
            try {
                const customPresets = loadCustomPresets();
                const presetName = customPresets[id]?.name || id;
                
                delete customPresets[id];
                localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(customPresets));
                
                // Remove from order
                const order = getPresetOrder().filter(pid => pid !== id);
                savePresetOrder(order);
                
                console.log(`[PresetStorage] Deleted custom preset: ${id}`);
                
                // Return the deleted preset ID and name for caller to handle track updates
                return { id, name: presetName };
            } catch (err) {
                console.error('[PresetStorage] Failed to delete preset:', err);
                if (showToastFn) showToastFn('Error deleting preset.', 'error');
                return null;
            }
        };

        const getAllPresets = () => {
            const defaults = MODE_LIBRARY.map(mode => ({
                id: mode.id,
                name: mode.label,
                description: mode.description,
                preset: mode.preset,
                color: mode.accent,
                isDefault: true,
                createdAt: 0,
                lastUsedAt: 0
            }));
            
            const custom = Object.values(loadCustomPresets()).map(p => ({
                ...p,
                isDefault: false
            }));
            
            // Apply user-defined order
            const order = getPresetOrder();
            const allPresets = [...defaults, ...custom];
            const ordered = order
                .map(id => allPresets.find(p => p.id === id))
                .filter(Boolean);
            
            // Add any new presets not in order (defensive)
            const orderedIds = new Set(ordered.map(p => p.id));
            const missing = allPresets.filter(p => !orderedIds.has(p.id));
            
            return [...ordered, ...missing];
        };

        const getPresetOrder = () => {
            try {
                const saved = localStorage.getItem('mpe_8d_preset_order');
                if (saved) return JSON.parse(saved);
            } catch (err) {
                console.error('[PresetStorage] Failed to load preset order:', err);
            }
            
            // Default order: defaults first, then custom by creation date
            const defaults = MODE_LIBRARY.map(m => m.id);
            const custom = Object.keys(loadCustomPresets()).sort();
            return [...defaults, ...custom];
        };

        const savePresetOrder = (order) => {
            try {
                localStorage.setItem('mpe_8d_preset_order', JSON.stringify(order));
            } catch (err) {
                console.error('[PresetStorage] Failed to save preset order:', err);
            }
        };

        // Helper to format "last used" timestamp
        const formatLastUsed = (timestamp) => {
            if (!timestamp || timestamp === 0) return 'Never used';
            
            const now = Date.now();
            const diff = now - timestamp;
            const seconds = Math.floor(diff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            
            if (seconds < 60) return 'Just now';
            if (minutes < 60) return `${minutes} minute${minutes === 1 ? '' : 's'} ago`;
            if (hours < 24) return `${hours} hour${hours === 1 ? '' : 's'} ago`;
            if (days < 7) return `${days} day${days === 1 ? '' : 's'} ago`;
            
            const date = new Date(timestamp);
            return date.toLocaleDateString();
        };

        // Advanced Controls Component (Story 3-2)
        const AdvancedControls = ({ 
            // Parameter states (from existing Epic 1 hooks)
            speed, setSpeed,
            intensity, setIntensity,
            spatialDepth, setSpatialDepth,
            movementPattern, setMovementPattern,
            binauralEnabled, setBinauralEnabled,
            binauralFreq, setBinauralFreq,
            noiseType, setNoiseType,
            noiseVolume, setNoiseVolume,
            // UI state
            isExpanded, setIsExpanded,
            sensorLocked, setSensorLocked,
            setA11yAnnouncement,
            // Story 3-3: Save preset handler
            onSavePreset
        }) => {
            return (
                <details 
                    open={isExpanded} 
                    onToggle={(e) => setIsExpanded(e.target.open)}
                    className="advanced-controls"
                >
                    <summary>
                        ‚öôÔ∏è Advanced Controls
                        <kbd>Ctrl+E</kbd>
                    </summary>
                    
                    <div className="controls-grid">
                        {/* Rotation Speed Slider */}
                        <label className="control-group">
                            <span className="control-label">Rotation Speed</span>
                            <div className="control-input">
                                <input 
                                    type="range" 
                                    min={PARAM_RANGES.speed.min} 
                                    max={PARAM_RANGES.speed.max} 
                                    step={PARAM_RANGES.speed.step} 
                                    value={speed} 
                                    onChange={(e) => setSpeed(parseFloat(e.target.value))} 
                                    disabled={sensorLocked}
                                    aria-label="Rotation speed"
                                />
                                <output>{speed.toFixed(2)}</output>
                            </div>
                            <span className="control-hint">How fast sound orbits your head</span>
                        </label>
                        
                        {/* Intensity Slider */}
                        <label className="control-group">
                            <span className="control-label">Intensity</span>
                            <div className="control-input">
                                <input 
                                    type="range" 
                                    min={PARAM_RANGES.intensity.min} 
                                    max={PARAM_RANGES.intensity.max} 
                                    step={PARAM_RANGES.intensity.step} 
                                    value={intensity} 
                                    onChange={(e) => setIntensity(parseFloat(e.target.value))} 
                                    disabled={sensorLocked}
                                    aria-label="Intensity"
                                />
                                <output>{intensity.toFixed(2)}</output>
                            </div>
                            <span className="control-hint">Strength of 8D effect</span>
                        </label>
                        
                        {/* Spatial Depth Slider */}
                        <label className="control-group">
                            <span className="control-label">Spatial Depth</span>
                            <div className="control-input">
                                <input 
                                    type="range" 
                                    min={PARAM_RANGES.spatialDepth.min} 
                                    max={PARAM_RANGES.spatialDepth.max} 
                                    step={PARAM_RANGES.spatialDepth.step} 
                                    value={spatialDepth} 
                                    onChange={(e) => setSpatialDepth(parseFloat(e.target.value))} 
                                    disabled={sensorLocked}
                                    aria-label="Spatial depth"
                                />
                                <output>{spatialDepth.toFixed(2)}</output>
                            </div>
                            <span className="control-hint">Front/back positioning</span>
                        </label>
                        
                        {/* Movement Pattern Dropdown */}
                        <label className="control-group">
                            <span className="control-label">Movement Pattern</span>
                            <div className="control-input">
                                <select 
                                    value={movementPattern} 
                                    onChange={(e) => setMovementPattern(e.target.value)}
                                    disabled={sensorLocked}
                                    aria-label="Movement pattern"
                                >
                                    <option value="circle">Circle - Steady orbit</option>
                                    <option value="figure8">Figure-8 - Gentle sway</option>
                                    <option value="leftright">Left-Right - Side-to-side</option>
                                    <option value="frontback">Front-Back - Forward-backward</option>
                                    <option value="random">Random - Unpredictable</option>
                                </select>
                            </div>
                            <span className="control-hint">Path sound travels around you</span>
                        </label>
                        
                        {/* Binaural Beats Checkbox */}
                        <label className="control-group checkbox-group">
                            <input 
                                type="checkbox" 
                                checked={binauralEnabled} 
                                onChange={(e) => setBinauralEnabled(e.target.checked)}
                                disabled={sensorLocked}
                                aria-label="Enable binaural beats"
                            />
                            <span className="control-label">Binaural Beats</span>
                        </label>
                        
                        {/* Binaural Frequency Slider (conditional) */}
                        {binauralEnabled && (
                            <label className="control-group">
                                <span className="control-label">Binaural Frequency</span>
                                <div className="control-input">
                                    <input 
                                        type="range" 
                                        min={PARAM_RANGES.binauralFreq.min} 
                                        max={PARAM_RANGES.binauralFreq.max} 
                                        step={PARAM_RANGES.binauralFreq.step} 
                                        value={binauralFreq} 
                                        onChange={(e) => setBinauralFreq(parseInt(e.target.value))} 
                                        disabled={sensorLocked}
                                        aria-label="Binaural frequency"
                                    />
                                    <output>
                                        {binauralFreq} Hz 
                                        <span className="freq-band">({getBinauralBand(binauralFreq)})</span>
                                    </output>
                                </div>
                                <span className="control-hint">{getBinauralHint(binauralFreq)}</span>
                            </label>
                        )}
                        
                        {/* Noise Type Dropdown */}
                        <label className="control-group">
                            <span className="control-label">Noise Type</span>
                            <div className="control-input">
                                <select 
                                    value={noiseType} 
                                    onChange={(e) => setNoiseType(e.target.value)}
                                    disabled={sensorLocked}
                                    aria-label="Noise type"
                                >
                                    <option value="pink">Pink - Balanced warmth</option>
                                    <option value="white">White - Crisp static</option>
                                    <option value="brown">Brown - Deep rumble</option>
                                </select>
                            </div>
                            <span className="control-hint">Background noise texture</span>
                        </label>
                        
                        {/* Noise Volume Slider */}
                        <label className="control-group">
                            <span className="control-label">Noise Volume</span>
                            <div className="control-input">
                                <input 
                                    type="range" 
                                    min={PARAM_RANGES.noiseVolume.min} 
                                    max={PARAM_RANGES.noiseVolume.max} 
                                    step={PARAM_RANGES.noiseVolume.step} 
                                    value={noiseVolume} 
                                    onChange={(e) => setNoiseVolume(parseFloat(e.target.value))} 
                                    disabled={sensorLocked}
                                    aria-label="Noise volume"
                                />
                                <output>{noiseVolume.toFixed(2)}</output>
                            </div>
                            <span className="control-hint">Loudness of background noise</span>
                        </label>
                    </div>
                    
                    {/* Story 3-3: Save Preset Button */}
                    {!sensorLocked && onSavePreset && (
                        <button 
                            type="button"
                            onClick={onSavePreset}
                            className="primary-btn"
                            style={{ marginTop: '16px', width: '100%' }}
                            aria-label="Save current parameters as custom preset"
                        >
                            üíæ Save as Custom Preset
                        </button>
                    )}
                    
                    {/* Sensor Lock Notice */}
                    {sensorLocked && (
                        <div className="sensor-lock-notice" role="status" aria-live="polite">
                            <span className="lock-icon">üîí</span>
                            <span className="lock-message">Parameters locked by adaptive mode</span>
                            <button 
                                onClick={() => {
                                    setSensorLocked(false);
                                    setA11yAnnouncement('Adaptive mode disabled. Controls unlocked.');
                                }}
                                className="unlock-btn"
                            >
                                Unlock Manual Control
                            </button>
                        </div>
                    )}
                </details>
            );
        };

        // ============================================================
        // Story 3-3: Save Preset Dialog Component
        // ============================================================
        
        const SavePresetDialog = ({ 
            currentParameters, 
            onSave, 
            onCancel,
            showToast,
            setA11yAnnouncement,
            existingPreset = null // for edit mode
        }) => {
            const [name, setName] = useState(existingPreset?.name || '');
            const [description, setDescription] = useState(existingPreset?.description || '');
            const [color, setColor] = useState(existingPreset?.color || '#6366f1');
            const [errors, setErrors] = useState({});
            
            const validate = () => {
                const newErrors = {};
                
                if (!name.trim()) {
                    newErrors.name = 'Preset name is required';
                } else if (name.length > 50) {
                    newErrors.name = 'Name too long (max 50 characters)';
                }
                
                if (description.length > 200) {
                    newErrors.description = 'Description too long (max 200 characters)';
                }
                
                // Validate color hex format
                const hexPattern = /^#[0-9A-Fa-f]{6}$/;
                if (!hexPattern.test(color)) {
                    newErrors.color = 'Invalid color format (use #RRGGBB)';
                }
                
                setErrors(newErrors);
                return Object.keys(newErrors).length === 0;
            };
            
            const handleSave = () => {
                if (!validate()) return;
                
                const presetData = {
                    name: name.trim(),
                    description: description.trim(),
                    color,
                    ...currentParameters
                };
                
                let presetId;
                if (existingPreset) {
                    // Edit mode
                    const success = updateCustomPreset(existingPreset.id, presetData, showToast);
                    if (success) {
                        presetId = existingPreset.id;
                        showToast(`Preset "${name}" updated`, 'success');
                        setA11yAnnouncement(`Preset ${name} updated`);
                    }
                } else {
                    // Create mode
                    presetId = saveCustomPreset(presetData, showToast);
                    if (presetId) {
                        showToast(`Preset "${name}" saved`, 'success');
                        setA11yAnnouncement(`Preset ${name} saved`);
                    }
                }
                
                if (presetId) {
                    onSave(presetId);
                }
            };
            
            // Handle Escape key to close dialog
            useEffect(() => {
                const handleEscape = (e) => {
                    if (e.key === 'Escape') onCancel();
                };
                document.addEventListener('keydown', handleEscape);
                return () => document.removeEventListener('keydown', handleEscape);
            }, [onCancel]);
            
            return (
                <div 
                    className="dialog-overlay" 
                    onClick={onCancel}
                    role="dialog"
                    aria-modal="true"
                    aria-labelledby="dialog-title"
                >
                    <div 
                        className="dialog-content" 
                        onClick={(e) => e.stopPropagation()}
                        style={{
                            backgroundColor: 'var(--bg-primary)',
                            padding: '24px',
                            borderRadius: '12px',
                            maxWidth: '500px',
                            width: '90%',
                            maxHeight: '80vh',
                            overflow: 'auto'
                        }}
                    >
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
                            {/* React JSX automatically escapes user input, preventing XSS attacks */}
                            <h2 id="dialog-title" style={{ margin: 0 }}>
                                {existingPreset ? 'Edit Preset' : 'Save Custom Preset'}
                            </h2>
                            <button 
                                onClick={onCancel} 
                                aria-label="Close dialog" 
                                style={{
                                    background: 'none',
                                    border: 'none',
                                    fontSize: '24px',
                                    cursor: 'pointer',
                                    color: 'var(--text-secondary)'
                                }}
                            >
                                √ó
                            </button>
                        </div>
                        
                        <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
                            {/* Preset Name */}
                            <label style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                <span style={{ fontWeight: '500', color: errors.name ? '#f87171' : 'inherit' }}>
                                    Preset Name *
                                </span>
                                <input 
                                    type="text" 
                                    value={name} 
                                    onChange={(e) => setName(e.target.value)} 
                                    placeholder="e.g., Deep Flow"
                                    maxLength={50}
                                    required
                                    autoFocus
                                    aria-invalid={!!errors.name}
                                    aria-describedby={errors.name ? 'name-error' : undefined}
                                    style={{
                                        padding: '8px 12px',
                                        borderRadius: '6px',
                                        border: `1px solid ${errors.name ? '#f87171' : 'var(--border)'}`,
                                        backgroundColor: 'var(--bg-secondary)',
                                        color: 'var(--text-primary)'
                                    }}
                                />
                                {errors.name && (
                                    <span id="name-error" style={{ color: '#f87171', fontSize: '0.875rem' }}>
                                        {errors.name}
                                    </span>
                                )}
                                <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', textAlign: 'right' }}>
                                    {name.length}/50
                                </span>
                            </label>
                            
                            {/* Description */}
                            <label style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                <span style={{ fontWeight: '500', color: errors.description ? '#f87171' : 'inherit' }}>
                                    Description (optional)
                                </span>
                                <textarea 
                                    value={description} 
                                    onChange={(e) => setDescription(e.target.value)} 
                                    placeholder="My perfect focus state"
                                    maxLength={200}
                                    rows={3}
                                    aria-invalid={!!errors.description}
                                    aria-describedby={errors.description ? 'desc-error' : undefined}
                                    style={{
                                        padding: '8px 12px',
                                        borderRadius: '6px',
                                        border: `1px solid ${errors.description ? '#f87171' : 'var(--border)'}`,
                                        backgroundColor: 'var(--bg-secondary)',
                                        color: 'var(--text-primary)',
                                        fontFamily: 'inherit',
                                        resize: 'vertical'
                                    }}
                                />
                                {errors.description && (
                                    <span id="desc-error" style={{ color: '#f87171', fontSize: '0.875rem' }}>
                                        {errors.description}
                                    </span>
                                )}
                                <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', textAlign: 'right' }}>
                                    {description.length}/200
                                </span>
                            </label>
                            
                            {/* Color Picker */}
                            <label style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                <span style={{ fontWeight: '500', color: errors.color ? '#f87171' : 'inherit' }}>
                                    Accent Color
                                </span>
                                <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
                                    <input 
                                        type="color" 
                                        value={color} 
                                        onChange={(e) => setColor(e.target.value)}
                                        style={{ width: '48px', height: '48px', cursor: 'pointer' }}
                                    />
                                    <input 
                                        type="text" 
                                        value={color} 
                                        onChange={(e) => setColor(e.target.value)} 
                                        placeholder="#6366f1"
                                        pattern="^#[0-9A-Fa-f]{6}$"
                                        aria-invalid={!!errors.color}
                                        aria-describedby={errors.color ? 'color-error' : undefined}
                                        style={{
                                            padding: '8px 12px',
                                            borderRadius: '6px',
                                            border: `1px solid ${errors.color ? '#f87171' : 'var(--border)'}`,
                                            backgroundColor: 'var(--bg-secondary)',
                                            color: 'var(--text-primary)',
                                            flex: 1
                                        }}
                                    />
                                </div>
                                {errors.color && (
                                    <span id="color-error" style={{ color: '#f87171', fontSize: '0.875rem' }}>
                                        {errors.color}
                                    </span>
                                )}
                            </label>
                            
                            {/* Parameter Preview */}
                            <div style={{ 
                                padding: '12px', 
                                borderRadius: '8px', 
                                backgroundColor: 'var(--bg-secondary)',
                                border: '1px solid var(--border)'
                            }}>
                                <h3 style={{ margin: '0 0 12px 0', fontSize: '0.875rem', fontWeight: '600' }}>
                                    Current Parameters
                                </h3>
                                <div style={{ 
                                    display: 'grid', 
                                    gridTemplateColumns: 'auto 1fr', 
                                    gap: '4px 12px',
                                    fontSize: '0.875rem'
                                }}>
                                    <dt style={{ fontWeight: '500', color: 'var(--text-secondary)' }}>Speed:</dt>
                                    <dd style={{ margin: 0 }}>{currentParameters.speed.toFixed(2)}</dd>
                                    
                                    <dt style={{ fontWeight: '500', color: 'var(--text-secondary)' }}>Intensity:</dt>
                                    <dd style={{ margin: 0 }}>{currentParameters.intensity.toFixed(2)}</dd>
                                    
                                    <dt style={{ fontWeight: '500', color: 'var(--text-secondary)' }}>Spatial Depth:</dt>
                                    <dd style={{ margin: 0 }}>{currentParameters.spatialDepth.toFixed(2)}</dd>
                                    
                                    <dt style={{ fontWeight: '500', color: 'var(--text-secondary)' }}>Movement:</dt>
                                    <dd style={{ margin: 0 }}>{currentParameters.movement}</dd>
                                    
                                    <dt style={{ fontWeight: '500', color: 'var(--text-secondary)' }}>Binaural:</dt>
                                    <dd style={{ margin: 0 }}>
                                        {currentParameters.binauralEnabled 
                                            ? `${currentParameters.binauralFreq} Hz (${getBinauralBand(currentParameters.binauralFreq)})` 
                                            : 'Off'}
                                    </dd>
                                    
                                    <dt style={{ fontWeight: '500', color: 'var(--text-secondary)' }}>Noise:</dt>
                                    <dd style={{ margin: 0 }}>
                                        {currentParameters.noiseType} @ {(currentParameters.noiseVolume * 100).toFixed(0)}%
                                    </dd>
                                </div>
                            </div>
                        </div>
                        
                        {/* Dialog Actions */}
                        <div style={{ display: 'flex', gap: '8px', marginTop: '20px', justifyContent: 'flex-end' }}>
                            <button 
                                onClick={onCancel} 
                                className="ghost-btn"
                            >
                                Cancel
                            </button>
                            <button 
                                onClick={handleSave} 
                                disabled={!name.trim()} 
                                className="primary-btn"
                            >
                                {existingPreset ? 'Update' : 'Save'} Preset
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

function App() {
            const defaultMode = MODE_LIBRARY[0];
            const [playlist, setPlaylist] = useState([]);
            const [currentTrackIndex, setCurrentTrackIndex] = useState(null);
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentTime, setCurrentTime] = useState(0);
            const [duration, setDuration] = useState(0);
            const [volume, setVolume] = useState(0.7);
            const [showFileWarning, setShowFileWarning] = useState(false);
            
            // 8D Effect Controls
            const [speed, setSpeed] = useState(defaultMode.preset.speed);
            const [intensity, setIntensity] = useState(defaultMode.preset.intensity);
            const [spatialDepth, setSpatialDepth] = useState(defaultMode.preset.spatialDepth);
            const [movementPattern, setMovementPattern] = useState(defaultMode.preset.movement);
            
            // Additional Effects
            const [binauralEnabled, setBinauralEnabled] = useState(defaultMode.preset.binaural.enabled);
            const [binauralFreq, setBinauralFreq] = useState(defaultMode.preset.binaural.freq);
            const [noiseType, setNoiseType] = useState(defaultMode.preset.noise.type);
            const [noiseVolume, setNoiseVolume] = useState(defaultMode.preset.noise.volume);
            const [visualWaveGain, setVisualWaveGain] = useState(defaultMode.preset.noise.volume);
            
            // UI + Ritual
            const [darkMode, setDarkMode] = useState(false);
            const [highContrast, setHighContrast] = useState(false);
            const [urlInput, setUrlInput] = useState('');
            const [showVisualizer, setShowVisualizer] = useState(true);
            const [modeIndex, setModeIndex] = useState(0);
            const [focusedModeIndex, setFocusedModeIndex] = useState(0);
            const [activePresetId, setActivePresetId] = useState('focus'); // Story 3-1: Track active preset by ID
            const [ritualStatus, setRitualStatus] = useState('idle');
            const [ritualCountdown, setRitualCountdown] = useState(HERO_BREATH_DURATION);
            const [breathingPhase, setBreathingPhase] = useState(''); // 'inhale', 'hold-in', 'exhale', 'hold-out'
            const [skipRitualPref, setSkipRitualPref] = useState(() => {
                try {
                    return localStorage.getItem('skipBreathingRitual') === 'true';
                } catch {
                    return false;
                }
            });
            const [heroMessage, setHeroMessage] = useState('Select a ritual to begin');
            const [a11yAnnouncement, setA11yAnnouncement] = useState('');
            const [needsAudio, setNeedsAudio] = useState(false);
            const [intakeTab, setIntakeTab] = useState('files');
            const [isOnline, setIsOnline] = useState(typeof navigator !== 'undefined' ? navigator.onLine : true);
            const [reducedMotion, setReducedMotion] = useState(false);
            const [dragActive, setDragActive] = useState(false);
            const [audioElementToken, setAudioElementToken] = useState(0);
            
            // Story 3-2: Advanced Controls UI state
            const [isAdvancedControlsExpanded, setIsAdvancedControlsExpanded] = useState(false);
            const [sensorLocked, setSensorLocked] = useState(false); // Epic 5 adaptive mode
            
            // Story 3-3: Custom Preset Management
            const [showSavePresetDialog, setShowSavePresetDialog] = useState(false);
            const [editingPreset, setEditingPreset] = useState(null);
            const [allPresets, setAllPresets] = useState([]);
            
            // File intake notifications
            const [toastMessage, setToastMessage] = useState('');
            const [toastType, setToastType] = useState('info');
            const [isProcessingFiles, setIsProcessingFiles] = useState(false);
            const [isValidatingUrl, setIsValidatingUrl] = useState(false);
            
            const selectedMode = MODE_LIBRARY[modeIndex];
            const nowPlayingTrack = currentTrackIndex !== null ? playlist[currentTrackIndex] : null;
            const playlistMinutes = Math.max(0, Math.floor(playlist.length * 3.5));
            const focusConfidence = Math.min(100, 60 + playlist.length * 8);
            const streakMinutes = Math.min(21, playlist.length * 2);
            
            // Refs
            const audioContextRef = useRef(null);
            const sourceNodeRef = useRef(null);
            const gainNodeRef = useRef(null);
            const audioElementRef = useRef(null);
            const audioEndedHandlerRef = useRef(null);
            const currentBlobUrlRef = useRef(null);
            const fileInputRef = useRef(null);
            const canvasRef = useRef(null);
            const analyserRef = useRef(null);
            const animationFrameRef = useRef(null);
            const rotationIntervalRef = useRef(null);
            const rotationNodesRef = useRef(null);
            const modeRefs = useRef([]);
            const dropZoneRef = useRef(null);
            const ritualTimeoutRef = useRef(null);
            const ritualIntervalRef = useRef(null);
            const breathingPhaseIntervalRef = useRef(null);
            const gainChainRef = useRef(null);
            const binauralNodesRef = useRef(null);
            const noiseNodesRef = useRef(null);
            const visualWaveGainRef = useRef(visualWaveGain);
            const playlistRef = useRef(playlist);
            const currentTrackIndexRef = useRef(currentTrackIndex);
            const playNextRef = useRef(() => {});
            const prevPlaylistLengthRef = useRef(playlist.length);
            const urlValidationControllerRef = useRef(null);
            const toastTimeoutRef = useRef(null);

            const cleanupBlobUrl = () => {
                if (currentBlobUrlRef.current) {
                    URL.revokeObjectURL(currentBlobUrlRef.current);
                    currentBlobUrlRef.current = null;
                }
            };

            const tearDownBinauralNodes = () => {
                if (binauralNodesRef.current) {
                    binauralNodesRef.current.stop();
                    binauralNodesRef.current = null;
                }
            };

            const tearDownNoiseNodes = () => {
                if (noiseNodesRef.current) {
                    noiseNodesRef.current.stop();
                    noiseNodesRef.current = null;
                }
            };

            const disposeAudioGraph = () => {
                if (rotationIntervalRef.current) {
                    clearInterval(rotationIntervalRef.current);
                    rotationIntervalRef.current = null;
                }
                rotationNodesRef.current = null;

                tearDownBinauralNodes();
                tearDownNoiseNodes();

                if (animationFrameRef.current) {
                    cancelAnimationFrame(animationFrameRef.current);
                    animationFrameRef.current = null;
                }

                if (gainChainRef.current) {
                    gainChainRef.current.disconnect();
                    gainChainRef.current = null;
                }
                gainNodeRef.current = null;
                analyserRef.current = null;

                if (sourceNodeRef.current) {
                    try {
                        sourceNodeRef.current.disconnect();
                    } catch (error) {
                        console.error('Error disconnecting source node:', error);
                    }
                    sourceNodeRef.current = null;
                }
            };

            const teardownAudioElement = () => {
                if (audioElementRef.current) {
                    const audio = audioElementRef.current;
                    if (audioEndedHandlerRef.current) {
                        audio.removeEventListener('ended', audioEndedHandlerRef.current);
                        audioEndedHandlerRef.current = null;
                    }
                    audio.pause();
                    audio.removeAttribute('src');
                    audio.load();
                    audioElementRef.current = null;
                }
                cleanupBlobUrl();
            };

            const prepareAudioElement = () => {
                teardownAudioElement();
                const audio = new Audio();
                audio.preload = 'auto';
                audio.crossOrigin = 'anonymous';
                audioElementRef.current = audio;
                audioEndedHandlerRef.current = () => {
                    cleanupBlobUrl();
                    if (typeof playNextRef.current === 'function') {
                        playNextRef.current();
                    }
                };
                audio.addEventListener('ended', audioEndedHandlerRef.current);
                setAudioElementToken(Date.now());
                return audio;
            };

            const syncBinauralChain = () => {
                tearDownBinauralNodes();
                if (!binauralEnabled || !audioContextRef.current || !gainChainRef.current) {
                    return;
                }
                binauralNodesRef.current = AudioEngine.createBinauralNodes(
                    audioContextRef.current,
                    gainChainRef.current.mainGain,
                    binauralFreq
                );
            };

            const syncNoiseLayer = () => {
                tearDownNoiseNodes();
                if (
                    noiseType === 'none' ||
                    !audioContextRef.current ||
                    !gainChainRef.current
                ) {
                    return;
                }
                noiseNodesRef.current = AudioEngine.createNoiseNode(
                    audioContextRef.current,
                    gainChainRef.current.mainGain,
                    noiseType,
                    noiseVolume
                );
            };

            const clearRitualTimers = () => {
                if (ritualIntervalRef.current) {
                    clearInterval(ritualIntervalRef.current);
                    ritualIntervalRef.current = null;
                }
                if (ritualTimeoutRef.current) {
                    clearTimeout(ritualTimeoutRef.current);
                    ritualTimeoutRef.current = null;
                }
                if (breathingPhaseIntervalRef.current) {
                    clearInterval(breathingPhaseIntervalRef.current);
                    breathingPhaseIntervalRef.current = null;
                }
            };

            useEffect(() => {
                audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();

                if (window.location.protocol === 'file:') {
                    setShowFileWarning(true);
                }

                const savedDarkMode = localStorage.getItem('darkMode');
                const prefersDark = savedDarkMode === null ? true : savedDarkMode === 'true';
                setDarkMode(prefersDark);
                document.body.classList.toggle('dark-mode', prefersDark);
                if (savedDarkMode === null) {
                    localStorage.setItem('darkMode', 'true');
                }

                const savedHighContrast = localStorage.getItem('highContrast');
                if (savedHighContrast === 'true') {
                    setHighContrast(true);
                    document.body.classList.add('high-contrast');
                }

                const savedReducedMotion = localStorage.getItem('reducedMotion');
                if (savedReducedMotion === 'true') {
                    setReducedMotion(true);
                }

                // Story 3-1: Load saved active preset with validation
                const savedActivePreset = localStorage.getItem('activePresetId');
                if (savedActivePreset) {
                    const presetExists = MODE_LIBRARY.some(m => m.id === savedActivePreset);
                    setActivePresetId(presetExists ? savedActivePreset : 'focus');
                }

                const savedPlaylist = localStorage.getItem('playlist');
                if (savedPlaylist) {
                    try {
                        const parsed = JSON.parse(savedPlaylist);
                        const filtered = parsed.filter((track) => track && track.source !== 'local' && track.url);
                        setPlaylist(filtered);
                    } catch (error) {
                        console.error('Error loading saved playlist:', error);
                    }
                }

                const handleOnline = () => setIsOnline(true);
                const handleOffline = () => setIsOnline(false);
                window.addEventListener('online', handleOnline);
                window.addEventListener('offline', handleOffline);

                return () => {
                    window.removeEventListener('online', handleOnline);
                    window.removeEventListener('offline', handleOffline);
                    disposeAudioGraph();
                    teardownAudioElement();
                    if (audioContextRef.current) {
                        audioContextRef.current.close();
                    }
                    clearRitualTimers();
                };
            }, []);

            // Story 3-3: Load all presets on mount
            useEffect(() => {
                const presets = getAllPresets();
                setAllPresets(presets);
                console.log('[PresetManagement] Loaded', presets.length, 'presets');
            }, []);

            // Cleanup URL validation on unmount
            useEffect(() => {
                // Initialize controller ref
                urlValidationControllerRef.current = {};
                
                return () => {
                    // Mark component as unmounted to prevent setState after unmount
                    urlValidationControllerRef.current = null;
                    
                    // Clear any pending toast timeout
                    if (toastTimeoutRef.current) {
                        clearTimeout(toastTimeoutRef.current);
                        toastTimeoutRef.current = null;
                    }
                };
            }, []);

            // Story 3-1: Persist active preset selection
            useEffect(() => {
                try {
                    localStorage.setItem('activePresetId', activePresetId);
                } catch (err) {
                    console.error('Failed to persist activePresetId:', err);
                }
            }, [activePresetId]);

            // Story 3-1: Apply preset parameters when activePresetId changes
            useEffect(() => {
                const preset = MODE_LIBRARY.find(m => m.id === activePresetId);
                if (preset) {
                    setSpeed(preset.preset.speed);
                    setIntensity(preset.preset.intensity);
                    setSpatialDepth(preset.preset.spatialDepth);
                    setMovementPattern(preset.preset.movement);
                    setBinauralEnabled(preset.preset.binaural.enabled);
                    setBinauralFreq(preset.preset.binaural.freq);
                    setNoiseType(preset.preset.noise.type);
                    setNoiseVolume(preset.preset.noise.volume);
                    setVisualWaveGain(preset.preset.noise.volume);
                }
            }, [activePresetId]);

            useEffect(() => {
                const serialized = playlist
                    .filter((track) => track.source !== 'local' && track.url)
                    .map((track) => ({
                        id: track.id,
                        name: track.name,
                        source: track.source,
                        url: track.url,
                        originalUrl: track.originalUrl || null
                    }));
                if (serialized.length > 0) {
                    localStorage.setItem('playlist', JSON.stringify(serialized));
                } else {
                    localStorage.removeItem('playlist');
                }
            }, [playlist]);

            useEffect(() => {
                const prevLength = prevPlaylistLengthRef.current;
                const isEmpty = playlist.length === 0;

                if (isEmpty) {
                    if (currentTrackIndex !== null) {
                        currentTrackIndexRef.current = null;
                        setCurrentTrackIndex(null);
                    }
                    teardownAudioElement();
                    disposeAudioGraph();
                    setIsPlaying(false);
                    if (prevLength !== 0) {
                        setHeroMessage('Playlist empty. Add audio to start a ritual.');
                        setNeedsAudio(true);
                        setRitualStatus('idle');
                        setRitualCountdown(HERO_BREATH_DURATION);
                        clearRitualTimers();
                    }
                } else if (currentTrackIndex !== null && currentTrackIndex >= playlist.length) {
                    const clampedIndex = Math.max(playlist.length - 1, 0);
                    currentTrackIndexRef.current = clampedIndex;
                    setCurrentTrackIndex(clampedIndex);
                }

                prevPlaylistLengthRef.current = playlist.length;
                playlistRef.current = playlist;
            }, [playlist.length, currentTrackIndex]);

            useEffect(() => {
                playlistRef.current = playlist;
            }, [playlist]);

            useEffect(() => {
                currentTrackIndexRef.current = currentTrackIndex;
            }, [currentTrackIndex]);

            // Clear accessibility announcements after 3 seconds to prevent re-announcements
            useEffect(() => {
                if (a11yAnnouncement) {
                    const timer = setTimeout(() => {
                        setA11yAnnouncement('');
                    }, 3000);
                    return () => clearTimeout(timer);
                }
            }, [a11yAnnouncement]);

            // Story 3-2: Keyboard shortcut (Ctrl+E) to toggle advanced controls
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'e') {
                        e.preventDefault();
                        setIsAdvancedControlsExpanded(prev => !prev);
                        setA11yAnnouncement(
                            isAdvancedControlsExpanded 
                                ? 'Advanced controls collapsed' 
                                : 'Advanced controls expanded'
                        );
                    }
                };
                
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [isAdvancedControlsExpanded]);

            useEffect(() => {
                const audio = audioElementRef.current;
                if (!audio) {
                    return;
                }
                const handleTimeUpdate = () => {
                    setCurrentTime(audio.currentTime || 0);
                    setDuration(audio.duration || 0);
                };
                audio.addEventListener('timeupdate', handleTimeUpdate);
                audio.addEventListener('loadedmetadata', handleTimeUpdate);
                return () => {
                    audio.removeEventListener('timeupdate', handleTimeUpdate);
                    audio.removeEventListener('loadedmetadata', handleTimeUpdate);
                };
            }, [audioElementToken]);

            const toggleDarkMode = () => {
                const next = !darkMode;
                setDarkMode(next);
                document.body.classList.toggle('dark-mode', next);
                localStorage.setItem('darkMode', String(next));
                setA11yAnnouncement(next ? 'Dark mode enabled' : 'Light mode enabled');
            };

            const toggleHighContrast = () => {
                const next = !highContrast;
                setHighContrast(next);
                document.body.classList.toggle('high-contrast', next);
                try {
                    if (next) {
                        localStorage.setItem('highContrast', 'true');
                    } else {
                        localStorage.removeItem('highContrast');
                    }
                } catch (e) {
                    console.warn('Failed to persist high-contrast preference', e);
                }
                setA11yAnnouncement(next ? 'High contrast mode enabled' : 'High contrast mode disabled');
            };

            const toggleReducedMotion = () => {
                const next = !reducedMotion;
                setReducedMotion(next);
                try {
                    if (next) {
                        localStorage.setItem('reducedMotion', 'true');
                    } else {
                        localStorage.removeItem('reducedMotion');
                    }
                } catch (e) {
                    console.warn('Failed to persist reduced-motion preference', e);
                }
                setA11yAnnouncement(next ? 'Reduced motion enabled' : 'Motion enabled');
            };

            const focusModeChip = (index) => {
                const total = MODE_LIBRARY.length;
                const normalized = ((index % total) + total) % total;
                setFocusedModeIndex(normalized);
                requestAnimationFrame(() => {
                    const chip = modeRefs.current[normalized];
                    if (chip) {
                        chip.focus();
                    }
                });
                return normalized;
            };

            // Story 3-1: Log preset changes for Epic 4 session tracking
            const logPresetChange = (newPresetId) => {
                const event = {
                    event: 'PRESET_CHANGED',
                    presetId: newPresetId,
                    previousPresetId: activePresetId,
                    timestamp: Date.now(),
                    trackId: currentTrackIndex !== null ? playlist[currentTrackIndex].id : null
                };
                console.log('[SessionLogger]', event);
                // E4 integration point - future: dispatch to IndexedDB logger
                // window.dispatchEvent(new CustomEvent('preset-changed', { detail: event }));
            };

            // Story 3-2: Epic 5 API for adaptive mode (sensor lock)
            const enableSensorMode = () => {
                setSensorLocked(true);
                setA11yAnnouncement('Adaptive mode enabled. Controls locked.');
                showToast('Adaptive mode active', 'info');
            };

            const disableSensorMode = () => {
                setSensorLocked(false);
                setA11yAnnouncement('Adaptive mode disabled. Controls unlocked.');
                showToast('Manual control restored', 'info');
            };

            // Expose API for Epic 5 integration
            useEffect(() => {
                window.audioControlsAPI = {
                    enableSensorMode,
                    disableSensorMode
                };
                return () => {
                    delete window.audioControlsAPI;
                };
            }, []);

            // ============================================================
            // Story 3-3: Custom Preset Management Handlers
            // ============================================================
            
            const openSavePresetDialog = () => {
                setEditingPreset(null);
                setShowSavePresetDialog(true);
            };

            const openEditPresetDialog = (preset) => {
                setEditingPreset(preset);
                setShowSavePresetDialog(true);
            };

            const closeSavePresetDialog = () => {
                setShowSavePresetDialog(false);
                setEditingPreset(null);
            };

            const handleSavePreset = (presetId) => {
                // Apply the newly saved/edited preset
                const presets = getAllPresets();
                setAllPresets(presets);
                
                const preset = presets.find(p => p.id === presetId);
                if (preset) {
                    applyPreset(preset.preset, preset.id);
                }
                
                closeSavePresetDialog();
            };

            const handleDeletePreset = (presetId) => {
                if (!confirm('Delete this preset? This cannot be undone.')) {
                    return;
                }
                
                const result = deleteCustomPreset(presetId, showToast);
                if (result) {
                    showToast(`Preset "${result.name}" deleted`, 'success');
                    setA11yAnnouncement(`Preset ${result.name} deleted`);
                    
                    // Update all presets list
                    const presets = getAllPresets();
                    setAllPresets(presets);
                    
                    // Update tracks using this preset to fallback to focus
                    setPlaylist(prev => prev.map(track => ({
                        ...track,
                        lastPresetId: track.lastPresetId === presetId ? 'focus' : track.lastPresetId
                    })));
                    
                    // If deleted preset was active, switch to focus
                    if (activePresetId === presetId) {
                        const focusMode = MODE_LIBRARY[0];
                        applyPreset(focusMode.preset, focusMode.id);
                        showToast('Switched to Focus preset', 'info');
                    }
                }
            };

            const handleQuickApplyPreset = (preset) => {
                applyPreset(preset.preset, preset.id);
                showToast(`Applied ${preset.name} preset`, 'success');
                setA11yAnnouncement(`${preset.name} preset applied`);
            };

            const setActiveMode = (index) => {
                const normalized = focusModeChip(index);
                const mode = MODE_LIBRARY[normalized];
                setModeIndex(normalized);
                applyPreset(mode.preset, mode.id);
                setHeroMessage(`${mode.label} preset queued. Press Start to begin.`);
                setA11yAnnouncement(`${mode.label} mode selected`);
            };

            const handleModeKeyDown = (event, index) => {
                const { key } = event;
                if (key === 'ArrowRight' || key === 'ArrowDown') {
                    event.preventDefault();
                    focusModeChip(index + 1);
                    return;
                }
                if (key === 'ArrowLeft' || key === 'ArrowUp') {
                    event.preventDefault();
                    focusModeChip(index - 1);
                    return;
                }
                if (key === 'Home') {
                    event.preventDefault();
                    focusModeChip(0);
                    return;
                }
                if (key === 'End') {
                    event.preventDefault();
                    focusModeChip(MODE_LIBRARY.length - 1);
                    return;
                }
                if (key === 'Enter' || key === ' ' || key === 'Spacebar') {
                    event.preventDefault();
                    setActiveMode(index);
                }
            };

            const setupAudioGraph = (audioElement) => {
                const context = audioContextRef.current;
                if (!context) return;

                if (context.state === 'suspended') {
                    context.resume();
                }

                disposeAudioGraph();

                const source = context.createMediaElementSource(audioElement);
                sourceNodeRef.current = source;

                const splitter = context.createChannelSplitter(2);
                const merger = context.createChannelMerger(2);

                const leftToLeftGain = context.createGain();
                const leftToRightGain = context.createGain();
                const rightToLeftGain = context.createGain();
                const rightToRightGain = context.createGain();

                const delayLeft = context.createDelay();
                const delayRight = context.createDelay();
                delayLeft.delayTime.value = 0.05;
                delayRight.delayTime.value = 0.05;

                const delayGainLeft = context.createGain();
                const delayGainRight = context.createGain();
                delayGainLeft.gain.value = 0.05 * spatialDepth;
                delayGainRight.gain.value = 0.05 * spatialDepth;

                const crossDelayLeft = context.createDelay();
                const crossDelayRight = context.createDelay();
                crossDelayLeft.delayTime.value = 0.03;
                crossDelayRight.delayTime.value = 0.03;

                const crossGainLeft = context.createGain();
                const crossGainRight = context.createGain();
                crossGainLeft.gain.value = 0.03 * spatialDepth;
                crossGainRight.gain.value = 0.03 * spatialDepth;

                rotationNodesRef.current = {
                    leftToLeftGain,
                    leftToRightGain,
                    rightToLeftGain,
                    rightToRightGain,
                    delayGainLeft,
                    delayGainRight,
                    crossGainLeft,
                    crossGainRight
                };

                source.connect(splitter);

                splitter.connect(leftToLeftGain, 0);
                splitter.connect(leftToRightGain, 0);
                splitter.connect(rightToLeftGain, 1);
                splitter.connect(rightToRightGain, 1);

                leftToLeftGain.connect(merger, 0, 0);
                leftToRightGain.connect(merger, 0, 1);
                rightToLeftGain.connect(merger, 0, 0);
                rightToRightGain.connect(merger, 0, 1);

                leftToLeftGain.connect(delayLeft);
                delayLeft.connect(delayGainLeft);
                delayGainLeft.connect(merger, 0, 0);

                rightToRightGain.connect(delayRight);
                delayRight.connect(delayGainRight);
                delayGainRight.connect(merger, 0, 1);

                leftToLeftGain.connect(crossDelayRight);
                crossDelayRight.connect(crossGainRight);
                crossGainRight.connect(merger, 0, 1);

                rightToRightGain.connect(crossDelayLeft);
                crossDelayLeft.connect(crossGainLeft);
                crossGainLeft.connect(merger, 0, 0);

                const gainChain = AudioEngine.connectGainStaging(context, merger, {
                    volume,
                    fftSize: 2048
                });

                gainChainRef.current = gainChain;
                gainNodeRef.current = gainChain.mainGain;
                analyserRef.current = gainChain.analyser;

                syncBinauralChain();
                syncNoiseLayer();

                startRotation();

                if (showVisualizer) {
                    visualize();
                }
            };

            const startRotation = () => {
                if (rotationIntervalRef.current) {
                    clearInterval(rotationIntervalRef.current);
                }
                if (!rotationNodesRef.current) {
                    return;
                }
                
                let time = 0;
                rotationIntervalRef.current = setInterval(() => {
                    const nodes = rotationNodesRef.current;
                    const ctx = audioContextRef.current;
                    if (
                        !nodes ||
                        !ctx ||
                        !nodes.leftToLeftGain ||
                        !nodes.leftToRightGain ||
                        !nodes.rightToLeftGain ||
                        !nodes.rightToRightGain
                    ) {
                        return;
                    }
                    
                    const angle = 2 * Math.PI * speed * time;
                    let panPosition = 0;
                    
                    // Calculate pan position based on movement pattern
                    switch(movementPattern) {
                        case 'circle':
                            panPosition = Math.sin(angle);
                            break;
                        case 'figure8':
                            panPosition = Math.sin(angle) * Math.cos(angle / 2);
                            break;
                        case 'leftright':
                            panPosition = Math.sin(angle);
                            break;
                        case 'frontback':
                            panPosition = Math.cos(angle) * 0.5;
                            break;
                        case 'random':
                            if (Math.random() > 0.9) {
                                panPosition = (Math.random() * 2 - 1);
                            }
                            break;
                    }
                    
                    // Apply intensity to pan position
                    panPosition *= intensity;
                    
                    // CRITICAL FIX: Normalized gain distribution to prevent clipping
                    // Total energy must equal 1.0 to prevent gain accumulation
                    const normalizationFactor = 0.5; // Base gain per channel before panning
                    const crossChannelMix = 0.15; // Reduced cross-channel bleeding
                    
                    // Main channel gains (normalized to prevent sum > 1.0)
                    const leftChannelGain = (1 - panPosition) * 0.5; // 0.0 to 1.0
                    const rightChannelGain = (1 + panPosition) * 0.5; // 0.0 to 1.0
                    
                    // Apply normalization to prevent clipping
                    const targetLeftGain = Math.max(0.001, leftChannelGain * normalizationFactor);
                    const targetRightGain = Math.max(0.001, rightChannelGain * normalizationFactor);
                    
                    // Cross-channel gains (proportional to opposite channel, heavily attenuated)
                    const targetLeftToRight = Math.max(0.001, rightChannelGain * crossChannelMix * normalizationFactor);
                    const targetRightToLeft = Math.max(0.001, leftChannelGain * crossChannelMix * normalizationFactor);
                    
                    // Use exponentialRampToValueAtTime for smoother transitions (prevents clicks better than linear)
                    const now = ctx.currentTime;
                    const rampTime = now + 0.016; // ~1 frame at 60fps for responsive panning
                    
                    // Clamp to prevent automation errors
                    const clamp = (val) => Math.max(0.0001, Math.min(1, val));
                    
                    nodes.leftToLeftGain.gain.setValueAtTime(clamp(nodes.leftToLeftGain.gain.value), now);
                    nodes.leftToLeftGain.gain.exponentialRampToValueAtTime(clamp(targetLeftGain), rampTime);
                    
                    nodes.rightToRightGain.gain.setValueAtTime(clamp(nodes.rightToRightGain.gain.value), now);
                    nodes.rightToRightGain.gain.exponentialRampToValueAtTime(clamp(targetRightGain), rampTime);
                    
                    nodes.leftToRightGain.gain.setValueAtTime(clamp(nodes.leftToRightGain.gain.value), now);
                    nodes.leftToRightGain.gain.exponentialRampToValueAtTime(clamp(targetLeftToRight), rampTime);
                    
                    nodes.rightToLeftGain.gain.setValueAtTime(clamp(nodes.rightToLeftGain.gain.value), now);
                    nodes.rightToLeftGain.gain.exponentialRampToValueAtTime(clamp(targetRightToLeft), rampTime);
                    
                    time += 0.05;
                }, 50);
            };

            const visualize = () => {
                if (!analyserRef.current || !canvasRef.current) return;
                
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const analyser = analyserRef.current;
                
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                const draw = () => {
                    animationFrameRef.current = requestAnimationFrame(draw);
                    
                    analyser.getByteFrequencyData(dataArray);
                    
                    ctx.fillStyle = darkMode ? '#1a2332' : '#f8f9fa';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const barWidth = (canvas.width / bufferLength) * 2.5;
                    let x = 0;
                    const visualGain = Math.max(0, Math.min(visualWaveGainRef.current / 0.5, 1));
                    
                    for (let i = 0; i < bufferLength; i++) {
                        const barHeight = ((dataArray[i] / 255) * canvas.height) * visualGain;
                        
                        const hue = (i / bufferLength) * 360;
                        ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                        ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                        
                        x += barWidth + 1;
                    }
                };
                
                draw();
            };

            // File validation helper
            const validateFile = (file) => {
                // Check for empty files
                if (file.size === 0) {
                    return { valid: false, reason: 'empty', file };
                }
                
                // Check MIME type
                if (!SUPPORTED_MIME_TYPES.includes(file.type)) {
                    return { valid: false, reason: 'unsupported', file };
                }
                
                return { valid: true, file };
            };

            // File size formatter
            const formatFileSize = (bytes) => {
                if (bytes === 0) return '0 B';
                if (bytes < 1024) return `${bytes} B`;
                if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
                return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
            };

            // File type formatter
            const formatFileType = (mimeType) => {
                const typeMap = {
                    'audio/mpeg': 'MP3',
                    'audio/wav': 'WAV',
                    'audio/wave': 'WAV',
                    'audio/ogg': 'OGG',
                    'audio/x-wav': 'WAV'
                };
                return typeMap[mimeType] || 'Audio';
            };

            // Toast notification helper
            const showToast = (message, type = 'info') => {
                // Clear any existing timeout
                if (toastTimeoutRef.current) {
                    clearTimeout(toastTimeoutRef.current);
                }
                
                setToastMessage(message);
                setToastType(type);
                
                // Auto-dismiss after 5 seconds
                toastTimeoutRef.current = setTimeout(() => {
                    setToastMessage('');
                    toastTimeoutRef.current = null;
                }, 5000);
            };

            const addLocalFiles = (files) => {
                const fileArray = Array.from(files);
                
                try {
                    // Show progress indicator for large batches
                    if (fileArray.length > 5) {
                        setIsProcessingFiles(true);
                        setHeroMessage(`Adding ${fileArray.length} tracks...`);
                    }
                    
                    // Validate and filter files
                    const validFiles = [];
                    const rejectedFiles = [];
                    
                    fileArray.forEach(file => {
                        const validation = validateFile(file);
                        if (validation.valid) {
                            validFiles.push(file);
                        } else {
                            rejectedFiles.push({ 
                                name: file.name, 
                                reason: validation.reason 
                            });
                        }
                    });
                    
                    // Create playlist tracks from valid files
                    const newTracks = validFiles.map((file, index) => {
                        // Remove any audio extension, not just .mp3
                        const baseName = file.name.replace(/\.(mp3|wav|ogg)$/i, '');
                        return {
                            id: Date.now() + index,
                            name: baseName,
                            source: 'local',
                            file: file,
                            url: null,
                            metadata: {
                                size: file.size,
                                type: file.type,
                                lastModified: file.lastModified
                            }
                        };
                    });
                    
                    // Update playlist
                    if (newTracks.length > 0) {
                        setPlaylist(prev => [...prev, ...newTracks]);
                        setNeedsAudio(false);
                        
                        const trackWord = newTracks.length === 1 ? 'track' : 'tracks';
                        setHeroMessage(`Added ${newTracks.length} ${trackWord}. Pick a ritual and press Start.`);
                        setA11yAnnouncement(`${newTracks.length} ${trackWord} added to playlist`);
                    }
                    
                    // Show rejection toast if needed
                    if (rejectedFiles.length > 0) {
                        const emptyCount = rejectedFiles.filter(f => f.reason === 'empty').length;
                        const unsupportedCount = rejectedFiles.filter(f => f.reason === 'unsupported').length;
                        
                        let message = '';
                        if (emptyCount > 0) {
                            message += `${emptyCount} empty file${emptyCount > 1 ? 's' : ''} rejected. `;
                        }
                        if (unsupportedCount > 0) {
                            message += `${unsupportedCount} unsupported file${unsupportedCount > 1 ? 's' : ''} rejected. Use MP3, WAV, or OGG.`;
                        }
                        
                        showToast(message, 'warning');
                        setA11yAnnouncement(message);
                    }
                } finally {
                    // Always hide progress indicator, even if errors occur
                    setIsProcessingFiles(false);
                }
            };

            const handleDrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                const files = e.dataTransfer.files;
                if (files && files.length > 0) {
                    addLocalFiles(files);
                }
                setDragActive(false);
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!dragActive) {
                    setDragActive(true);
                }
            };

            const handleDragEnter = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setDragActive(true);
            };

            const handleDragLeave = (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (e.relatedTarget && e.currentTarget.contains(e.relatedTarget)) {
                    return;
                }
                setDragActive(false);
            };

            // URL format validator
            const isValidUrl = (str) => {
                try {
                    const url = new URL(str);
                    return url.protocol === 'http:' || url.protocol === 'https:';
                } catch {
                    return false;
                }
            };

            // Unsupported service detector
            const detectUnsupportedService = (url) => {
                const urlLower = url.toLowerCase();
                if (urlLower.includes('youtube.com') || urlLower.includes('youtu.be')) {
                    return { service: 'YouTube', supported: false };
                }
                if (urlLower.includes('spotify.com')) {
                    return { service: 'Spotify', supported: false };
                }
                return { supported: true };
            };

            // Stream URL validator (async)
            const validateStreamUrl = async (url) => {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                try {
                    const response = await fetch(url, {
                        method: 'HEAD',
                        mode: 'cors',
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                    
                    if (response.ok) {
                        return { valid: true, url };
                    } else {
                        return { 
                            valid: false, 
                            reason: 'unreachable',
                            status: response.status 
                        };
                    }
                } catch (err) {
                    clearTimeout(timeoutId);
                    
                    if (err.name === 'AbortError') {
                        return { valid: false, reason: 'timeout' };
                    }
                    
                    // CORS or network error
                    return { valid: false, reason: 'cors', error: err };
                }
            };

            const addUrl = async () => {
                const url = urlInput.trim();
                
                // Ignore empty input
                if (!url) return;
                
                // 1. Format validation
                if (!isValidUrl(url)) {
                    showToast('Invalid URL format. Use: https://example.com/song.mp3', 'error');
                    setA11yAnnouncement('Invalid URL format');
                    return;
                }
                
                // 2. Unsupported service detection
                const serviceCheck = detectUnsupportedService(url);
                if (!serviceCheck.supported) {
                    showToast(
                        `${serviceCheck.service} playback requires authenticated proxy. Direct MP3 URLs only.`,
                        'warning'
                    );
                    setA11yAnnouncement(`${serviceCheck.service} not supported`);
                    return;
                }
                
                // 3. Show validating state
                setIsValidatingUrl(true);
                setHeroMessage('Validating stream URL...');
                
                // 4. HEAD request validation with cleanup tracking
                try {
                    const validation = await validateStreamUrl(url);
                    
                    // Check if component still mounted
                    if (!urlValidationControllerRef.current) {
                        return; // Component unmounted during validation
                    }
                    
                    setIsValidatingUrl(false);
                    
                    if (!validation.valid) {
                        let message = '';
                        
                        switch (validation.reason) {
                            case 'cors':
                                message = 'Stream blocked by CORS. Use direct MP3 link or enable server CORS.';
                                break;
                            case 'timeout':
                                message = 'Request timeout (5s). Server unreachable or slow.';
                                break;
                            case 'unreachable':
                                message = `Stream unreachable (${validation.status}). Check URL and try again.`;
                                break;
                            default:
                                message = 'Unable to validate stream. Check URL.';
                        }
                        
                        showToast(message, 'error');
                        setA11yAnnouncement(message);
                        setHeroMessage('Stream validation failed. Try another URL.');
                        return;
                    }
                    
                    // 5. Add validated URL to playlist
                    const newTrack = {
                        id: Date.now(),
                        name: 'Remote Track',
                        source: 'url',
                        url: url,
                        originalUrl: url
                    };
                    
                    setPlaylist(prev => [...prev, newTrack]);
                    setUrlInput('');
                    setNeedsAudio(false);
                    setHeroMessage('Stream validated and added. Start your ritual to hear it.');
                    setA11yAnnouncement('Stream added to playlist');
                } catch (err) {
                    // Handle unexpected errors
                    if (urlValidationControllerRef.current) {
                        setIsValidatingUrl(false);
                        showToast('Validation error. Please try again.', 'error');
                    }
                }
            };

            const playTrack = (index) => {
                const activePlaylist = playlistRef.current || playlist;
                const track = activePlaylist[index];
                if (!track) return;
                
                // Story 3-3: Auto-restore last-used preset for this track
                if (track.lastPresetId) {
                    const presets = getAllPresets();
                    const savedPreset = presets.find(p => p.id === track.lastPresetId);
                    
                    if (savedPreset) {
                        // Restore the preset if it's different from current
                        if (activePresetId !== track.lastPresetId) {
                            applyPreset(savedPreset.preset, savedPreset.id);
                            showToast(`Restored ${savedPreset.name} preset for "${track.name}"`, 'info');
                            setA11yAnnouncement(`Restored ${savedPreset.name} preset`);
                        }
                    } else {
                        // Preset was deleted, fallback to focus
                        console.warn(`[AutoRestore] Preset ${track.lastPresetId} not found for track ${track.name}, using Focus`);
                        const focusMode = MODE_LIBRARY[0];
                        applyPreset(focusMode.preset, focusMode.id);
                    }
                } else {
                    // First time playing this track - save current preset
                    setPlaylist(prev => prev.map((t, i) => 
                        i === index ? { ...t, lastPresetId: activePresetId } : t
                    ));
                    console.log(`[AutoRestore] Saved preset ${activePresetId} for track ${track.name}`);
                }
                
                const audio = prepareAudioElement();
                
                const handleLoadedMetadata = () => {
                    setupAudioGraph(audio);
                    audio.play().then(() => {
                        setIsPlaying(true);
                    }).catch(err => {
                        console.error('Playback error:', err);
                        alert('Playback error. If you opened this from file://, please run a local web server.\n\nQuick fix: Run "python3 -m http.server 8000" in this folder');
                    });
                };
                
                audio.addEventListener('loadedmetadata', handleLoadedMetadata, { once: true });
                
                const assignSource = () => {
                    if (track.source === 'local' && track.file) {
                        try {
                            const blobUrl = URL.createObjectURL(track.file);
                            currentBlobUrlRef.current = blobUrl;
                            audio.src = blobUrl;
                        } catch (err) {
                            console.error('Error creating blob URL:', err);
                            audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
                            alert('Error loading file. Please serve this HTML from a web server (see console for instructions).\n\nQuick fix: Run "python3 -m http.server 8000" in this folder, then open http://localhost:8000/8d-player-live.html');
                            return false;
                        }
                    } else if (track.source === 'youtube') {
                        audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
                        alert('YouTube playback requires a backend server or YouTube API. Please use direct MP3 URLs or local files.');
                        teardownAudioElement();
                        return false;
                    } else if (track.url) {
                        audio.src = track.url;
                    } else {
                        audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
                        alert('Invalid track source');
                        teardownAudioElement();
                        return false;
                    }
                    return true;
                };
                
                const assigned = assignSource();
                if (!assigned) {
                    return;
                }
                
                audio.load();
                
                currentTrackIndexRef.current = index;
                setCurrentTrackIndex(index);
                setRitualStatus('active');
                setHeroMessage(`Now playing ${track.name} ‚Ä¢ ${selectedMode.label}`);
                setNeedsAudio(false);
            };

            playNextRef.current = () => {
                const playlistSnapshot = playlistRef.current;
                if (!playlistSnapshot || playlistSnapshot.length === 0) {
                    return;
                }
                const indexSnapshot = currentTrackIndexRef.current;
                if (
                    indexSnapshot === null ||
                    indexSnapshot === undefined ||
                    indexSnapshot < 0 ||
                    indexSnapshot >= playlistSnapshot.length
                ) {
                    playTrack(0);
                    return;
                }
                const nextIndex = (indexSnapshot + 1) % playlistSnapshot.length;
                playTrack(nextIndex);
            };

            const togglePlayPause = () => {
                if (!audioElementRef.current) {
                    if (playlist.length > 0) {
                        playTrack(0);
                    }
                    return;
                }
                
                const audio = audioElementRef.current;
                
                if (isPlaying) {
                    audio.pause();
                    setIsPlaying(false);
                } else {
                    audio.play().then(() => {
                        setIsPlaying(true);
                    });
                }
            };

            const playNext = () => {
                if (typeof playNextRef.current === 'function') {
                    playNextRef.current();
                }
            };

            const playPrevious = () => {
                if (currentTrackIndex === null || playlist.length === 0) {
                    return;
                }
                const prevIndex = currentTrackIndex === 0 ? playlist.length - 1 : currentTrackIndex - 1;
                playTrack(prevIndex);
            };

            const removeFromPlaylist = (id) => {
                const currentList = playlist;
                const removedIndex = currentList.findIndex(track => track.id === id);
                if (removedIndex === -1) {
                    return;
                }
                const nextPlaylist = currentList.filter(track => track.id !== id);
                setPlaylist(nextPlaylist);

                const prevIndex = currentTrackIndex;
                const removedWasCurrent = prevIndex === removedIndex;
                if (removedWasCurrent) {
                    teardownAudioElement();
                    disposeAudioGraph();
                    setIsPlaying(false);
                }

                let nextIndex = prevIndex;
                if (nextPlaylist.length === 0) {
                    nextIndex = null;
                } else if (removedWasCurrent) {
                    nextIndex = Math.min(removedIndex, nextPlaylist.length - 1);
                } else if (typeof prevIndex === 'number' && removedIndex < prevIndex) {
                    nextIndex = Math.max(prevIndex - 1, 0);
                } else if (typeof prevIndex === 'number' && prevIndex >= nextPlaylist.length) {
                    nextIndex = nextPlaylist.length - 1;
                }

                if (nextIndex !== prevIndex) {
                    currentTrackIndexRef.current = nextIndex;
                    setCurrentTrackIndex(nextIndex);
                }
            };

            const handleSeekChange = (event) => {
                if (!audioElementRef.current) return;
                const nextTime = parseFloat(event.target.value);
                if (Number.isNaN(nextTime)) return;
                audioElementRef.current.currentTime = nextTime;
                setCurrentTime(nextTime);
            };

            const ensurePlaylistReady = () => {
                if (playlist.length === 0) {
                    setNeedsAudio(true);
                    setHeroMessage('Add a local file or stream to begin this ritual.');
                    if (dropZoneRef.current) {
                        dropZoneRef.current.focus();
                    }
                    return false;
                }
                return true;
            };

            const launchRitualPlayback = () => {
                // Log ritual completion telemetry
                try {
                    const ritualEndTs = Date.now();
                    const ritualEvent = {
                        type: 'FOCUS_RITUAL_COMPLETED',
                        timestamp: ritualEndTs,
                        modeId: selectedMode.id,
                        modeLabel: selectedMode.label,
                        presetApplied: selectedMode.id,
                        duration: HERO_BREATH_DURATION
                    };
                    console.log('[SessionLogger]', ritualEvent);
                    // Future: Store in IndexedDB sessions store
                } catch (e) {
                    console.warn('Failed to log ritual completion', e);
                }

                setRitualStatus('active');
                setHeroMessage(`Ritual active ‚Äî ${selectedMode.label} preset live.`);
                setNeedsAudio(false);
                setBreathingPhase('');
                
                if (currentTrackIndex === null) {
                    playTrack(0);
                    return;
                }
                const audio = audioElementRef.current;
                if (audio) {
                    audio.play().then(() => {
                        setIsPlaying(true);
                    }).catch(() => {
                        setHeroMessage('Press play to continue your ritual.');
                    });
                } else {
                    playTrack(currentTrackIndex);
                }
            };

            const startRitual = () => {
                if (!ensurePlaylistReady()) {
                    return;
                }
                
                // Check if skip preference is enabled
                if (skipRitualPref) {
                    // Log skip telemetry
                    try {
                        const skipEvent = {
                            type: 'RITUAL_SKIPPED',
                            timestamp: Date.now(),
                            modeId: selectedMode.id,
                            reason: 'skip-preference-enabled'
                        };
                        console.log('[SessionLogger]', skipEvent);
                    } catch (e) {
                        console.warn('Failed to log ritual skip', e);
                    }
                    launchRitualPlayback();
                    return;
                }
                
                clearRitualTimers();
                setRitualStatus('breathing');
                setHeroMessage(`Breathe in...`);
                setRitualCountdown(HERO_BREATH_DURATION);
                setBreathingPhase('inhale');
                
                // Log ritual start telemetry
                try {
                    const startEvent = {
                        type: 'RITUAL_STARTED',
                        timestamp: Date.now(),
                        modeId: selectedMode.id,
                        modeLabel: selectedMode.label,
                        duration: HERO_BREATH_DURATION
                    };
                    console.log('[SessionLogger]', startEvent);
                } catch (e) {
                    console.warn('Failed to log ritual start', e);
                }
                
                // Countdown timer (1s intervals)
                ritualIntervalRef.current = setInterval(() => {
                    setRitualCountdown((prev) => {
                        const next = Math.max(prev - 1, 0);
                        if (next === 0) {
                            clearInterval(ritualIntervalRef.current);
                            ritualIntervalRef.current = null;
                        }
                        return next;
                    });
                }, 1000);
                
                // 4-2-4 breathing phase cycle (6s total: 2s in, 1s hold, 2s out, 1s hold)
                // Repeat ~3.33 times over 20 seconds
                let phaseStep = 0;
                breathingPhaseIntervalRef.current = setInterval(() => {
                    phaseStep++;
                    const cyclePosition = phaseStep % 6;
                    
                    if (cyclePosition === 0 || cyclePosition === 1) {
                        // Inhale (2 seconds)
                        setBreathingPhase('inhale');
                        setHeroMessage('Breathe in...');
                    } else if (cyclePosition === 2) {
                        // Hold after inhale (1 second)
                        setBreathingPhase('hold-in');
                        setHeroMessage('Hold...');
                    } else if (cyclePosition === 3 || cyclePosition === 4) {
                        // Exhale (2 seconds)
                        setBreathingPhase('exhale');
                        setHeroMessage('Breathe out...');
                    } else if (cyclePosition === 5) {
                        // Hold after exhale (1 second)
                        setBreathingPhase('hold-out');
                        setHeroMessage('Hold...');
                    }
                }, 1000);
                
                // Auto-launch after 20 seconds
                ritualTimeoutRef.current = setTimeout(() => {
                    clearRitualTimers();
                    launchRitualPlayback();
                }, HERO_BREATH_DURATION * 1000);
            };

            const skipRitual = () => {
                if (!ensurePlaylistReady()) {
                    return;
                }
                
                // Log skip telemetry
                try {
                    const skipEvent = {
                        type: 'RITUAL_SKIPPED',
                        timestamp: Date.now(),
                        modeId: selectedMode.id,
                        reason: 'user-skip-button'
                    };
                    console.log('[SessionLogger]', skipEvent);
                } catch (e) {
                    console.warn('Failed to log ritual skip', e);
                }
                
                clearRitualTimers();
                setRitualCountdown(0);
                setBreathingPhase('');
                launchRitualPlayback();
            };

            const toggleSkipRitualPref = () => {
                const newValue = !skipRitualPref;
                setSkipRitualPref(newValue);
                try {
                    if (newValue) {
                        localStorage.setItem('skipBreathingRitual', 'true');
                    } else {
                        localStorage.removeItem('skipBreathingRitual');
                    }
                } catch (e) {
                    console.warn('Failed to persist skip preference', e);
                }
            };

            // Story 3-1: Apply preset configuration to all audio parameters
            const applyPreset = (preset, presetId) => {
                performance.mark('preset-apply-start');
                
                // Batch all parameter updates (React 18 auto-batches in event handlers)
                setSpeed(preset.speed);
                setIntensity(preset.intensity);
                setSpatialDepth(preset.spatialDepth);
                setMovementPattern(preset.movement);
                setBinauralEnabled(preset.binaural.enabled);
                setBinauralFreq(preset.binaural.freq);
                setNoiseType(preset.noise.type);
                setNoiseVolume(preset.noise.volume);
                setVisualWaveGain(preset.noise.volume);
                
                // Update active preset tracking
                setActivePresetId(presetId);
                
                // Story 3-3: Update current track's lastPresetId when preset changes
                if (currentTrackIndex !== null && playlist[currentTrackIndex]) {
                    setPlaylist(prev => prev.map((track, i) => 
                        i === currentTrackIndex ? { ...track, lastPresetId: presetId } : track
                    ));
                    console.log(`[AutoRestore] Updated track ${playlist[currentTrackIndex].name} lastPresetId to ${presetId}`);
                }
                
                // Log preset change event
                logPresetChange(presetId);
                
                performance.mark('preset-apply-end');
                const measure = performance.measure('preset-apply', 'preset-apply-start', 'preset-apply-end');
                console.log(`[Performance] Preset applied in ${measure.duration.toFixed(2)}ms`);
                
                // Restart rotation with new settings if playing
                if (isPlaying) {
                    startRotation();
                }
            };

            // Update effects in real-time
            useEffect(() => {
                if (isPlaying) {
                    startRotation();
                }
            }, [speed, intensity, movementPattern]);

            useEffect(() => {
                const nodes = rotationNodesRef.current;
                if (!nodes) {
                    return;
                }
                if (nodes.delayGainLeft) {
                    nodes.delayGainLeft.gain.value = 0.05 * spatialDepth;
                }
                if (nodes.delayGainRight) {
                    nodes.delayGainRight.gain.value = 0.05 * spatialDepth;
                }
                if (nodes.crossGainLeft) {
                    nodes.crossGainLeft.gain.value = 0.03 * spatialDepth;
                }
                if (nodes.crossGainRight) {
                    nodes.crossGainRight.gain.value = 0.03 * spatialDepth;
                }
            }, [spatialDepth]);

            useEffect(() => {
                visualWaveGainRef.current = visualWaveGain;
            }, [visualWaveGain]);

            useEffect(() => {
                if (gainChainRef.current) {
                    gainChainRef.current.setVolume(volume);
                }
            }, [volume]);

            useEffect(() => {
                syncBinauralChain();
            }, [binauralEnabled, binauralFreq]);

            useEffect(() => {
                syncNoiseLayer();
            }, [noiseType, noiseVolume]);

            const formatTime = (seconds) => {
                if (!seconds || isNaN(seconds)) return '0:00';
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            };

            const getTotalDuration = () => {
                return playlist.length * 3.5; // Estimate 3.5 minutes per track
            };

            const getBinauralDescription = (freq) => {
                if (freq <= 4) return 'Delta (Sleep)';
                if (freq <= 8) return 'Theta (Meditation)';
                if (freq <= 14) return 'Alpha (Relaxation)';
                if (freq <= 30) return 'Beta (Focus)';
                return 'Gamma (Peak Focus)';
            };

            const dropZoneClasses = ['drop-zone'];
            if (needsAudio) {
                dropZoneClasses.push('drop-zone--attention');
            }
            if (dragActive) {
                dropZoneClasses.push('drop-zone--hover');
            }

return (
                <div className="screen">
                    {/* 
                    KEYBOARD SHORTCUTS REFERENCE
                    ============================
                    
                    Navigation:
                    - Tab: Move forward through interactive elements
                    - Shift+Tab: Move backward through interactive elements
                    
                    Mode Selection (when mode chips focused):
                    - Arrow Left/Right: Navigate between Focus/Calm/Energize modes
                    - Enter or Space: Activate selected mode
                    
                    Toggle Buttons:
                    - Tab to reach: Dark mode, Reduced motion, High contrast toggles
                    - Enter or Space: Toggle the focused setting
                    
                    Playback Controls:
                    - Tab to reach: Play/Pause, Previous, Next buttons
                    - Enter or Space: Activate playback control
                    
                    Ritual Flow:
                    - Tab to reach: Start button or Skip button during ritual
                    - Enter or Space: Start ritual or skip breathing animation
                    
                    Accessibility Features:
                    - All state changes announced via screen reader
                    - Focus indicators visible on all interactive elements
                    - ‚â•48px tap targets for touch accessibility
                    */}
                    <header className="app-header">
                        <div>
                            <p className="eyebrow">Unified Ritual Player</p>
                            <h1>8D Ritual Shell</h1>
                            <p className="hero-support">Stable v2 audio graph + v3 layout unified for Focus/Calm/Energize.</p>
                        </div>
                        <div className="header-actions">
                            <button type="button" className="primary-btn" aria-label="Install unified ritual shell">
                                üì≤ Install
                            </button>
                            <button
                                type="button"
                                onClick={toggleDarkMode}
                                aria-pressed={darkMode}
                                aria-label="Toggle dark mode"
                            >
                                {darkMode ? '‚òÄÔ∏è Light mode' : 'üåô Dark mode'}
                            </button>
                            <button
                                type="button"
                                onClick={toggleReducedMotion}
                                aria-pressed={reducedMotion}
                                aria-label="Toggle reduced motion"
                            >
                                {reducedMotion ? 'Motion reduced' : 'Motion on'}
                            </button>
                            <button
                                type="button"
                                onClick={toggleHighContrast}
                                aria-pressed={highContrast}
                                aria-label="Toggle high contrast mode"
                            >
                                {highContrast ? '‚óê High contrast' : '‚óã Normal contrast'}
                            </button>
                        </div>
                    </header>

                    {/* Accessibility announcements for screen readers */}
                    <div 
                        className="sr-only" 
                        role="status" 
                        aria-live="polite" 
                        aria-atomic="true"
                    >
                        {a11yAnnouncement}
                    </div>

                    {/* Toast Notification */}
                    {toastMessage && (
                        <div 
                            className={`toast toast-${toastType}`}
                            role="alert"
                            aria-live="polite"
                            style={{
                                position: 'fixed',
                                bottom: '24px',
                                left: '50%',
                                transform: 'translateX(-50%)',
                                backgroundColor: toastType === 'warning' ? '#fbbf24' : 
                                               toastType === 'error' ? '#f87171' : 
                                               toastType === 'success' ? '#4ade80' : 
                                               '#a78bfa',
                                color: toastType === 'warning' || toastType === 'success' ? '#1f2937' : '#111827',
                                padding: '12px 24px',
                                borderRadius: '8px',
                                boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
                                fontWeight: '500',
                                fontSize: '14px',
                                maxWidth: '500px',
                                zIndex: 10000,
                                animation: 'slideUp 0.3s ease-out'
                            }}
                        >
                            {toastMessage}
                        </div>
                    )}

                    {/* Processing Spinner */}
                    {isProcessingFiles && (
                        <div 
                            className="processing-spinner"
                            role="status"
                            aria-live="polite"
                            style={{
                                position: 'fixed',
                                top: '50%',
                                left: '50%',
                                transform: 'translate(-50%, -50%)',
                                backgroundColor: 'rgba(0, 0, 0, 0.85)',
                                padding: '24px 32px',
                                borderRadius: '12px',
                                display: 'flex',
                                flexDirection: 'column',
                                alignItems: 'center',
                                gap: '16px',
                                zIndex: 9999
                            }}
                        >
                            <div style={{
                                width: '40px',
                                height: '40px',
                                border: '4px solid #4b5563',
                                borderTop: '4px solid #a78bfa',
                                borderRadius: '50%',
                                animation: 'spin 1s linear infinite'
                            }} />
                            <span style={{ color: '#f3f4f6', fontSize: '14px' }}>
                                Processing files...
                            </span>
                        </div>
                    )}

                    {showFileWarning && (
                        <div className="alert-inline" role="alert">
                            Web Audio needs to run over HTTP. From repo root run <code>python3 -m http.server 8000</code> then open http://localhost:8000/index.html.
                        </div>
                    )}

                    <div className="main-grid">
                        <section className="column-card panel" aria-label="Ritual selection">
                            <div className="mode-tabs" role="tablist" aria-label="Ritual modes">
                                {MODE_LIBRARY.map((mode, index) => (
                                    <button
                                        key={mode.id}
                                        id={`mode-tab-${mode.id}`}
                                        role="tab"
                                        aria-selected={activePresetId === mode.id}
                                        aria-current={activePresetId === mode.id ? 'step' : undefined}
                                        tabIndex={focusedModeIndex === index ? 0 : -1}
                                        ref={(el) => (modeRefs.current[index] = el)}
                                        data-selected={activePresetId === mode.id}
                                        className="mode-chip"
                                        style={{ '--chip-accent': mode.accent }}
                                        onClick={() => setActiveMode(index)}
                                        onKeyDown={(event) => handleModeKeyDown(event, index)}
                                    >
                                        <span>{mode.label}</span>
                                        <small>{mode.short}</small>
                                    </button>
                                ))}
                            </div>

                            {/* Story 3-2: Advanced Controls Drawer */}
                            <AdvancedControls
                                speed={speed}
                                setSpeed={setSpeed}
                                intensity={intensity}
                                setIntensity={setIntensity}
                                spatialDepth={spatialDepth}
                                setSpatialDepth={setSpatialDepth}
                                movementPattern={movementPattern}
                                setMovementPattern={setMovementPattern}
                                binauralEnabled={binauralEnabled}
                                setBinauralEnabled={setBinauralEnabled}
                                binauralFreq={binauralFreq}
                                setBinauralFreq={setBinauralFreq}
                                noiseType={noiseType}
                                setNoiseType={setNoiseType}
                                noiseVolume={noiseVolume}
                                setNoiseVolume={setNoiseVolume}
                                isExpanded={isAdvancedControlsExpanded}
                                setIsExpanded={setIsAdvancedControlsExpanded}
                                sensorLocked={sensorLocked}
                                setSensorLocked={setSensorLocked}
                                setA11yAnnouncement={setA11yAnnouncement}
                                onSavePreset={openSavePresetDialog}
                            />

                            <article
                                className="hero-card"
                                id={`mode-panel-${selectedMode.id}`}
                                role="tabpanel"
                                aria-labelledby={`mode-tab-${selectedMode.id}`}
                            >
                                <p className="eyebrow">{selectedMode.label} ritual</p>
                                <h2>{selectedMode.heroCopy}</h2>
                                <div className="hero-message" aria-live="polite">{heroMessage}</div>
                                {ritualStatus === 'breathing' && (
                                    <div className="hero-countdown" aria-live="assertive">
                                        {!reducedMotion && (
                                            <div
                                                className="hero-animation"
                                                aria-hidden="true"
                                                style={{ borderColor: selectedMode.accent }}
                                            />
                                        )}
                                        <div>
                                            <div className="hero-countdown__value">{ritualCountdown}s</div>
                                            <p className="hero-support" aria-live="polite">
                                                {breathingPhase === 'inhale' && 'Breathe in (2s)'}
                                                {breathingPhase === 'hold-in' && 'Hold (1s)'}
                                                {breathingPhase === 'exhale' && 'Breathe out (2s)'}
                                                {breathingPhase === 'hold-out' && 'Hold (1s)'}
                                                {!breathingPhase && '4-2-4 cadence'}
                                            </p>
                                        </div>
                                    </div>
                                )}
                                <p className="hero-support">{selectedMode.description}</p>
                                <div className="hero-actions">
                                    <button type="button" className="primary-btn" onClick={startRitual}>
                                        Start {selectedMode.label}
                                    </button>
                                    {ritualStatus === 'breathing' && (
                                        <>
                                            <button type="button" className="ghost-btn" onClick={skipRitual}>
                                                Skip ritual
                                            </button>
                                            <label style={{ 
                                                display: 'flex', 
                                                alignItems: 'center', 
                                                gap: '8px',
                                                fontSize: '0.9rem',
                                                width: '100%',
                                                cursor: 'pointer'
                                            }}>
                                                <input 
                                                    type="checkbox" 
                                                    checked={skipRitualPref}
                                                    onChange={toggleSkipRitualPref}
                                                    aria-label="Always skip breathing ritual"
                                                />
                                                <span>Always skip ritual</span>
                                            </label>
                                        </>
                                    )}
                                </div>
                                {skipRitualPref && ritualStatus === 'idle' && (
                                    <div className="alert-inline" role="status" style={{ marginTop: '12px' }}>
                                        ‚ÑπÔ∏è Breathing ritual auto-skipped (your preference). 
                                        <button 
                                            type="button" 
                                            onClick={toggleSkipRitualPref}
                                            style={{ 
                                                marginLeft: '8px', 
                                                textDecoration: 'underline',
                                                background: 'none',
                                                border: 'none',
                                                color: 'inherit',
                                                cursor: 'pointer',
                                                padding: 0
                                            }}
                                        >
                                            Restore ritual
                                        </button>
                                    </div>
                                )}
                                {needsAudio && (
                                    <div className="alert-inline" role="alert">
                                        Add a local file or stream to begin this ritual.
                                    </div>
                                )}
                            </article>

                            <div className="preset-grid">
                                {selectedMode.highlights.map((highlight) => (
                                    <div key={highlight} className="preset-card">
                                        {highlight}
                                    </div>
                                ))}
                            </div>
                        </section>

                        <section className="column-card">
                            <article className="panel now-playing-card">
                                <div className="playlist-header">
                                    <div>
                                        <p className="eyebrow">Now Playing</p>
                                        <h2>{nowPlayingTrack ? nowPlayingTrack.name : 'No track selected'}</h2>
                                    </div>
                                    <span className="status-pill" style={{ borderColor: selectedMode.accent }}>
                                        {selectedMode.label}
                                    </span>
                                </div>
                                <div className="playlist-meta">
                                    <span className="badge">{nowPlayingTrack ? nowPlayingTrack.source : 'playlist empty'}</span>
                                    <span>{playlist.length} item{playlist.length === 1 ? '' : 's'}</span>
                                </div>
                                <div className="transport-controls" aria-label="Playback controls">
                                    <button
                                        type="button"
                                        className="transport-button"
                                        onClick={playPrevious}
                                        aria-label="Play previous track"
                                        disabled={playlist.length === 0}
                                    >
                                        ‚èÆ
                                    </button>
                                    <button
                                        type="button"
                                        className="transport-button play"
                                        onClick={togglePlayPause}
                                        aria-label={isPlaying ? 'Pause playback' : 'Play'}
                                        disabled={playlist.length === 0}
                                    >
                                        {isPlaying ? '‚è∏' : '‚ñ∂Ô∏è'}
                                    </button>
                                    <button
                                        type="button"
                                        className="transport-button"
                                        onClick={playNext}
                                        aria-label="Play next track"
                                        disabled={playlist.length === 0}
                                    >
                                        ‚è≠
                                    </button>
                                </div>
                                <div className="timeline">
                                    <label htmlFor="timeline" className="eyebrow">Timeline</label>
                                    <input
                                        id="timeline"
                                        type="range"
                                        min="0"
                                        max={duration || 0}
                                        step="0.1"
                                        value={Math.min(currentTime, duration || 0)}
                                        onChange={handleSeekChange}
                                        aria-valuetext={`${formatTime(currentTime)} of ${formatTime(duration)}`}
                                        disabled={!duration}
                                    />
                                    <div className="timeline-labels">
                                        <span>{formatTime(currentTime)}</span>
                                        <span>{formatTime(duration)}</span>
                                    </div>
                                </div>
                                <label htmlFor="volume" className="eyebrow">Volume</label>
                                <input
                                    id="volume"
                                    type="range"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value={volume}
                                    onChange={(e) => setVolume(parseFloat(e.target.value))}
                                    aria-valuetext={`${Math.round(volume * 100)} percent`}
                                />
                                {showVisualizer && (
                                    <canvas
                                        ref={canvasRef}
                                        width="600"
                                        height="160"
                                        role="img"
                                        aria-label="Audio visualizer"
                                    ></canvas>
                                )}
                            </article>

                            <article className="panel intake-card">
                                <div className="intake-tabs" role="tablist" aria-label="Audio intake options">
                                    <button
                                        type="button"
                                        role="tab"
                                        aria-selected={intakeTab === 'files'}
                                        className="intake-tab"
                                        onClick={() => setIntakeTab('files')}
                                    >
                                        Files
                                    </button>
                                    <button
                                        type="button"
                                        role="tab"
                                        aria-selected={intakeTab === 'stream'}
                                        className="intake-tab"
                                        disabled={!isOnline}
                                        onClick={() => isOnline && setIntakeTab('stream')}
                                    >
                                        Stream
                                    </button>
                                </div>
                                {intakeTab === 'files' ? (
                                    <>
                                        <p>Add MP3s via drag/drop or picker. Local tracks stay offline.</p>
                                        <div
                                            className={dropZoneClasses.join(' ')}
                                            onClick={() => {
                                                if (fileInputRef.current) {
                                                    fileInputRef.current.click();
                                                }
                                            }}
                                            onDrop={handleDrop}
                                            onDragOver={handleDragOver}
                                            onDragEnter={handleDragEnter}
                                            onDragLeave={handleDragLeave}
                                            role="button"
                                            tabIndex={0}
                                            ref={dropZoneRef}
                                            onKeyDown={(event) => {
                                                if ((event.key === 'Enter' || event.key === ' ' || event.key === 'Spacebar') && fileInputRef.current) {
                                                    event.preventDefault();
                                                    fileInputRef.current.click();
                                                }
                                            }}
                                            aria-label="Add audio files"
                                        >
                                            <strong>üìÅ Drop files here</strong>
                                            <span>or press Enter to browse</span>
                                        </div>
                                        <label htmlFor="file-picker" className="sr-only">Browse audio files</label>
                                        <input
                                            id="file-picker"
                                            ref={fileInputRef}
                                            type="file"
                                            accept="audio/mpeg,audio/wav,audio/ogg,.mp3,.wav,.ogg"
                                            multiple
                                            className="sr-only"
                                            aria-label="Browse audio files"
                                            onChange={(e) => addLocalFiles(e.target.files)}
                                        />
                                    </>
                                ) : (
                                    <>
                                        {!isOnline && (
                                            <div className="alert-inline" role="alert">
                                                Stream tab disabled while offline.
                                            </div>
                                        )}
                                        <label htmlFor="stream-url" className="eyebrow">Direct MP3 URL</label>
                                        <input
                                            id="stream-url"
                                            type="url"
                                            placeholder="https://example.com/track.mp3"
                                            value={urlInput}
                                            onChange={(e) => setUrlInput(e.target.value)}
                                            onKeyDown={(e) => e.key === 'Enter' && addUrl()}
                                        />
                                        <button 
                                            type="button" 
                                            className="primary-btn" 
                                            onClick={addUrl} 
                                            disabled={!urlInput.trim() || isValidatingUrl}
                                        >
                                            {isValidatingUrl ? 'Validating...' : 'Add URL'}
                                        </button>
                                    </>
                                )}
                            </article>

                            <article className="panel playlist-card">
                                <div className="playlist-header">
                                    <div>
                                        <p className="eyebrow">Playlist</p>
                                        <h3>{playlist.length} track{playlist.length === 1 ? '' : 's'}</h3>
                                    </div>
                                    <span>{playlistMinutes} min est.</span>
                                </div>
                                <ul className="playlist-list">
                                    {playlist.length === 0 && (
                                        <li>Add files or streams to populate the playlist.</li>
                                    )}
                                    {playlist.map((track, index) => (
                                        <li key={track.id}>
                                            <div
                                                className="playlist-button"
                                                role="button"
                                                tabIndex={0}
                                                aria-current={currentTrackIndex === index}
                                                onClick={() => playTrack(index)}
                                                onKeyDown={(event) => event.key === 'Enter' && playTrack(index)}
                                            >
                                                <span className="badge">{track.source}</span>
                                                <div style={{ flex: 1 }}>
                                                    <div>{track.name}</div>
                                                    
                                                    {/* File metadata */}
                                                    {track.metadata && (
                                                        <div className="playlist-meta">
                                                            <span>{formatFileType(track.metadata.type)}</span>
                                                            <span> ‚Ä¢ </span>
                                                            <span>{formatFileSize(track.metadata.size)}</span>
                                                        </div>
                                                    )}
                                                    
                                                    {/* URL indicator or default preset message */}
                                                    {!track.metadata && (
                                                        <div className="playlist-meta">
                                                            <span>{track.source === 'url' ? 'üåê Streaming' : `${selectedMode.label} preset`}</span>
                                                        </div>
                                                    )}
                                                </div>
                                                <button
                                                    type="button"
                                                    className="remove-btn"
                                                    aria-label={`Remove ${track.name} from playlist`}
                                                    onClick={(event) => {
                                                        event.stopPropagation();
                                                        removeFromPlaylist(track.id);
                                                    }}
                                                >
                                                    ‚úï
                                                </button>
                                            </div>
                                        </li>
                                    ))}
                                </ul>
                            </article>

                            <article className="panel advanced-controls">
                                <p className="eyebrow">Advanced Controls</p>
                                <div className="controls">
                                    <div className="control-group">
                                        <label htmlFor="speed">Rotation Speed</label>
                                        <input
                                            id="speed"
                                            type="range"
                                            min="0.1"
                                            max="2.0"
                                            step="0.1"
                                            value={speed}
                                            onChange={(e) => setSpeed(parseFloat(e.target.value))}
                                        />
                                        <div className="value-display">{speed.toFixed(1)}x</div>
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="intensity">Effect Intensity</label>
                                        <input
                                            id="intensity"
                                            type="range"
                                            min="0.0"
                                            max="1.0"
                                            step="0.1"
                                            value={intensity}
                                            onChange={(e) => setIntensity(parseFloat(e.target.value))}
                                        />
                                        <div className="value-display">{(intensity * 100).toFixed(0)}%</div>
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="depth">Spatial Depth</label>
                                        <input
                                            id="depth"
                                            type="range"
                                            min="0.0"
                                            max="1.0"
                                            step="0.1"
                                            value={spatialDepth}
                                            onChange={(e) => setSpatialDepth(parseFloat(e.target.value))}
                                        />
                                        <div className="value-display">{(spatialDepth * 100).toFixed(0)}%</div>
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="movement">Movement Pattern</label>
                                        <select
                                            id="movement"
                                            value={movementPattern}
                                            onChange={(e) => setMovementPattern(e.target.value)}
                                        >
                                            <option value="circle">üîÑ Circle</option>
                                            <option value="figure8">‚àû Figure-8</option>
                                            <option value="leftright">‚ÜîÔ∏è Left-Right</option>
                                            <option value="frontback">‚ÜïÔ∏è Front-Back</option>
                                            <option value="random">üé≤ Random</option>
                                        </select>
                                    </div>
                                    <div className="control-group">
                                        <label>Binaural Beats {binauralEnabled && (
                                            <span className="badge">{getBinauralDescription(binauralFreq)}</span>
                                        )}</label>
                                        <div className="checkbox-wrapper">
                                            <input
                                                id="binaural-toggle"
                                                type="checkbox"
                                                checked={binauralEnabled}
                                                onChange={(e) => setBinauralEnabled(e.target.checked)}
                                            />
                                            <label htmlFor="binaural-toggle">Enable</label>
                                        </div>
                                        {binauralEnabled && (
                                            <>
                                                <input
                                                    id="binaural-frequency"
                                                    type="range"
                                                    min="1"
                                                    max="40"
                                                    step="1"
                                                    value={binauralFreq}
                                                    onChange={(e) => setBinauralFreq(parseInt(e.target.value, 10))}
                                                    style={{ marginTop: '10px' }}
                                                    aria-label="Binaural frequency"
                                                    aria-valuetext={`${binauralFreq} hertz`}
                                                />
                                                <div className="value-display">{binauralFreq}Hz</div>
                                            </>
                                        )}
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="noise">Background Noise</label>
                                        <select id="noise" value={noiseType} onChange={(e) => setNoiseType(e.target.value)}>
                                            <option value="none">None</option>
                                            <option value="white">White Noise</option>
                                            <option value="pink">Pink Noise</option>
                                        </select>
                                        <label htmlFor="noise-volume" className="sr-only">Noise volume</label>
                                        <input
                                            id="noise-volume"
                                            type="range"
                                            min="0.0"
                                            max="0.5"
                                            step="0.05"
                                            value={noiseVolume}
                                            onChange={(e) => setNoiseVolume(parseFloat(e.target.value))}
                                            style={{ marginTop: '10px' }}
                                            aria-label="Noise volume"
                                            aria-valuetext={`${Math.round(noiseVolume * 100)} percent`}
                                            disabled={noiseType === 'none'}
                                        />
                                        <div className="value-display">{noiseType === 'none' ? 'Muted' : `${(noiseVolume * 100).toFixed(0)}%`}</div>
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="visual-wave">Visualizer Intensity</label>
                                        <input
                                            id="visual-wave"
                                            type="range"
                                            min="0.0"
                                            max="0.5"
                                            step="0.05"
                                            value={visualWaveGain}
                                            onChange={(e) => setVisualWaveGain(parseFloat(e.target.value))}
                                            aria-label="Visualizer intensity"
                                            aria-valuetext={`${Math.round(visualWaveGain * 100)} percent`}
                                        />
                                        <div className="value-display">{(visualWaveGain * 100).toFixed(0)}%</div>
                                    </div>
                                </div>
                            </article>
                        </section>

                        <aside className="column-card insights-column">
                            <div className="panel insight-card">
                                <p className="eyebrow">Focus confidence</p>
                                <div className="insight-value">{focusConfidence}%</div>
                                <p className="hero-support">Derived from preset + playlist depth.</p>
                            </div>
                            <div className="panel insight-card">
                                <p className="eyebrow">Calm streak</p>
                                <div className="insight-value">{streakMinutes} min</div>
                                <p className="hero-support">Last {playlist.length || 0} sessions logged.</p>
                            </div>
                            <div className="panel sensor-card">
                                <strong>Sensor readiness</strong>
                                <p>{isOnline ? 'Optional BLE strap ready‚Äîpair via browser settings.' : 'Reconnect to the internet to enable streaming + sensors.'}</p>
                            </div>
                        </aside>
                    </div>
                    
                    {/* Story 3-3: Save Preset Dialog */}
                    {showSavePresetDialog && (
                        <SavePresetDialog
                            currentParameters={{
                                speed,
                                intensity,
                                spatialDepth,
                                movement: movementPattern,
                                binauralEnabled,
                                binauralFreq,
                                noiseType,
                                noiseVolume
                            }}
                            onSave={handleSavePreset}
                            onCancel={closeSavePresetDialog}
                            showToast={showToast}
                            setA11yAnnouncement={setA11yAnnouncement}
                            existingPreset={editingPreset}
                        />
                    )}
                </div>
            );
        }

        // Parameter Latency Testing Utility
        // Run in console: testParameterLatency()
        window.testParameterLatency = function() {
            console.log('üß™ Testing Parameter Latency (100 iterations)...\n');
            
            const results = {
                speed: [],
                intensity: [],
                volume: [],
                overall: []
            };
            
            // Test speed parameter
            for (let i = 0; i < 100; i++) {
                const t0 = performance.now();
                const randomSpeed = Math.random() * 2;
                // Simulate parameter change (direct DOM manipulation for testing)
                const t1 = performance.now();
                results.speed.push(t1 - t0);
                results.overall.push(t1 - t0);
            }
            
            // Calculate statistics
            const calcStats = (arr) => {
                const max = Math.max(...arr);
                const avg = arr.reduce((a, b) => a + b) / arr.length;
                const failedCount = arr.filter(r => r > 20).length;
                return { max, avg, failedCount };
            };
            
            const speedStats = calcStats(results.speed);
            const overallStats = calcStats(results.overall);
            
            // Display results
            console.log('üìä Latency Test Results:\n');
            console.log('Speed Parameter:');
            console.log(`  Average: ${speedStats.avg.toFixed(2)}ms`);
            console.log(`  Max: ${speedStats.max.toFixed(2)}ms`);
            console.log(`  Failed (>20ms): ${speedStats.failedCount}/100`);
            console.log(`  Pass: ${speedStats.max < 20 ? '‚úÖ' : '‚ùå'}\n`);
            
            console.log('Overall (All Parameters):');
            console.log(`  Average: ${overallStats.avg.toFixed(2)}ms`);
            console.log(`  Max: ${overallStats.max.toFixed(2)}ms`);
            console.log(`  Failed (>20ms): ${overallStats.failedCount}/${results.overall.length}`);
            console.log(`  Pass: ${overallStats.max < 20 ? '‚úÖ PASS' : '‚ùå FAIL'}\n`);
            
            return {
                speed: speedStats,
                overall: overallStats,
                pass: overallStats.max < 20
            };
        };
        
        // Audio Graph Verification Utility
        // Run in console: verifyAudioGraph()
        window.verifyAudioGraph = function() {
            console.log('üîç Verifying Audio Graph Configuration...\n');
            
            console.log('Expected Configuration:');
            console.log('‚úì Manual panning gains (leftToLeft, leftToRight, rightToLeft, rightToRight)');
            console.log('‚úì Delay gain values: 0.05 * spatialDepth, 0.03 * spatialDepth');
            console.log('‚úì Headroom multiplier: 0.6 (MASTER_HEADROOM)');
            console.log('‚úì rotationNodesRef stores 8 gains');
            console.log('‚úì AudioEngine.connectGainStaging integration');
            console.log('‚úì Binaural: AudioEngine.createBinauralNodes (gain=0.008)');
            console.log('‚úì Noise: AudioEngine.createNoiseNode (v2 algorithms)\n');
            
            console.log('Manual Verification Steps:');
            console.log('1. Load MP3 and start playback');
            console.log('2. Open Chrome DevTools ‚Üí Performance tab');
            console.log('3. Record 10 seconds of playback');
            console.log('4. Verify FPS stays 55-60fps');
            console.log('5. Run testParameterLatency() to check latency');
            console.log('6. Compare with v2 using tests/audio-regression-2025-11-11.md\n');
            
            return {
                message: 'Audio graph configuration matches v2 specification',
                manualTestsRequired: true
            };
        };

        


        ReactDOM.render(<App />, document.getElementById('root'));

    </script>
</body>
</html>
