<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8D Audio Player - Live Streaming Edition</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="./audio-engine.js"></script>
    <script src="./session-logging.js"></script>
    <style>
        :root {
            --bg-1: #f4f6ff;
            --bg-2: #dfe7ff;
            --card-bg: rgba(255, 255, 255, 0.95);
            --card-border: rgba(15, 27, 68, 0.08);
            --surface: rgba(255, 255, 255, 0.7);
            --text-primary: #0c1440;
            --text-secondary: rgba(12, 20, 64, 0.7);
            --shadow-soft: 0 30px 60px rgba(15, 21, 56, 0.2);
            --accent-focus: #6d8bff;
            --accent-calm: #4edbc6;
            --accent-energize: #ffb562;
            --accent-default: #6d8bff;
            --chip-accent: var(--accent-default);
            --danger: #f05d7b;
            --positive: #3ad8a7;
            --grid-gap: 24px;
        }

        body.dark-mode {
            --bg-1: #05071c;
            --bg-2: #0c122d;
            --card-bg: rgba(7, 10, 30, 0.95);
            --card-border: rgba(255, 255, 255, 0.08);
            --surface: rgba(255, 255, 255, 0.04);
            --text-primary: #f5f7ff;
            --text-secondary: rgba(245, 247, 255, 0.7);
            --shadow-soft: 0 40px 90px rgba(0, 0, 0, 0.65);
        }

        /* High-contrast mode: WCAG AA compliant (≥4.5:1 normal text, ≥3:1 large text) */
        body.high-contrast {
            --bg-1: #ffffff;
            --bg-2: #f0f0f0;
            --card-bg: #ffffff;
            --card-border: #000000;
            --surface: #ffffff;
            --text-primary: #000000;
            --text-secondary: #000000;
            --shadow-soft: 0 2px 8px rgba(0, 0, 0, 0.3);
            --accent-focus: #0000ee;
            --accent-calm: #006060;
            --accent-energize: #cc5500;
            --accent-default: #0000ee;
            --danger: #cc0000;
            --positive: #008800;
        }

        /* High-contrast dark mode combination */
        body.dark-mode.high-contrast {
            --bg-1: #000000;
            --bg-2: #1a1a1a;
            --card-bg: #000000;
            --card-border: #ffffff;
            --surface: #000000;
            --text-primary: #ffffff;
            --text-secondary: #ffffff;
            --shadow-soft: 0 2px 8px rgba(255, 255, 255, 0.3);
            --accent-focus: #6699ff;
            --accent-calm: #00ffff;
            --accent-energize: #ffaa00;
            --accent-default: #6699ff;
            --danger: #ff6666;
            --positive: #00ff00;
        }

        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
            min-height: 100vh;
            background-image:
                radial-gradient(circle at 20% 20%, rgba(109, 139, 255, 0.25), transparent 45%),
                radial-gradient(circle at 80% 0%, rgba(255, 175, 123, 0.22), transparent 40%),
                linear-gradient(135deg, var(--bg-1), var(--bg-2));
            color: var(--text-primary);
            transition: background 0.35s ease, color 0.35s ease;
        }

        button, input, select, textarea {
            font: inherit;
        }

        .screen {
            max-width: 1440px;
            margin: 0 auto;
            padding: 32px clamp(16px, 4vw, 64px) 64px;
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .app-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 16px;
        }

        .app-header h1 {
            font-size: clamp(1.85rem, 3vw, 2.8rem);
            margin: 6px 0 8px;
        }

        .eyebrow {
            text-transform: uppercase;
            letter-spacing: 0.2em;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .header-actions {
            display: flex;
            gap: 12px;
        }

        .header-actions button {
            min-height: 48px;
            border-radius: 999px;
            padding: 0 20px;
            border: 1px solid var(--card-border);
            background: var(--surface);
            color: var(--text-primary);
            cursor: pointer;
            transition: transform 0.2s ease, border 0.2s ease;
        }

        .header-actions button:focus-visible {
            outline: 3px solid rgba(109, 139, 255, 0.7);
            outline-offset: 2px;
        }

        .primary-btn {
            background: linear-gradient(120deg, var(--accent-focus), #9f9bff);
            color: #fff;
            border: none;
            box-shadow: 0 20px 40px rgba(109, 139, 255, 0.35);
        }

        .ghost-btn {
            background: transparent;
            border: 1px dashed var(--card-border);
            color: var(--text-primary);
        }

        /* Design spec §3: Three-column grid layout for desktop ≥1280px (Ritual/Preset | Playback | Insights) */
        .main-grid {
            display: grid;
            grid-template-columns: minmax(280px, 360px) minmax(420px, 1fr) minmax(260px, 320px);
            gap: var(--grid-gap);
        }

        .column-card {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .panel {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 24px;
            padding: 24px;
            box-shadow: var(--shadow-soft);
        }

        /* Design spec §3: Mode tabs (Focus/Calm/Energize) with roving tabindex */
        .mode-tabs {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .mode-chip {
            flex: 1 1 140px;
            min-height: 56px;
            border-radius: 18px;
            border: 1px solid var(--card-border);
            padding: 12px 16px;
            background: var(--surface);
            color: var(--text-primary);
            cursor: pointer;
            text-align: left;
            transition: transform 0.2s ease, border 0.2s ease, box-shadow 0.2s ease;
        }

        .mode-chip[data-selected="true"] {
            border-color: var(--chip-accent);
            box-shadow: 0 10px 30px rgba(109, 139, 255, 0.25);
            background: linear-gradient(135deg, var(--chip-accent), rgba(255,255,255,0.1));
            color: #fff;
        }

        .mode-chip span {
            display: block;
            font-size: 1rem;
            font-weight: 600;
        }

        .mode-chip small {
            font-size: 0.78rem;
            opacity: 0.85;
        }

        /* Story 3-2: Advanced Controls Drawer */
        .advanced-controls {
            background: var(--surface-1);
            border: 2px solid var(--border-subtle);
            border-radius: 12px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .advanced-controls summary {
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            list-style: none;
            user-select: none;
        }

        .advanced-controls summary::-webkit-details-marker {
            display: none;
        }

        .advanced-controls summary::after {
            content: '▼';
            transition: transform 0.2s ease;
            font-size: 0.85rem;
            opacity: 0.6;
        }

        .advanced-controls[open] summary::after {
            transform: rotate(180deg);
        }

        .advanced-controls summary:hover {
            background: var(--surface-2);
            border-radius: 8px;
        }

        .advanced-controls kbd {
            font-size: 0.75rem;
            background: var(--surface-2);
            padding: 0.125rem 0.375rem;
            border-radius: 4px;
            border: 1px solid var(--border-subtle);
            font-family: monospace;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
            margin-top: 1rem;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .checkbox-group {
            flex-direction: row;
            align-items: center;
            gap: 0.5rem;
        }

        .checkbox-group input[type="checkbox"] {
            width: 24px;
            height: 24px;
            cursor: pointer;
        }

        .control-label {
            font-weight: 500;
            color: var(--text-1);
            font-size: 0.95rem;
        }

        .control-input {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .control-input input[type="range"] {
            flex: 1;
            height: 8px;
            border-radius: 4px;
            appearance: none;
            background: var(--surface-3);
            outline: none;
        }

        .control-input input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-focus);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.1s ease;
        }

        .control-input input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .control-input input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-focus);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.1s ease;
        }

        .control-input input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.1);
        }

        .control-input input[type="range"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .control-input input[type="range"]:disabled::-webkit-slider-thumb {
            cursor: not-allowed;
        }

        .control-input input[type="range"]:disabled::-moz-range-thumb {
            cursor: not-allowed;
        }

        .control-input select {
            flex: 1;
            padding: 0.5rem;
            border-radius: 6px;
            background: var(--surface-2);
            border: 2px solid var(--border-subtle);
            color: var(--text-1);
            font-size: 0.9rem;
            cursor: pointer;
        }

        .control-input select:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .control-input output {
            font-variant-numeric: tabular-nums;
            min-width: 3.5rem;
            text-align: right;
            font-weight: 600;
            color: var(--text-2);
            font-size: 0.9rem;
        }

        .freq-band {
            font-size: 0.8rem;
            color: var(--text-3);
            font-weight: 400;
            margin-left: 0.25rem;
        }

        .control-hint {
            font-size: 0.85rem;
            color: var(--text-3);
            font-style: italic;
            line-height: 1.3;
        }

        .sensor-lock-notice {
            background: var(--warning-bg, #fff3cd);
            border: 2px solid var(--warning-border, #ffc107);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .lock-icon {
            font-size: 1.5rem;
        }

        .lock-message {
            flex: 1;
            font-weight: 500;
            color: var(--warning-text, #664d03);
        }

        .unlock-btn {
            padding: 0.5rem 1rem;
            border-radius: 6px;
            background: var(--surface-1);
            border: 2px solid var(--border);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-1);
        }

        .unlock-btn:hover {
            background: var(--accent-focus);
            color: white;
            border-color: var(--accent-focus);
            transform: translateY(-1px);
        }

        .unlock-btn:active {
            transform: translateY(0);
        }

        .hero-card {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .hero-card h2 {
            margin: 0;
            font-size: 1.6rem;
        }

        .hero-message {
            min-height: 48px;
            border-radius: 16px;
            padding: 12px 16px;
            background: var(--surface);
            color: var(--text-primary);
            display: flex;
            align-items: center;
        }

        .hero-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        .hero-actions button {
            flex: 1;
            min-width: 140px;
            min-height: 54px;
        }

        .hero-countdown {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .hero-animation {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            border: 3px solid rgba(109, 139, 255, 0.3);
            position: relative;
        }

        .hero-animation::after {
            content: '';
            position: absolute;
            inset: 8px;
            border-radius: 50%;
            border: 3px solid rgba(109, 139, 255, 0.8);
            animation: breathe424 6s ease-in-out infinite;
        }

        /* 4-2-4 breathing animation: 2s inhale, 1s hold, 2s exhale, 1s hold = 6s cycle */
        @keyframes breathe424 {
            0% {
                transform: scale(0.85);
                opacity: 0.6;
            }
            /* Inhale: 0-33.33% (2s of 6s) */
            33.33% {
                transform: scale(1.15);
                opacity: 1;
            }
            /* Hold inhale: 33.33-50% (1s of 6s) */
            50% {
                transform: scale(1.15);
                opacity: 1;
            }
            /* Exhale: 50-83.33% (2s of 6s) */
            83.33% {
                transform: scale(0.85);
                opacity: 0.6;
            }
            /* Hold exhale: 83.33-100% (1s of 6s) */
            100% {
                transform: scale(0.85);
                opacity: 0.6;
            }
        }

        .hero-countdown__value {
            font-size: 2rem;
            font-weight: 600;
        }

        .preset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
        }

        .preset-card {
            border-radius: 16px;
            border: 1px solid var(--card-border);
            padding: 14px;
            background: var(--surface);
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .hero-support {
            color: var(--text-secondary);
            margin: 0;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 16px;
        }

        .value-display {
            text-align: right;
            font-weight: 600;
            color: var(--accent-focus);
            margin-top: 8px;
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .now-playing-card canvas {
            width: 100%;
            height: 120px;
            border-radius: 16px;
            border: 1px solid var(--card-border);
            background: #050915;
        }

        .now-playing-track-info {
            display: flex;
            gap: 16px;
            align-items: center;
            margin-bottom: 16px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            border: 1px solid var(--card-border);
        }

        .album-art {
            width: 80px;
            height: 80px;
            min-width: 80px;
            border-radius: 10px;
            background: linear-gradient(135deg, rgba(109, 139, 255, 0.15), rgba(159, 155, 255, 0.1));
            border: 1px solid var(--card-border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: var(--text-secondary);
            overflow: hidden;
        }

        .album-art img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .track-details {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .track-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin: 0;
        }

        .track-artist {
            font-size: 0.9rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin: 0;
        }

        .track-source {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 0;
        }

        @media (max-width: 480px) {
            .now-playing-track-info {
                gap: 12px;
                padding: 10px;
            }
            .album-art {
                width: 64px;
                height: 64px;
                min-width: 64px;
                font-size: 1.5rem;
            }
            .track-title {
                font-size: 1rem;
            }
            .track-artist {
                font-size: 0.85rem;
            }
        }

        /* Timer Styles */
        .timer-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--card-border);
        }

        .timer-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .timer-tab {
            flex: 1;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--card-border);
            border-radius: 8px;
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .timer-tab:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .timer-tab.active {
            background: var(--accent);
            color: black;
            border-color: var(--accent);
            font-weight: 600;
        }

        .timer-display {
            text-align: center;
            padding: 16px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            margin-bottom: 12px;
        }

        .timer-time {
            font-size: 2.5rem;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
            color: var(--text-primary);
            letter-spacing: 2px;
        }

        .timer-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 4px;
        }

        .timer-presets {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 12px;
        }

        .timer-preset {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid var(--card-border);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .timer-preset:hover {
            background: rgba(255, 255, 255, 0.15);
            color: var(--text-primary);
        }

        .timer-preset.selected {
            background: var(--accent);
            color: black;
            border-color: var(--accent);
            font-weight: 600;
        }

        .timer-controls {
            display: flex;
            gap: 8px;
        }

        .timer-btn {
            flex: 1;
            padding: 10px 16px;
            border-radius: 8px;
            border: none;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .timer-btn.start {
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: black;
        }

        .timer-btn.stop {
            background: linear-gradient(135deg, #f87171, #ef4444);
            color: white;
        }

        .timer-btn.pause {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            color: black;
        }

        .timer-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pomodoro-phase {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: 8px;
            margin-bottom: 12px;
            font-weight: 600;
        }

        .pomodoro-phase.work {
            background: rgba(109, 139, 255, 0.2);
            color: var(--accent-focus);
        }

        .pomodoro-phase.break {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }

        .pomodoro-settings {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }

        .pomodoro-setting {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .pomodoro-setting label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .pomodoro-setting input {
            padding: 8px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid var(--card-border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.9rem;
            text-align: center;
        }

        .pomodoro-cycles {
            display: flex;
            gap: 6px;
            justify-content: center;
            margin-bottom: 8px;
        }

        .cycle-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transition: all 0.3s;
        }

        .cycle-dot.completed {
            background: var(--accent);
            box-shadow: 0 0 8px var(--accent);
        }

        .cycle-dot.current {
            background: #4ade80;
            box-shadow: 0 0 8px #4ade80;
            animation: pulse 1s infinite;
        }

        .break-action-select {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid var(--card-border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.85rem;
            margin-bottom: 12px;
        }

        @media (max-width: 480px) {
            .timer-time {
                font-size: 2rem;
            }
            .pomodoro-settings {
                grid-template-columns: 1fr;
            }
        }

        /* Playlist Search */
        .playlist-search {
            position: relative;
            margin-bottom: 12px;
        }

        .playlist-search-input {
            width: 100%;
            padding: 10px 12px 10px 36px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid var(--card-border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .playlist-search-input::placeholder {
            color: var(--text-muted);
        }

        .playlist-search-input:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(255, 255, 255, 0.1);
        }

        .playlist-search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted);
            font-size: 0.9rem;
            pointer-events: none;
        }

        .playlist-search-clear {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: var(--text-secondary);
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 0.7rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .playlist-search-clear:hover {
            background: rgba(255, 255, 255, 0.2);
            color: var(--text-primary);
        }

        .playlist-no-results {
            text-align: center;
            padding: 20px;
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        /* Playlist Save/Load */
        .playlist-actions {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .playlist-action-btn {
            flex: 1;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid var(--card-border);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .playlist-action-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            color: var(--text-primary);
        }

        .playlist-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .saved-playlists-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            padding: 20px;
        }

        .saved-playlists-content {
            background: var(--surface);
            border-radius: 16px;
            border: 1px solid var(--card-border);
            max-width: 400px;
            width: 100%;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .saved-playlists-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--card-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .saved-playlists-header h3 {
            margin: 0;
            font-size: 1.1rem;
        }

        .saved-playlists-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 4px;
        }

        .saved-playlists-close:hover {
            color: var(--text-primary);
        }

        .saved-playlists-body {
            padding: 16px 20px;
            overflow-y: auto;
            flex: 1;
        }

        .save-playlist-form {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }

        .save-playlist-input {
            flex: 1;
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid var(--card-border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .save-playlist-input::placeholder {
            color: var(--text-muted);
        }

        .save-playlist-btn {
            padding: 10px 16px;
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: black;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .save-playlist-btn:hover {
            transform: scale(1.02);
        }

        .save-playlist-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .saved-playlist-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            margin-bottom: 8px;
            transition: all 0.2s;
        }

        .saved-playlist-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .saved-playlist-info {
            flex: 1;
            min-width: 0;
        }

        .saved-playlist-name {
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .saved-playlist-meta {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .saved-playlist-actions {
            display: flex;
            gap: 6px;
        }

        .saved-playlist-load {
            padding: 6px 12px;
            background: var(--accent);
            color: black;
            border: none;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
        }

        .saved-playlist-delete {
            padding: 6px 10px;
            background: rgba(239, 68, 68, 0.2);
            color: #f87171;
            border: none;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
        }

        .saved-playlist-delete:hover {
            background: rgba(239, 68, 68, 0.4);
        }

        .no-saved-playlists {
            text-align: center;
            padding: 20px;
            color: var(--text-muted);
        }

        .status-pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 999px;
            font-size: 0.8rem;
            border: 1px solid var(--card-border);
        }

        .transport-controls {
            display: flex;
            gap: 12px;
            justify-content: space-between;
            align-items: center;
        }

        .transport-button {
            min-width: 64px;
            min-height: 64px;
            border-radius: 20px;
            border: none;
            background: var(--surface);
            color: var(--text-primary);
            font-size: 1.4rem;
            cursor: pointer;
        }

        .transport-button.play {
            flex: 1;
            background: linear-gradient(135deg, var(--accent-focus), #9f9bff);
            color: #fff;
            font-size: 1.6rem;
            box-shadow: 0 20px 40px rgba(109, 139, 255, 0.35);
        }

        .timeline {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .timeline input[type="range"] {
            width: 100%;
            accent-color: var(--accent-focus);
        }

        .timeline-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .intake-tabs {
            display: inline-flex;
            border-radius: 999px;
            border: 1px solid var(--card-border);
            overflow: hidden;
        }

        .intake-tab {
            border: none;
            background: transparent;
            padding: 12px 20px;
            min-height: 48px;
            cursor: pointer;
            color: var(--text-primary);
        }

        .intake-tab[aria-selected="true"] {
            background: linear-gradient(135deg, rgba(109, 139, 255, 0.18), rgba(109, 139, 255, 0));
            color: var(--text-primary);
        }

        .drop-zone {
            margin-top: 16px;
            border: 2px dashed rgba(109, 139, 255, 0.45);
            border-radius: 20px;
            padding: 28px 20px;
            text-align: center;
            background: var(--surface);
            min-height: 160px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            justify-content: center;
            cursor: pointer;
            transition: border 0.2s ease, box-shadow 0.2s ease;
        }

        .drop-zone--attention {
            border-color: var(--danger);
            box-shadow: 0 0 0 3px rgba(240, 93, 123, 0.2);
        }

        .drop-zone--hover {
            border-color: var(--accent-focus);
            box-shadow: 0 0 0 3px rgba(109, 139, 255, 0.25);
        }

        .playlist-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .playlist-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .playlist-button {
            width: 100%;
            border-radius: 18px;
            border: 1px solid var(--card-border);
            padding: 14px 18px;
            background: var(--surface);
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            gap: 12px;
            text-align: left;
            cursor: pointer;
            min-height: 64px;
        }

        .playlist-button[aria-current="true"] {
            border-color: var(--accent-focus);
            box-shadow: 0 0 0 2px rgba(109, 139, 255, 0.25);
        }

        .playlist-meta {
            display: flex;
            gap: 8px;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .badge {
            border-radius: 999px;
            padding: 3px 10px;
            font-size: 0.75rem;
            border: 1px solid var(--card-border);
        }

        .remove-btn {
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 1.2rem;
            min-width: 48px;
            min-height: 48px;
            border-radius: 12px;
            display: grid;
            place-items: center;
        }

        .advanced-controls .control-group {
            background: var(--surface);
            border-radius: 16px;
            padding: 18px;
        }

        .advanced-controls label {
            font-weight: 600;
            font-size: 0.95rem;
        }

        .advanced-controls input[type="range"],
        .advanced-controls select {
            width: 100%;
            margin-top: 8px;
        }

        .pill {
            border-radius: 12px;
            padding: 4px 10px;
            font-size: 0.8rem;
        }

        .insights-grid {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .insight-card,
        .sensor-card {
            border-radius: 20px;
            border: 1px solid var(--card-border);
            background: var(--card-bg);
            padding: 20px;
        }

        .insight-value {
            font-size: 2rem;
            font-weight: 600;
        }

        .sensor-card strong {
            display: block;
            margin-bottom: 8px;
        }

        .session-log-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 12px;
        }

        .session-log-actions button {
            border-radius: 999px;
            border: 1px solid var(--card-border);
            background: var(--surface);
            padding: 10px 16px;
            font-weight: 600;
            color: var(--text-primary);
            cursor: pointer;
            transition: opacity 0.2s ease;
        }

        .session-log-actions button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .alert-inline {
            border-radius: 16px;
            padding: 12px 16px;
            background: rgba(240, 93, 123, 0.12);
            color: var(--danger);
            border: 1px solid rgba(240, 93, 123, 0.35);
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        button:focus-visible,
        .mode-chip:focus-visible,
        .intake-tab:focus-visible,
        .playlist-button:focus-visible {
            outline: 3px solid rgba(109, 139, 255, 0.7);
            outline-offset: 2px;
        }

        /* Design spec §3: Responsive grid breakpoints */
        /* Three-column layout ≥1280px (default above) */
        /* Two-column layout 768-1279px */
        @media (min-width: 768px) and (max-width: 1279px) {
            .main-grid {
                grid-template-columns: repeat(2, minmax(280px, 1fr));
            }
            .insights-column {
                grid-column: 1 / -1;
            }
        }

        /* Single-column layout ≤767px (mobile) */
        @media (max-width: 767px) {
            .app-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .main-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .hero-actions button {
                flex: 1 1 100%;
            }

            .mode-tabs {
                position: sticky;
                top: 0;
                padding: 12px 0;
                background: linear-gradient(180deg, var(--bg-1), rgba(255, 255, 255, 0));
                z-index: 5;
            }

            /* Story 3-2: Mobile responsive */
            .controls-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .advanced-controls summary {
                font-size: 1rem;
            }

            .control-input {
                flex-direction: column;
                align-items: stretch;
            }

            .control-input output {
                text-align: left;
            }

            .sensor-lock-notice {
                flex-direction: column;
                text-align: center;
            }

            .unlock-btn {
                width: 100%;
            }
        }

        @keyframes breathe {
            0% { transform: scale(0.8); opacity: 0.6; }
            50% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0.6; }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.9; }
            50% { transform: scale(1.1); opacity: 1; }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideUpButtons {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideDownButtons {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .toast {
            pointer-events: none;
        }

        /* Story 3-3: Dialog Overlay Styles */
        .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.2s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .dialog-content {
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Mobile Bottom Navigation */
        .mobile-bottom-nav {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 70px;
            background: var(--card-bg);
            border-top: 1px solid var(--card-border);
            z-index: 9999;
            padding-bottom: env(safe-area-inset-bottom, 0);
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.15);
        }

        .mobile-nav-items {
            display: flex;
            height: 100%;
            justify-content: space-around;
            align-items: center;
            padding: 0 8px;
        }

        .mobile-nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 8px 16px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 12px;
            transition: all 0.2s ease;
            min-width: 70px;
        }

        .mobile-nav-item.active {
            color: var(--accent-focus);
            background: rgba(109, 139, 255, 0.1);
        }

        .mobile-nav-item:active {
            transform: scale(0.95);
        }

        .mobile-nav-icon {
            font-size: 1.5rem;
            line-height: 1;
        }

        .mobile-nav-label {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .mobile-nav-badge {
            position: absolute;
            top: 2px;
            right: 8px;
            background: var(--danger);
            color: white;
            font-size: 0.6rem;
            padding: 2px 5px;
            border-radius: 8px;
            font-weight: 700;
        }

        /* Mobile view containers */
        .mobile-view {
            display: none;
        }

        .mobile-view.active {
            display: block;
        }

        /* Mobile-only visibility classes */
        @media (max-width: 767px) {
            .mobile-bottom-nav {
                display: block;
            }

            .screen {
                padding-bottom: calc(90px + env(safe-area-inset-bottom, 0));
            }

            /* Hide desktop grid on mobile */
            .main-grid {
                display: none;
            }

            /* Show mobile views */
            .mobile-views-container {
                display: block;
            }

            /* Mobile header adjustments */
            .app-header {
                padding: 8px 0;
            }

            .app-header h1 {
                font-size: 1.4rem;
            }

            .header-actions {
                flex-wrap: wrap;
            }

            .header-actions button {
                padding: 0 12px;
                min-height: 40px;
                font-size: 0.85rem;
            }

            /* Mobile view panel styling */
            .mobile-view .panel {
                margin-bottom: 16px;
            }

            /* Compact mode tabs for mobile */
            .mobile-view .mode-tabs {
                position: static;
                background: transparent;
            }

            .mobile-view .mode-chip {
                flex: 1;
                min-height: 48px;
                padding: 8px 12px;
            }

            /* Compact transport for mobile */
            .mobile-view .transport-controls {
                padding: 12px 0;
            }

            .mobile-view .transport-button {
                width: 48px;
                height: 48px;
            }

            .mobile-view .transport-button.play {
                width: 60px;
                height: 60px;
            }

            /* Compact playlist for mobile */
            .mobile-view .playlist-track {
                padding: 10px 12px;
            }

            /* Compact timers for mobile */
            .mobile-view .timer-section {
                padding: 12px;
            }

            .mobile-view .timer-time {
                font-size: 2rem;
            }

            /* Mobile player fixed at top - always visible */
            .mobile-player-fixed {
                margin-bottom: 16px;
            }

            .mobile-player-fixed .transport-controls {
                padding: 12px 0;
            }

            .mobile-player-fixed .transport-button {
                width: 48px;
                height: 48px;
            }

            .mobile-player-fixed .transport-button.play {
                width: 60px;
                height: 60px;
            }
        }

        /* Desktop keeps normal grid */
        @media (min-width: 768px) {
            .mobile-views-container {
                display: none;
            }

            .mobile-bottom-nav {
                display: none !important;
            }

            .mobile-player-fixed {
                display: none;
            }
        }

        /* Fullscreen Visualizer - Mobile Optimized */
        .fullscreen-visualizer-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 99999;
            background: #0a0a0a;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .fullscreen-visualizer-overlay canvas {
            width: 100% !important;
            height: 100% !important;
            object-fit: contain;
        }

        .fullscreen-viz-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100000;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .fullscreen-viz-btn {
            padding: 10px 16px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .fullscreen-viz-btn.active {
            background: var(--accent-focus);
            border-color: var(--accent-focus);
        }

        .fullscreen-viz-close {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100000;
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        /* Fullscreen track info */
        .fullscreen-track-info {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100000;
            text-align: center;
            color: white;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
            padding: 12px 24px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            max-width: 90vw;
        }

        .fullscreen-track-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .fullscreen-track-artist {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        /* Landscape orientation on mobile */
        @media (max-width: 767px) and (orientation: landscape) {
            .fullscreen-viz-controls {
                top: 10px;
                right: 10px;
                flex-direction: row;
            }

            .fullscreen-viz-btn {
                padding: 8px 12px;
                font-size: 0.8rem;
            }

            .fullscreen-viz-close {
                top: 10px;
                left: 10px;
                padding: 8px 14px;
            }

            .fullscreen-track-info {
                bottom: 15px;
                padding: 8px 16px;
            }

            .fullscreen-track-title {
                font-size: 1rem;
            }

            .fullscreen-track-artist {
                font-size: 0.8rem;
            }
        }

        /* Portrait on mobile - stack controls vertically */
        @media (max-width: 767px) and (orientation: portrait) {
            .fullscreen-viz-controls {
                top: auto;
                bottom: 100px;
                right: 10px;
                flex-direction: column;
            }

            .fullscreen-track-info {
                bottom: 20px;
            }
        }

        /* Hide mobile nav when visualizer is fullscreen */
        body.viz-fullscreen .mobile-bottom-nav {
            display: none !important;
        }

        body.viz-fullscreen {
            overflow: hidden;
        }

        /* Mobile Header Styles */
        .mobile-header {
            display: none;
        }

        .mobile-header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--card-bg);
            border-bottom: 1px solid var(--card-border);
        }

        .mobile-header-title {
            font-size: 1rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .mobile-menu-btn {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: 1px solid var(--card-border);
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2rem;
        }

        .mobile-menu-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--card-bg);
            border-bottom: 1px solid var(--card-border);
            padding: 12px;
            display: none;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        .mobile-menu-dropdown.open {
            display: flex;
        }

        .mobile-menu-dropdown button {
            padding: 12px;
            text-align: left;
            border-radius: 8px;
        }

        .calibration-bar {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--card-border);
        }

        .calibration-status {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .calibration-status.calibrated {
            color: #4ade80;
        }

        .calibration-btn {
            padding: 6px 12px;
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
            border: 1px solid #4ade80;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .calibration-btn.not-calibrated {
            background: var(--accent-focus);
            color: white;
            border-color: var(--accent-focus);
        }

        @media (max-width: 767px) {
            .mobile-header {
                display: block;
                position: sticky;
                top: 0;
                z-index: 100;
            }

            .app-header {
                display: none;
            }
        }

        @media (min-width: 768px) {
            .mobile-header {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        const MODE_LIBRARY = [
            {
                id: 'focus',
                label: 'Focus',
                short: 'Deep work',
                description: 'Steady orbit + beta beats keep intrusive thoughts at bay.',
                heroCopy: 'Steady pulses to clear the mental slate in two breaths.',
                accent: 'var(--accent-focus)',
                preset: {
                    speed: 0.55,
                    intensity: 0.85,
                    spatialDepth: 0.45,
                    movement: 'circle',
                    binaural: { enabled: true, freq: 14 },
                    noise: { type: 'pink', volume: 0.08 },
                    spatial: { itdAmount: 0.7, headShadow: 0.5, directionalDepth: 0.15, crossBleed: 0.05, panCurve: 2.0, backDepth: 0.55, hardPanThreshold: 0.1 }
                },
                highlights: ['Beta 14 Hz pulses', 'Low drift orbit', 'Pink noise cushion']
            },
            {
                id: 'calm',
                label: 'Calm',
                short: 'Breathing companion',
                description: 'Longer arcs, theta beats, and softer noise for co-regulation.',
                heroCopy: 'Elongated orbit with theta support for family wind-downs.',
                accent: 'var(--accent-calm)',
                preset: {
                    speed: 0.35,
                    intensity: 0.6,
                    spatialDepth: 0.6,
                    movement: 'figure8',
                    binaural: { enabled: true, freq: 8 },
                    noise: { type: 'white', volume: 0.05 },
                    spatial: { itdAmount: 0.5, headShadow: 0.4, directionalDepth: 0.1, crossBleed: 0.1, panCurve: 1.5, backDepth: 0.65, hardPanThreshold: 0.15 }
                },
                highlights: ['Theta 8 Hz support', 'Figure-eight drift', 'Gentle white noise']
            },
            {
                id: 'energize',
                label: 'Energize',
                short: 'Quick reset',
                description: 'Fast arcs + brighter stereo swing for playful bursts.',
                heroCopy: 'Hyper-clear panning for a quick dopamine reset.',
                accent: 'var(--accent-energize)',
                preset: {
                    speed: 0.95,
                    intensity: 0.9,
                    spatialDepth: 0.7,
                    movement: 'random',
                    binaural: { enabled: true, freq: 30 },
                    noise: { type: 'pink', volume: 0.12 },
                    spatial: { itdAmount: 1.0, headShadow: 0.7, directionalDepth: 0.25, crossBleed: 0, panCurve: 3.0, backDepth: 0.4, hardPanThreshold: 0.05 }
                },
                highlights: ['Gamma 30 Hz spark', 'Randomized orbit', 'Louder pink noise']
            },
            {
                id: 'apd-friendly',
                label: 'APD Friendly',
                short: 'Accessible 8D',
                description: 'Optimized for auditory processing differences - relies on volume and tone, not timing.',
                heroCopy: 'Enhanced spatial cues designed for brains that process differently.',
                accent: 'var(--accent-calm)',
                preset: {
                    speed: 0.45,
                    intensity: 0.8,
                    spatialDepth: 0.5,
                    movement: 'quadrant',
                    binaural: { enabled: false, freq: 0 },
                    noise: { type: 'pink', volume: 0.06 },
                    spatial: { itdAmount: 0, headShadow: 1.0, directionalDepth: 0.35, crossBleed: 0, panCurve: 4.0, backDepth: 0.35, hardPanThreshold: 0.05 }
                },
                highlights: ['No timing cues (ITD off)', 'Max muffling contrast', 'Clear L/R separation']
            }
        ];

        const HERO_BREATH_DURATION = 20;

        // Mode-specific track rating icons - reinforces the mindset
        const RATING_ICONS = {
            focus: {
                boost: { icon: '🎯', label: 'Locked In', desc: 'This locks me in' },
                neutral: { icon: '➖', label: 'Meh', desc: 'Play less often' },
                remove: { icon: '💭', label: 'Distracting', desc: 'Mind wanders' }
            },
            calm: {
                boost: { icon: '🌊', label: 'Flowing', desc: 'Brings peace' },
                neutral: { icon: '➖', label: 'Meh', desc: 'Play less often' },
                remove: { icon: '🌀', label: 'Turbulent', desc: 'Unsettling' }
            },
            energize: {
                boost: { icon: '⚡', label: 'Energizing', desc: 'Fires me up' },
                neutral: { icon: '➖', label: 'Meh', desc: 'Play less often' },
                remove: { icon: '💤', label: 'Draining', desc: 'Makes me tired' }
            },
            'apd-friendly': {
                boost: { icon: '🔮', label: 'Crystal Clear', desc: 'Easy to follow' },
                neutral: { icon: '➖', label: 'Meh', desc: 'Play less often' },
                remove: { icon: '🌫️', label: 'Muddy', desc: 'Hard to process' }
            }
        };

        // Story 3-3: Custom Preset Storage Keys
        const CUSTOM_PRESETS_KEY = 'mpe_8d_custom_presets';

        // Supported MIME types for file intake validation
        const SUPPORTED_MIME_TYPES = [
            'audio/mpeg',      // .mp3
            'audio/wav',       // .wav
            'audio/wave',      // .wav (alternate)
            'audio/ogg',       // .ogg
            'audio/x-wav'      // .wav (legacy)
        ];

        // Story 3-2: Parameter range constants
        const PARAM_RANGES = {
            speed: { min: 0, max: 1, step: 0.05 },
            intensity: { min: 0, max: 1, step: 0.05 },
            spatialDepth: { min: 0, max: 1, step: 0.05 },
            binauralFreq: { min: 0, max: 40, step: 1 },
            noiseVolume: { min: 0, max: 0.3, step: 0.01 }
        };

        // Helper: Get binaural frequency band name
        const getBinauralBand = (freq) => {
            if (freq < 4) return 'Delta';
            if (freq < 8) return 'Theta';
            if (freq < 14) return 'Alpha';
            if (freq < 30) return 'Beta';
            return 'Gamma';
        };

        // Helper: Get binaural frequency hint
        const getBinauralHint = (freq) => {
            if (freq < 4) return 'Deep sleep, healing';
            if (freq < 8) return 'Deep relaxation, meditation';
            if (freq < 14) return 'Calm focus, learning';
            if (freq < 30) return 'Active focus, problem-solving';
            return 'Peak alertness, high energy';
        };

        // ============================================================
        // Story 3-3: Custom Preset CRUD Storage Helpers
        // ============================================================
        
        const loadCustomPresets = () => {
            try {
                const saved = localStorage.getItem(CUSTOM_PRESETS_KEY);
                return saved ? JSON.parse(saved) : {};
            } catch (err) {
                console.error('[PresetStorage] Failed to load custom presets:', err);
                return {};
            }
        };

        const saveCustomPreset = (presetData, showToastFn) => {
            try {
                const customPresets = loadCustomPresets();
                const id = `custom-preset-${Date.now()}`;
                
                customPresets[id] = {
                    id,
                    name: presetData.name,
                    description: presetData.description || '',
                    createdAt: Date.now(),
                    lastUsedAt: Date.now(),
                    preset: {
                        speed: presetData.speed,
                        intensity: presetData.intensity,
                        spatialDepth: presetData.spatialDepth,
                        movement: presetData.movement,
                        binaural: { 
                            enabled: presetData.binauralEnabled, 
                            freq: presetData.binauralFreq 
                        },
                        noise: {
                            type: presetData.noiseType,
                            volume: presetData.noiseVolume
                        },
                        spatial: {
                            itdAmount: presetData.itdAmount ?? 0.7,
                            headShadow: presetData.headShadow ?? 0.5,
                            directionalDepth: presetData.directionalDepth ?? 0.15,
                            crossBleed: presetData.crossBleed ?? 0,
                            panCurve: presetData.panCurve ?? 2.0,
                            backDepth: presetData.backDepth ?? 0.55,
                            hardPanThreshold: presetData.hardPanThreshold ?? 0.1
                        }
                    },
                    color: presetData.color || '#6366f1',
                    tags: presetData.tags || []
                };
                
                localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(customPresets));
                
                // Add to preset order
                const order = getPresetOrder();
                order.push(id);
                savePresetOrder(order);
                
                console.log(`[PresetStorage] Saved custom preset: ${id} - ${presetData.name}`);
                return id;
            } catch (err) {
                if (err.name === 'QuotaExceededError') {
                    if (showToastFn) showToastFn('Storage full. Please delete old presets.', 'error');
                } else {
                    console.error('[PresetStorage] Failed to save preset:', err);
                    if (showToastFn) showToastFn('Error saving preset.', 'error');
                }
                return null;
            }
        };

        const updateCustomPreset = (id, updates, showToastFn) => {
            try {
                const customPresets = loadCustomPresets();
                if (customPresets[id]) {
                    customPresets[id] = { 
                        ...customPresets[id], 
                        ...updates,
                        lastUsedAt: Date.now()
                    };
                    localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(customPresets));
                    console.log(`[PresetStorage] Updated custom preset: ${id}`);
                    return true;
                }
                console.warn(`[PresetStorage] Preset not found: ${id}`);
                return false;
            } catch (err) {
                console.error('[PresetStorage] Failed to update preset:', err);
                if (showToastFn) showToastFn('Error updating preset.', 'error');
                return false;
            }
        };

        const deleteCustomPreset = (id, showToastFn) => {
            try {
                const customPresets = loadCustomPresets();
                const presetName = customPresets[id]?.name || id;
                
                delete customPresets[id];
                localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(customPresets));
                
                // Remove from order
                const order = getPresetOrder().filter(pid => pid !== id);
                savePresetOrder(order);
                
                console.log(`[PresetStorage] Deleted custom preset: ${id}`);
                
                // Return the deleted preset ID and name for caller to handle track updates
                return { id, name: presetName };
            } catch (err) {
                console.error('[PresetStorage] Failed to delete preset:', err);
                if (showToastFn) showToastFn('Error deleting preset.', 'error');
                return null;
            }
        };

        const getAllPresets = () => {
            const defaults = MODE_LIBRARY.map(mode => ({
                id: mode.id,
                name: mode.label,
                description: mode.description,
                preset: mode.preset,
                color: mode.accent,
                isDefault: true,
                createdAt: 0,
                lastUsedAt: 0
            }));
            
            const custom = Object.values(loadCustomPresets()).map(p => ({
                ...p,
                isDefault: false
            }));
            
            // Apply user-defined order
            const order = getPresetOrder();
            const allPresets = [...defaults, ...custom];
            const ordered = order
                .map(id => allPresets.find(p => p.id === id))
                .filter(Boolean);
            
            // Add any new presets not in order (defensive)
            const orderedIds = new Set(ordered.map(p => p.id));
            const missing = allPresets.filter(p => !orderedIds.has(p.id));
            
            return [...ordered, ...missing];
        };

        const getPresetOrder = () => {
            try {
                const saved = localStorage.getItem('mpe_8d_preset_order');
                if (saved) return JSON.parse(saved);
            } catch (err) {
                console.error('[PresetStorage] Failed to load preset order:', err);
            }
            
            // Default order: defaults first, then custom by creation date
            const defaults = MODE_LIBRARY.map(m => m.id);
            const custom = Object.keys(loadCustomPresets()).sort();
            return [...defaults, ...custom];
        };

        const savePresetOrder = (order) => {
            try {
                localStorage.setItem('mpe_8d_preset_order', JSON.stringify(order));
            } catch (err) {
                console.error('[PresetStorage] Failed to save preset order:', err);
            }
        };

        // Helper to format "last used" timestamp
        const formatLastUsed = (timestamp) => {
            if (!timestamp || timestamp === 0) return 'Never used';
            
            const now = Date.now();
            const diff = now - timestamp;
            const seconds = Math.floor(diff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            
            if (seconds < 60) return 'Just now';
            if (minutes < 60) return `${minutes} minute${minutes === 1 ? '' : 's'} ago`;
            if (hours < 24) return `${hours} hour${hours === 1 ? '' : 's'} ago`;
            if (days < 7) return `${days} day${days === 1 ? '' : 's'} ago`;
            
            const date = new Date(timestamp);
            return date.toLocaleDateString();
        };

        // Spatial Audio Tuner - Visual debugging tool for dialing in 3D audio effect
        const SpatialAudioTuner = ({
            isOpen,
            onClose,
            onApplyGains, // Function to apply gains to audio engine
            onApplyEQ, // Function to apply EQ: (bass, mid, treble, clarity) => void
            currentVolume = 0.7,
            onVolumeChange,
            // EQ props from parent
            eqBass = 0,
            eqMid = 0,
            eqTreble = 0,
            eqClarity = 0,
            onEqBassChange,
            onEqMidChange,
            onEqTrebleChange,
            onEqClarityChange,
            onCalibrationComplete // Called when calibration is saved
        }) => {
            const [orbPosition, setOrbPosition] = React.useState({ x: 0, y: -80 }); // Start at "front"
            const [isDragging, setIsDragging] = React.useState(false);
            const containerRef = React.useRef(null);
            const [activeTab, setActiveTab] = React.useState('position'); // 'position', 'spatial', 'eq', 'calibrate'
            const [expandedSections, setExpandedSections] = React.useState({ spatial: false, eq: true }); // Collapsible sections

            // Advanced tuning settings
            const [crossBleed, setCrossBleed] = React.useState(0); // 0-0.3: how much bleeds to opposite ear
            const [backDepth, setBackDepth] = React.useState(0.55); // 0.3-1.0: volume when behind
            const [panCurve, setPanCurve] = React.useState(2.0); // 1-4: how aggressively pan separates L/R
            const [hardPanThreshold, setHardPanThreshold] = React.useState(0.1); // 0-0.5: center dead zone
            const [itdAmount, setItdAmount] = React.useState(0.7); // 0-1.5: ITD multiplier (0.7ms max is realistic)
            const [directionalDepth, setDirectionalDepth] = React.useState(0.15); // 0-0.3: extra attenuation for ear facing away
            const [headShadow, setHeadShadow] = React.useState(0.5); // 0-1: how much high-freq is cut when behind/opposite

            // Calibration wizard state
            const [showCalibration, setShowCalibration] = React.useState(false);
            const [calibrationStep, setCalibrationStep] = React.useState(0);
            const [calibrationDelayMs, setCalibrationDelayMs] = React.useState(10); // Start at 10ms for testing
            const [calibrationTimingActive, setCalibrationTimingActive] = React.useState(false); // Prevents useEffect from overwriting ITD delays
            const [calibrationResults, setCalibrationResults] = React.useState({
                canHearLeftRight: null,      // Can perceive L/R panning
                leftRightIntensity: 2.0,     // How much pan curve they need
                canHearFrontBack: null,      // Can perceive front/back via muffling
                frontBackIntensity: 0.5,     // Head shadow amount
                canHearTimingLeft: null,     // Can perceive ITD in left ear
                canHearTimingRight: null,    // Can perceive ITD in right ear
                timingThresholdLeft: null,   // Personal timing threshold (ms) for left ear
                timingThresholdRight: null,  // Personal timing threshold (ms) for right ear
                preferredVolume: 0.5         // Their optimal volume
            });

            // Helper: Reset spatial settings to defaults for clean calibration tests
            const resetToDefaults = React.useCallback(() => {
                setHeadShadow(0.5);
                setDirectionalDepth(0.15);
                setCrossBleed(0);
                setPanCurve(2.0);
                setItdAmount(0.7);
                setHardPanThreshold(0.1);
                setBackDepth(0.55);
                setOrbPosition({ x: 0, y: -80 }); // Front center
            }, []);

            // Load saved calibration settings on mount
            React.useEffect(() => {
                try {
                    const saved = localStorage.getItem('mpe_8d_calibration');
                    if (saved) {
                        const data = JSON.parse(saved);
                        console.log('[Calibration] Loading saved settings:', data);
                        if (data.itdAmount !== undefined) setItdAmount(data.itdAmount);
                        if (data.headShadow !== undefined) setHeadShadow(data.headShadow);
                        if (data.panCurve !== undefined) setPanCurve(data.panCurve);
                        if (data.directionalDepth !== undefined) setDirectionalDepth(data.directionalDepth);
                        if (data.crossBleed !== undefined) setCrossBleed(data.crossBleed);
                        if (data.backDepth !== undefined) setBackDepth(data.backDepth);
                        if (data.hardPanThreshold !== undefined) setHardPanThreshold(data.hardPanThreshold);
                        if (data.results) setCalibrationResults(data.results);
                    }
                } catch (err) {
                    console.error('[Calibration] Failed to load saved settings:', err);
                }
            }, []); // Only run on mount

            // Calculate audio parameters from orb position
            const radius = 80; // Head radius
            const orbRadius = Math.sqrt(orbPosition.x ** 2 + orbPosition.y ** 2);
            const angle = Math.atan2(orbPosition.x, -orbPosition.y) * (180 / Math.PI); // 0=front, 90=right, 180=back, -90=left
            const normalizedAngle = ((angle + 360) % 360); // 0-360

            // Calculate pan position (-1 to 1) based on X position
            const panPosition = Math.max(-1, Math.min(1, orbPosition.x / radius));

            // Calculate if behind (y > 0 means behind the head in our coordinate system)
            const isBehind = orbPosition.y > 0;
            const behindAmount = isBehind ? Math.min(1, orbPosition.y / radius) : 0; // 0-1 how far behind

            // Base depth multiplier for being behind
            const baseDepthMultiplier = isBehind ? backDepth : 1.0;

            // Directional depth: the ear CLOSER to the source gets extra attenuation when sound is behind
            // This simulates the pinna (outer ear) blocking sounds from behind
            // At back-left (pan=-0.76), left ear should be slightly quieter because sound is behind it
            let leftDirectionalAtten = 1.0;
            let rightDirectionalAtten = 1.0;

            if (isBehind) {
                // When behind, attenuate the ear that's on the same side as the sound
                // because that ear is "facing away" from the sound source
                if (panPosition < 0) {
                    // Sound is back-left: left ear faces away, gets extra attenuation
                    leftDirectionalAtten = 1.0 - (directionalDepth * Math.abs(panPosition) * behindAmount);
                } else if (panPosition > 0) {
                    // Sound is back-right: right ear faces away, gets extra attenuation
                    rightDirectionalAtten = 1.0 - (directionalDepth * Math.abs(panPosition) * behindAmount);
                }
            }

            // Calculate gain values (what the audio engine should use)
            const leftGain = Math.max(0, (1 - panPosition) * 0.5 * baseDepthMultiplier * leftDirectionalAtten);
            const rightGain = Math.max(0, (1 + panPosition) * 0.5 * baseDepthMultiplier * rightDirectionalAtten);

            // Hard pan calculation with adjustable curve and threshold
            let hardLeftGain, hardRightGain, actualCrossBleed;
            if (panPosition > hardPanThreshold) {
                // Sound is on the right
                const rightAmount = Math.min(1, (panPosition - hardPanThreshold) / (1 - hardPanThreshold));
                const curved = Math.pow(rightAmount, 1 / panCurve); // Apply pan curve
                hardLeftGain = Math.max(0, 1 - curved);
                hardRightGain = 1;
                actualCrossBleed = crossBleed * (1 - curved);
            } else if (panPosition < -hardPanThreshold) {
                // Sound is on the left
                const leftAmount = Math.min(1, (-panPosition - hardPanThreshold) / (1 - hardPanThreshold));
                const curved = Math.pow(leftAmount, 1 / panCurve);
                hardLeftGain = 1;
                hardRightGain = Math.max(0, 1 - curved);
                actualCrossBleed = crossBleed * (1 - curved);
            } else {
                // Center zone
                hardLeftGain = 0.5;
                hardRightGain = 0.5;
                actualCrossBleed = crossBleed;
            }
            // Apply depth and directional attenuation
            hardLeftGain *= baseDepthMultiplier * leftDirectionalAtten;
            hardRightGain *= baseDepthMultiplier * rightDirectionalAtten;

            // Calculate ITD (Inter-aural Time Difference)
            // Sound reaches closer ear first. Max ITD ~0.7ms when sound is directly to one side
            // Negative pan = sound on left = delay right ear
            // Positive pan = sound on right = delay left ear
            const maxItdMs = 0.7 * itdAmount; // ms
            const itdLeftDelay = panPosition > 0 ? Math.abs(panPosition) * maxItdMs / 1000 : 0; // seconds
            const itdRightDelay = panPosition < 0 ? Math.abs(panPosition) * maxItdMs / 1000 : 0; // seconds

            // Calculate low-pass filter frequencies for "head shadow" effect
            // When sound is behind or on opposite side, high frequencies are blocked
            // Full open = 20000Hz, max muffled = 2000Hz
            const minFreq = 2000; // Muffled sound
            const maxFreq = 20000; // Clear sound

            // Left ear filter: darker when sound is on the RIGHT or BEHIND-LEFT
            // Right ear filter: darker when sound is on the LEFT or BEHIND-RIGHT
            let leftFilterFreq = maxFreq;
            let rightFilterFreq = maxFreq;

            if (headShadow > 0) {
                // Head shadow from opposite side (sound on right = left ear darker)
                const leftShadowFromPan = panPosition > 0 ? panPosition : 0; // 0-1 when sound on right
                const rightShadowFromPan = panPosition < 0 ? -panPosition : 0; // 0-1 when sound on left

                // Additional shadow when behind
                const behindShadow = isBehind ? behindAmount * 0.5 : 0;

                const leftShadowAmount = Math.min(1, (leftShadowFromPan + behindShadow) * headShadow);
                const rightShadowAmount = Math.min(1, (rightShadowFromPan + behindShadow) * headShadow);

                // Exponential mapping for more natural rolloff
                leftFilterFreq = maxFreq * Math.pow(minFreq / maxFreq, leftShadowAmount);
                rightFilterFreq = maxFreq * Math.pow(minFreq / maxFreq, rightShadowAmount);
            }

            // Apply gains to audio whenever orb position or settings change
            React.useEffect(() => {
                // SKIP when calibration timing test is active - those tests set ITD directly
                if (calibrationTimingActive) {
                    console.log('[SpatialTuner useEffect] Skipping - calibration timing test active');
                    return;
                }
                if (isOpen && onApplyGains) {
                    // During calibration wizard, use HARD PANNING (no cross-bleed) for accurate L/R testing
                    const calibrationCrossBleed = showCalibration ? 0.0001 : Math.max(0.001, actualCrossBleed);
                    // Use hard pan values with cross bleed, ITD, and filter frequencies
                    // 8th param: forceHardPan (mutes parallel cross-delay paths during calibration)
                    onApplyGains(hardLeftGain, hardRightGain, calibrationCrossBleed, itdLeftDelay, itdRightDelay, leftFilterFreq, rightFilterFreq, showCalibration);
                }
            }, [orbPosition, isOpen, onApplyGains, hardLeftGain, hardRightGain, actualCrossBleed, itdLeftDelay, itdRightDelay, leftFilterFreq, rightFilterFreq, crossBleed, backDepth, panCurve, hardPanThreshold, itdAmount, directionalDepth, headShadow, calibrationTimingActive, showCalibration]);

            // Apply EQ whenever values change
            React.useEffect(() => {
                if (isOpen && onApplyEQ) {
                    onApplyEQ(eqBass, eqMid, eqTreble, eqClarity);
                }
            }, [isOpen, onApplyEQ, eqBass, eqMid, eqTreble, eqClarity]);

            const handleMouseDown = (e) => {
                setIsDragging(true);
                updateOrbPosition(e);
            };

            const handleMouseMove = (e) => {
                if (!isDragging) return;
                updateOrbPosition(e);
            };

            const handleMouseUp = () => {
                setIsDragging(false);
            };

            const updateOrbPosition = (e) => {
                if (!containerRef.current) return;
                const rect = containerRef.current.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;

                let x = e.clientX - rect.left - centerX;
                let y = e.clientY - rect.top - centerY;

                // Constrain to circle
                const dist = Math.sqrt(x * x + y * y);
                if (dist > radius) {
                    x = (x / dist) * radius;
                    y = (y / dist) * radius;
                }

                setOrbPosition({ x, y });
            };

            const getPositionLabel = () => {
                if (normalizedAngle >= 315 || normalizedAngle < 45) return 'FRONT';
                if (normalizedAngle >= 45 && normalizedAngle < 135) return 'RIGHT';
                if (normalizedAngle >= 135 && normalizedAngle < 225) return 'BACK';
                return 'LEFT';
            };

            if (!isOpen) return null;

            return (
                <div style={{
                    position: 'fixed',
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    background: 'rgba(0,0,0,0.85)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    zIndex: 10000
                }} onClick={onClose}>
                    <div style={{
                        background: 'var(--bg-2)',
                        borderRadius: '16px',
                        maxWidth: '500px',
                        width: '95%',
                        maxHeight: '85vh',
                        display: 'flex',
                        flexDirection: 'column',
                        overflow: 'hidden'
                    }} onClick={e => e.stopPropagation()}>
                        {/* Fixed Header */}
                        <div style={{
                            padding: '12px 16px',
                            borderBottom: '1px solid var(--border)',
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center',
                            flexShrink: 0
                        }}>
                            <h3 style={{ margin: 0, color: 'var(--accent)', fontSize: '1rem' }}>Audio Settings</h3>
                            <button
                                onClick={onClose}
                                style={{
                                    background: 'transparent',
                                    border: 'none',
                                    color: 'var(--text-secondary)',
                                    fontSize: '1.5rem',
                                    cursor: 'pointer',
                                    padding: '0 4px',
                                    lineHeight: 1
                                }}
                            >×</button>
                        </div>

                        {/* Scrollable Content */}
                        <div style={{
                            flex: 1,
                            overflowY: 'auto',
                            padding: '12px',
                            minHeight: 0
                        }}>

                        {/* Volume Recommendation Panel */}
                        {(() => {
                            const volumePercent = Math.round(currentVolume * 100);
                            const isOptimal = volumePercent >= 40 && volumePercent <= 60;
                            const isTooLoud = volumePercent > 75;
                            const isTooQuiet = volumePercent < 25;
                            const statusColor = isOptimal ? '#4ade80' : (isTooLoud ? '#f87171' : (isTooQuiet ? '#fbbf24' : '#fbbf24'));
                            const statusText = isOptimal ? '✓ Optimal for spatial perception' :
                                              (isTooLoud ? '⚠ Too loud - spatial cues may be drowned out' :
                                              (isTooQuiet ? '⚠ Too quiet - may miss subtle effects' : '~ Adjust for best spatial effect'));

                            return (
                                <div style={{
                                    background: 'rgba(0,0,0,0.4)',
                                    borderRadius: '8px',
                                    padding: '12px',
                                    marginBottom: '16px',
                                    border: `1px solid ${statusColor}40`
                                }}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '8px' }}>
                                        <span style={{ fontSize: '1.2rem' }}>🔊</span>
                                        <span style={{ fontWeight: 'bold', color: 'var(--text-primary)', fontSize: '0.875rem' }}>
                                            Volume: {volumePercent}%
                                        </span>
                                        <span style={{
                                            fontSize: '0.75rem',
                                            color: statusColor,
                                            marginLeft: 'auto'
                                        }}>
                                            {statusText}
                                        </span>
                                    </div>

                                    {onVolumeChange && (
                                        <div>
                                            <input
                                                type="range"
                                                min="0"
                                                max="1"
                                                step="0.01"
                                                value={currentVolume}
                                                onChange={(e) => onVolumeChange(parseFloat(e.target.value))}
                                                style={{
                                                    width: '100%',
                                                    accentColor: statusColor,
                                                    height: '8px'
                                                }}
                                            />
                                            <div style={{
                                                display: 'flex',
                                                justifyContent: 'space-between',
                                                fontSize: '0.65rem',
                                                color: 'var(--text-secondary)',
                                                marginTop: '4px'
                                            }}>
                                                <span>Too Quiet</span>
                                                <span style={{ color: '#4ade80' }}>▲ Sweet Spot (40-60%)</span>
                                                <span>Too Loud</span>
                                            </div>
                                        </div>
                                    )}

                                    <div style={{
                                        fontSize: '0.7rem',
                                        color: 'var(--text-secondary)',
                                        marginTop: '8px',
                                        padding: '6px',
                                        background: 'rgba(255,255,255,0.05)',
                                        borderRadius: '4px'
                                    }}>
                                        💡 <strong>Tip:</strong> Research shows 73-85 dB SPL is optimal for spatial perception.
                                        At high volumes, spatial cues get "drowned out". Try 40-60% for best results.
                                    </div>
                                </div>
                            );
                        })()}

                        {/* Quick Calibration Button */}
                        {!showCalibration && (
                            <button
                                onClick={() => {
                                    resetToDefaults(); // Start fresh
                                    setCalibrationDelayMs(10);
                                    setCalibrationResults({
                                        canHearLeftRight: null,
                                        leftRightIntensity: 2.0,
                                        canHearFrontBack: null,
                                        frontBackIntensity: 0.5,
                                        canHearTimingLeft: null,
                                        canHearTimingRight: null,
                                        timingThresholdLeft: null,
                                        timingThresholdRight: null,
                                        preferredVolume: 0.5
                                    });
                                    setShowCalibration(true);
                                    setCalibrationStep(0);
                                }}
                                style={{
                                    width: '100%',
                                    padding: '12px',
                                    marginBottom: '16px',
                                    background: 'linear-gradient(135deg, #8b5cf6, #6366f1)',
                                    color: 'white',
                                    border: 'none',
                                    borderRadius: '8px',
                                    cursor: 'pointer',
                                    fontWeight: '600',
                                    fontSize: '0.9rem',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    gap: '8px'
                                }}
                            >
                                🧠 Quick Brain Calibration (APD-Friendly)
                            </button>
                        )}

                        {/* Calibration Wizard */}
                        {showCalibration && (
                            <div style={{
                                background: 'rgba(139, 92, 246, 0.1)',
                                border: '2px solid #8b5cf6',
                                borderRadius: '12px',
                                padding: '16px',
                                marginBottom: '16px'
                            }}>
                                {calibrationStep === 0 && (
                                    <div>
                                        <h4 style={{ margin: '0 0 12px', color: '#a78bfa' }}>🧠 Brain Calibration Wizard</h4>
                                        <p style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', marginBottom: '12px' }}>
                                            This wizard will help find the spatial audio settings that work best for YOUR brain.
                                            We'll test different types of spatial cues and adjust based on what you can perceive.
                                        </p>
                                        <div style={{ background: 'rgba(0,0,0,0.3)', padding: '12px', borderRadius: '8px', marginBottom: '12px' }}>
                                            <p style={{ fontSize: '0.8rem', color: '#fbbf24', margin: '0 0 8px' }}>
                                                <strong>For Auditory Processing Differences:</strong>
                                            </p>
                                            <ul style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', margin: 0, paddingLeft: '20px' }}>
                                                <li>Timing cues (ITD) may be harder to perceive - we'll test this</li>
                                                <li>Frequency changes (muffling) are often easier to notice</li>
                                                <li>We can boost effects that work best for you</li>
                                            </ul>
                                        </div>
                                        <p style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginBottom: '16px' }}>
                                            <strong>Requirements:</strong> Music playing + headphones on
                                        </p>
                                        <div style={{ display: 'flex', gap: '8px' }}>
                                            <button
                                                onClick={() => setCalibrationStep(1)}
                                                style={{
                                                    flex: 1,
                                                    padding: '10px',
                                                    background: '#8b5cf6',
                                                    color: 'white',
                                                    border: 'none',
                                                    borderRadius: '6px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600'
                                                }}
                                            >
                                                Start Calibration →
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setCalibrationTimingActive(false);
                                                    setShowCalibration(false);
                                                }}
                                                style={{
                                                    padding: '10px 16px',
                                                    background: 'transparent',
                                                    color: 'var(--text-secondary)',
                                                    border: '1px solid var(--text-secondary)',
                                                    borderRadius: '6px',
                                                    cursor: 'pointer'
                                                }}
                                            >
                                                Cancel
                                            </button>
                                        </div>
                                    </div>
                                )}

                                {calibrationStep === 1 && (
                                    <div>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                                            <h4 style={{ margin: 0, color: '#a78bfa' }}>Step 1: Left/Right Test</h4>
                                            <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)' }}>1 of 5</span>
                                        </div>
                                        <p style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', marginBottom: '12px' }}>
                                            I'll move the sound to the <strong>LEFT</strong> then <strong>RIGHT</strong>.
                                            Listen carefully - can you tell the difference?
                                        </p>

                                        {/* Test buttons to move sound */}
                                        <div style={{ display: 'flex', gap: '8px', marginBottom: '16px' }}>
                                            <button
                                                onClick={() => {
                                                    setOrbPosition({ x: -80, y: 0 });
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '16px',
                                                    background: 'rgba(59, 130, 246, 0.2)',
                                                    color: '#60a5fa',
                                                    border: '2px solid #60a5fa',
                                                    borderRadius: '8px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600',
                                                    fontSize: '1.1rem'
                                                }}
                                            >
                                                👈 LEFT
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setOrbPosition({ x: 80, y: 0 });
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '16px',
                                                    background: 'rgba(34, 197, 94, 0.2)',
                                                    color: '#4ade80',
                                                    border: '2px solid #4ade80',
                                                    borderRadius: '8px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600',
                                                    fontSize: '1.1rem'
                                                }}
                                            >
                                                RIGHT 👉
                                            </button>
                                        </div>

                                        <p style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginBottom: '8px' }}>
                                            <strong>Can you clearly hear the difference between LEFT and RIGHT?</strong>
                                        </p>
                                        <div style={{ display: 'flex', gap: '8px', marginBottom: '8px' }}>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearLeftRight: 'clear', leftRightIntensity: 2.0 }));
                                                    resetToDefaults(); // Reset for next test
                                                    setCalibrationStep(2);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#4ade80', color: 'black', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                Yes, clearly! ✓
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearLeftRight: 'subtle', leftRightIntensity: 3.0 }));
                                                    resetToDefaults(); // Reset for next test
                                                    setCalibrationStep(2);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#fbbf24', color: 'black', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                Barely / Subtle
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearLeftRight: 'no', leftRightIntensity: 4.0 }));
                                                    resetToDefaults(); // Reset for next test
                                                    setCalibrationStep(2);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#f87171', color: 'white', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                No / Can't tell ✗
                                            </button>
                                        </div>
                                    </div>
                                )}

                                {calibrationStep === 2 && (
                                    <div>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                                            <h4 style={{ margin: 0, color: '#a78bfa' }}>Step 2: Front/Back Test (Muffling)</h4>
                                            <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)' }}>2 of 5</span>
                                        </div>
                                        <p style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', marginBottom: '12px' }}>
                                            I'll move the sound to the <strong>FRONT</strong> (bright/clear) then <strong>BACK</strong> (muffled/darker).
                                            This tests if you can hear the tone change.
                                        </p>

                                        <div style={{ display: 'flex', gap: '8px', marginBottom: '16px' }}>
                                            <button
                                                onClick={() => {
                                                    setOrbPosition({ x: 0, y: -80 });
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '16px',
                                                    background: 'rgba(251, 191, 36, 0.2)',
                                                    color: '#fbbf24',
                                                    border: '2px solid #fbbf24',
                                                    borderRadius: '8px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600',
                                                    fontSize: '1rem'
                                                }}
                                            >
                                                🔆 FRONT (Clear)
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setOrbPosition({ x: 0, y: 80 });
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '16px',
                                                    background: 'rgba(107, 114, 128, 0.3)',
                                                    color: '#9ca3af',
                                                    border: '2px solid #6b7280',
                                                    borderRadius: '8px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600',
                                                    fontSize: '1rem'
                                                }}
                                            >
                                                🔅 BACK (Muffled)
                                            </button>
                                        </div>

                                        <p style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginBottom: '8px' }}>
                                            <strong>Can you hear the muffling/darkening when sound moves to BACK?</strong>
                                        </p>
                                        <div style={{ display: 'flex', gap: '8px' }}>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearFrontBack: 'clear', frontBackIntensity: 0.5 }));
                                                    resetToDefaults(); // Reset for timing test
                                                    setCalibrationDelayMs(10); // Start timing test at 10ms
                                                    setCalibrationTimingActive(true); // Prevent useEffect from overwriting ITD
                                                    setCalibrationStep(3);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#4ade80', color: 'black', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                Yes, clearly! ✓
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearFrontBack: 'subtle', frontBackIntensity: 0.8 }));
                                                    resetToDefaults(); // Reset for timing test
                                                    setCalibrationDelayMs(10);
                                                    setCalibrationTimingActive(true); // Prevent useEffect from overwriting ITD
                                                    setCalibrationStep(3);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#fbbf24', color: 'black', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                Barely / Subtle
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearFrontBack: 'no', frontBackIntensity: 1.0 }));
                                                    resetToDefaults(); // Reset for timing test
                                                    setCalibrationDelayMs(10);
                                                    setCalibrationTimingActive(true); // Prevent useEffect from overwriting ITD
                                                    setCalibrationStep(3);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#f87171', color: 'white', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                No / Can't tell ✗
                                            </button>
                                        </div>
                                    </div>
                                )}

                                {calibrationStep === 3 && (
                                    <div>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                                            <h4 style={{ margin: 0, color: '#a78bfa' }}>Step 3a: Left Ear Timing</h4>
                                            <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)' }}>3 of 5</span>
                                        </div>
                                        <p style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', marginBottom: '8px' }}>
                                            Sound arrives at your <strong style={{ color: '#60a5fa' }}>LEFT ear</strong> before your right.
                                            <strong style={{ color: '#fbbf24' }}> Adjust the delay until you can hear it!</strong>
                                        </p>
                                        <p style={{ fontSize: '0.75rem', color: '#6b7280', marginBottom: '12px', fontStyle: 'italic' }}>
                                            Tip: Keep volume at 40-60%. Normal ITD is ~0.7ms, but some people need more.
                                        </p>

                                        {/* Delay slider */}
                                        <div style={{ background: 'rgba(0,0,0,0.3)', padding: '12px', borderRadius: '8px', marginBottom: '12px' }}>
                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                                                <span style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>Delay Amount:</span>
                                                <span style={{ fontSize: '1rem', fontWeight: '700', color: '#60a5fa' }}>{calibrationDelayMs} ms</span>
                                            </div>
                                            <input
                                                type="range"
                                                min="0"
                                                max="200"
                                                step="5"
                                                value={calibrationDelayMs}
                                                onChange={(e) => setCalibrationDelayMs(Number(e.target.value))}
                                                style={{ width: '100%', accentColor: '#60a5fa' }}
                                            />
                                            <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.7rem', color: 'var(--text-secondary)' }}>
                                                <span>0ms</span>
                                                <span>Normal: ~0.7ms</span>
                                                <span>200ms</span>
                                            </div>
                                            {/* Quick adjust buttons */}
                                            <div style={{ display: 'flex', gap: '4px', marginTop: '8px', flexWrap: 'wrap' }}>
                                                <button onClick={() => setCalibrationDelayMs(10)} style={{ padding: '6px 10px', background: 'rgba(139,92,246,0.2)', color: '#a78bfa', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem' }}>10ms</button>
                                                <button onClick={() => setCalibrationDelayMs(25)} style={{ padding: '6px 10px', background: 'rgba(139,92,246,0.2)', color: '#a78bfa', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem' }}>25ms</button>
                                                <button onClick={() => setCalibrationDelayMs(50)} style={{ padding: '6px 10px', background: 'rgba(139,92,246,0.2)', color: '#a78bfa', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem' }}>50ms</button>
                                                <button onClick={() => setCalibrationDelayMs(100)} style={{ padding: '6px 10px', background: 'rgba(139,92,246,0.3)', color: '#a78bfa', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem' }}>100ms</button>
                                                <button onClick={() => setCalibrationDelayMs(150)} style={{ padding: '6px 10px', background: 'rgba(139,92,246,0.3)', color: '#a78bfa', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem' }}>150ms</button>
                                                <button onClick={() => setCalibrationDelayMs(200)} style={{ padding: '6px 10px', background: 'rgba(139,92,246,0.4)', color: '#a78bfa', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem' }}>200ms</button>
                                            </div>
                                        </div>

                                        <div style={{ display: 'flex', gap: '8px', marginBottom: '16px' }}>
                                            <button
                                                onClick={() => {
                                                    // Apply delay: left ear gets sound first (delay right ear)
                                                    // EQUAL VOLUME: same gain for both + high crossbleed for mono mix
                                                    const delaySeconds = calibrationDelayMs / 1000;
                                                    console.log(`[Calibration] LEFT FIRST: Delaying RIGHT ear by ${calibrationDelayMs}ms (${delaySeconds}s)`);
                                                    setHeadShadow(0);
                                                    setDirectionalDepth(0);
                                                    setCrossBleed(0.5); // High crossbleed = mono mix (equal in both ears)
                                                    setPanCurve(1.0); // Minimal pan separation
                                                    setOrbPosition({ x: 0, y: 0 }); // Center position
                                                    // Equal gains (0.5 each) + 0.5 crossbleed = mono mix to both ears
                                                    // Only difference: right ear delayed (itdRightDelay = delaySeconds)
                                                    onApplyGains(0.5, 0.5, 0.5, 0, delaySeconds, 20000, 20000);
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '12px',
                                                    background: 'rgba(96, 165, 250, 0.3)',
                                                    color: '#60a5fa',
                                                    border: '2px solid #3b82f6',
                                                    borderRadius: '8px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600'
                                                }}
                                            >
                                                ◀ Left First ({calibrationDelayMs}ms)
                                            </button>
                                            <button
                                                onClick={() => {
                                                    // No delay - SAME volume in both ears (mono mix)
                                                    console.log('[Calibration] NO DELAY: Both ears get sound at same time');
                                                    setHeadShadow(0);
                                                    setDirectionalDepth(0);
                                                    setCrossBleed(0.5); // High cross-bleed = mono mix
                                                    setPanCurve(1.0);
                                                    setOrbPosition({ x: 0, y: 0 });
                                                    onApplyGains(0.5, 0.5, 0.5, 0, 0, 20000, 20000);
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '12px',
                                                    background: 'rgba(107, 114, 128, 0.3)',
                                                    color: '#9ca3af',
                                                    border: '2px solid #6b7280',
                                                    borderRadius: '8px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600'
                                                }}
                                            >
                                                No Delay (Compare)
                                            </button>
                                        </div>

                                        <p style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginBottom: '8px' }}>
                                            <strong>Can you hear a difference when toggling?</strong> If not, increase the delay.
                                        </p>
                                        <div style={{ display: 'flex', gap: '8px' }}>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearTimingLeft: 'yes', timingThresholdLeft: calibrationDelayMs }));
                                                    resetToDefaults(); // Reset for right ear test
                                                    setCalibrationDelayMs(10); // Reset delay slider for right ear test
                                                    setCalibrationStep(4);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#4ade80', color: 'black', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                Yes! I hear it at {calibrationDelayMs}ms ✓
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearTimingLeft: 'no', timingThresholdLeft: null }));
                                                    resetToDefaults(); // Reset for right ear test
                                                    setCalibrationDelayMs(10);
                                                    setCalibrationStep(4);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#f87171', color: 'white', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                Can't hear it ✗
                                            </button>
                                        </div>
                                    </div>
                                )}

                                {calibrationStep === 4 && (
                                    <div>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                                            <h4 style={{ margin: 0, color: '#a78bfa' }}>Step 3b: Right Ear Timing</h4>
                                            <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)' }}>4 of 5</span>
                                        </div>
                                        <p style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', marginBottom: '8px' }}>
                                            Now sound arrives at your <strong style={{ color: '#f472b6' }}>RIGHT ear</strong> before your left.
                                            <strong style={{ color: '#fbbf24' }}> Same thing - find your threshold!</strong>
                                        </p>
                                        <p style={{ fontSize: '0.75rem', color: '#6b7280', marginBottom: '12px', fontStyle: 'italic' }}>
                                            {calibrationResults.timingThresholdLeft ? `Left ear threshold was ${calibrationResults.timingThresholdLeft}ms - might be similar!` : 'Some people perceive timing better in one ear than the other.'}
                                        </p>

                                        {/* Delay slider */}
                                        <div style={{ background: 'rgba(0,0,0,0.3)', padding: '12px', borderRadius: '8px', marginBottom: '12px' }}>
                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                                                <span style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>Delay Amount:</span>
                                                <span style={{ fontSize: '1rem', fontWeight: '700', color: '#f472b6' }}>{calibrationDelayMs} ms</span>
                                            </div>
                                            <input
                                                type="range"
                                                min="0"
                                                max="200"
                                                step="5"
                                                value={calibrationDelayMs}
                                                onChange={(e) => setCalibrationDelayMs(Number(e.target.value))}
                                                style={{ width: '100%', accentColor: '#f472b6' }}
                                            />
                                            <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.7rem', color: 'var(--text-secondary)' }}>
                                                <span>0ms</span>
                                                <span>Normal: ~0.7ms</span>
                                                <span>200ms</span>
                                            </div>
                                            {/* Quick adjust buttons */}
                                            <div style={{ display: 'flex', gap: '4px', marginTop: '8px', flexWrap: 'wrap' }}>
                                                <button onClick={() => setCalibrationDelayMs(10)} style={{ padding: '6px 10px', background: 'rgba(244,114,182,0.2)', color: '#f472b6', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem' }}>10ms</button>
                                                <button onClick={() => setCalibrationDelayMs(25)} style={{ padding: '6px 10px', background: 'rgba(244,114,182,0.2)', color: '#f472b6', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem' }}>25ms</button>
                                                <button onClick={() => setCalibrationDelayMs(50)} style={{ padding: '6px 10px', background: 'rgba(244,114,182,0.2)', color: '#f472b6', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem' }}>50ms</button>
                                                <button onClick={() => setCalibrationDelayMs(100)} style={{ padding: '6px 10px', background: 'rgba(244,114,182,0.3)', color: '#f472b6', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem' }}>100ms</button>
                                                <button onClick={() => setCalibrationDelayMs(150)} style={{ padding: '6px 10px', background: 'rgba(244,114,182,0.3)', color: '#f472b6', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem' }}>150ms</button>
                                                <button onClick={() => setCalibrationDelayMs(200)} style={{ padding: '6px 10px', background: 'rgba(244,114,182,0.4)', color: '#f472b6', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem' }}>200ms</button>
                                            </div>
                                        </div>

                                        <div style={{ display: 'flex', gap: '8px', marginBottom: '16px' }}>
                                            <button
                                                onClick={() => {
                                                    // Apply delay: right ear gets sound first (delay left ear)
                                                    // EQUAL VOLUME: same gain for both + high cross-bleed for mono mix
                                                    setHeadShadow(0);
                                                    setDirectionalDepth(0);
                                                    setCrossBleed(0.5); // High cross-bleed = mono mix (equal in both ears)
                                                    setPanCurve(1.0); // Minimal pan separation
                                                    setOrbPosition({ x: 0, y: 0 }); // Center position
                                                    // Equal gains + 0.5 cross-bleed = mono mix to both ears
                                                    // Only difference: left ear delayed
                                                    const delaySeconds = calibrationDelayMs / 1000;
                                                    onApplyGains(0.5, 0.5, 0.5, delaySeconds, 0, 20000, 20000);
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '12px',
                                                    background: 'rgba(244, 114, 182, 0.3)',
                                                    color: '#f472b6',
                                                    border: '2px solid #ec4899',
                                                    borderRadius: '8px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600'
                                                }}
                                            >
                                                Right First ({calibrationDelayMs}ms) ▶
                                            </button>
                                            <button
                                                onClick={() => {
                                                    // No delay - SAME volume in both ears (mono mix)
                                                    setHeadShadow(0);
                                                    setDirectionalDepth(0);
                                                    setCrossBleed(0.5); // High cross-bleed = mono mix
                                                    setPanCurve(1.0);
                                                    setOrbPosition({ x: 0, y: 0 });
                                                    onApplyGains(0.5, 0.5, 0.5, 0, 0, 20000, 20000);
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '12px',
                                                    background: 'rgba(107, 114, 128, 0.3)',
                                                    color: '#9ca3af',
                                                    border: '2px solid #6b7280',
                                                    borderRadius: '8px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600'
                                                }}
                                            >
                                                No Delay (Compare)
                                            </button>
                                        </div>

                                        <p style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginBottom: '8px' }}>
                                            <strong>Can you hear a difference when toggling?</strong> If not, increase the delay.
                                        </p>
                                        <div style={{ display: 'flex', gap: '8px' }}>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearTimingRight: 'yes', timingThresholdRight: calibrationDelayMs }));
                                                    setCalibrationTimingActive(false); // Re-enable normal spatial processing
                                                    resetToDefaults(); // Reset for results display
                                                    setCalibrationStep(5);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#4ade80', color: 'black', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                Yes! I hear it at {calibrationDelayMs}ms ✓
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearTimingRight: 'no', timingThresholdRight: null }));
                                                    setCalibrationTimingActive(false); // Re-enable normal spatial processing
                                                    resetToDefaults(); // Reset for results display
                                                    setCalibrationStep(5);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#f87171', color: 'white', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                Can't hear it ✗
                                            </button>
                                        </div>
                                    </div>
                                )}

                                {calibrationStep === 5 && (
                                    <div>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                                            <h4 style={{ margin: 0, color: '#4ade80' }}>✓ Calibration Complete!</h4>
                                            <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)' }}>5 of 5</span>
                                        </div>

                                        <div style={{ background: 'rgba(0,0,0,0.3)', padding: '12px', borderRadius: '8px', marginBottom: '16px' }}>
                                            <p style={{ fontSize: '0.85rem', color: 'var(--text-primary)', margin: '0 0 12px', fontWeight: '600' }}>
                                                Your Personalized Profile:
                                            </p>
                                            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px', fontSize: '0.8rem' }}>
                                                <div>
                                                    <span style={{ color: 'var(--text-secondary)' }}>Left/Right:</span>
                                                    <span style={{ marginLeft: '8px', color: calibrationResults.canHearLeftRight === 'clear' ? '#4ade80' : (calibrationResults.canHearLeftRight === 'subtle' ? '#fbbf24' : '#f87171') }}>
                                                        {calibrationResults.canHearLeftRight === 'clear' ? 'Clear ✓' : (calibrationResults.canHearLeftRight === 'subtle' ? 'Boosted' : 'Max Boost')}
                                                    </span>
                                                </div>
                                                <div>
                                                    <span style={{ color: 'var(--text-secondary)' }}>Front/Back:</span>
                                                    <span style={{ marginLeft: '8px', color: calibrationResults.canHearFrontBack === 'clear' ? '#4ade80' : (calibrationResults.canHearFrontBack === 'subtle' ? '#fbbf24' : '#f87171') }}>
                                                        {calibrationResults.canHearFrontBack === 'clear' ? 'Clear ✓' : (calibrationResults.canHearFrontBack === 'subtle' ? 'Boosted' : 'Max Boost')}
                                                    </span>
                                                </div>
                                                <div>
                                                    <span style={{ color: 'var(--text-secondary)' }}>Timing Left:</span>
                                                    <span style={{ marginLeft: '8px', color: calibrationResults.canHearTimingLeft === 'yes' ? '#4ade80' : '#6b7280' }}>
                                                        {calibrationResults.canHearTimingLeft === 'yes'
                                                            ? `✓ ${calibrationResults.timingThresholdLeft}ms`
                                                            : '✗ Not detected'}
                                                    </span>
                                                </div>
                                                <div>
                                                    <span style={{ color: 'var(--text-secondary)' }}>Timing Right:</span>
                                                    <span style={{ marginLeft: '8px', color: calibrationResults.canHearTimingRight === 'yes' ? '#4ade80' : '#6b7280' }}>
                                                        {calibrationResults.canHearTimingRight === 'yes'
                                                            ? `✓ ${calibrationResults.timingThresholdRight}ms`
                                                            : '✗ Not detected'}
                                                    </span>
                                                </div>
                                                <div style={{ gridColumn: '1 / -1' }}>
                                                    <span style={{ color: 'var(--text-secondary)' }}>Strategy:</span>
                                                    <span style={{ marginLeft: '8px', color: '#a78bfa' }}>
                                                        {calibrationResults.canHearTimingLeft === 'no' && calibrationResults.canHearTimingRight === 'no'
                                                            ? 'Volume + Tone (No ITD)'
                                                            : calibrationResults.canHearTimingLeft !== calibrationResults.canHearTimingRight
                                                                ? 'Partial ITD (one ear stronger)'
                                                                : 'Full Spatial'}
                                                    </span>
                                                </div>
                                            </div>
                                        </div>

                                        {calibrationResults.canHearTimingLeft === 'no' && calibrationResults.canHearTimingRight === 'no' && (
                                            <div style={{ background: 'rgba(251, 191, 36, 0.1)', padding: '10px', borderRadius: '6px', marginBottom: '12px', fontSize: '0.8rem', color: '#fbbf24' }}>
                                                💡 <strong>APD-Optimized:</strong> Since timing cues are harder for you, we're using
                                                <strong> volume differences</strong> and <strong>tone changes</strong> (muffling) as your primary spatial cues.
                                                These are processed differently by the brain and often work better!
                                            </div>
                                        )}

                                        {calibrationResults.canHearTimingLeft !== calibrationResults.canHearTimingRight && (
                                            <div style={{ background: 'rgba(139, 92, 246, 0.1)', padding: '10px', borderRadius: '6px', marginBottom: '12px', fontSize: '0.8rem', color: '#a78bfa' }}>
                                                💡 <strong>Asymmetric Timing:</strong> You perceive timing better in your
                                                <strong> {calibrationResults.canHearTimingLeft === 'yes' ? 'left' : 'right'} ear</strong>.
                                                This is common! ITD is enabled with this preference in mind.
                                            </div>
                                        )}

                                        {/* Show thresholds found */}
                                        {(calibrationResults.timingThresholdLeft || calibrationResults.timingThresholdRight) && (
                                            <div style={{ background: 'rgba(74, 222, 128, 0.1)', padding: '10px', borderRadius: '6px', marginBottom: '12px', fontSize: '0.8rem', color: '#4ade80' }}>
                                                🎯 <strong>Your Timing Thresholds:</strong>
                                                {calibrationResults.timingThresholdLeft && <span> Left: {calibrationResults.timingThresholdLeft}ms</span>}
                                                {calibrationResults.timingThresholdLeft && calibrationResults.timingThresholdRight && <span> |</span>}
                                                {calibrationResults.timingThresholdRight && <span> Right: {calibrationResults.timingThresholdRight}ms</span>}
                                                <br />
                                                <span style={{ fontSize: '0.7rem', color: 'var(--text-secondary)' }}>
                                                    (Normal hearing is ~0.7ms. Higher = needs more delay to perceive)
                                                </span>
                                            </div>
                                        )}

                                        <div style={{ display: 'flex', gap: '8px' }}>
                                            <button
                                                onClick={() => {
                                                    // Apply final settings based on results
                                                    let finalItdAmount = 0.7; // Default
                                                    const canHearAnyTiming = calibrationResults.canHearTimingLeft === 'yes' || calibrationResults.canHearTimingRight === 'yes';
                                                    if (!canHearAnyTiming) {
                                                        finalItdAmount = 0;
                                                        setItdAmount(0);
                                                    } else {
                                                        // Use their personal threshold to calculate ITD multiplier
                                                        // Normal ITD is 0.7ms, so multiplier = threshold / 0.7
                                                        const leftThreshold = calibrationResults.timingThresholdLeft || 50;
                                                        const rightThreshold = calibrationResults.timingThresholdRight || 50;
                                                        const avgThreshold = (leftThreshold + rightThreshold) / 2;
                                                        // Calculate multiplier: their threshold / normal (0.7ms)
                                                        // Cap at 70 (which gives ~50ms max delay)
                                                        const multiplier = Math.min(70, avgThreshold / 0.7);
                                                        finalItdAmount = multiplier;
                                                        setItdAmount(multiplier);
                                                        console.log(`[Calibration] Set ITD multiplier to ${multiplier.toFixed(1)} (threshold: ${avgThreshold}ms)`);
                                                    }
                                                    // Restore other settings
                                                    const finalHeadShadow = calibrationResults.frontBackIntensity || 0.5;
                                                    const finalPanCurve = calibrationResults.leftRightIntensity || 2.0;
                                                    setHeadShadow(finalHeadShadow);
                                                    setPanCurve(finalPanCurve);
                                                    setDirectionalDepth(0.15);
                                                    setCrossBleed(0);

                                                    // SAVE calibration to localStorage for persistence
                                                    const calibrationData = {
                                                        itdAmount: finalItdAmount,
                                                        headShadow: finalHeadShadow,
                                                        panCurve: finalPanCurve,
                                                        directionalDepth: 0.15,
                                                        crossBleed: 0,
                                                        backDepth: 0.55,
                                                        hardPanThreshold: 0.1,
                                                        // EQ settings
                                                        eq: {
                                                            bass: eqBass,
                                                            mid: eqMid,
                                                            treble: eqTreble,
                                                            clarity: eqClarity
                                                        },
                                                        results: calibrationResults,
                                                        savedAt: Date.now()
                                                    };
                                                    try {
                                                        localStorage.setItem('mpe_8d_calibration', JSON.stringify(calibrationData));
                                                        console.log('[Calibration] Saved to localStorage:', calibrationData);
                                                        // Notify parent that calibration is complete
                                                        if (onCalibrationComplete) {
                                                            onCalibrationComplete();
                                                        }
                                                    } catch (err) {
                                                        console.error('[Calibration] Failed to save:', err);
                                                    }

                                                    setCalibrationTimingActive(false); // Ensure timing mode is off
                                                    setShowCalibration(false);
                                                    setOrbPosition({ x: 0, y: -80 }); // Reset to front
                                                    // Reset calibration delay for next time
                                                    setCalibrationDelayMs(10);
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '12px',
                                                    background: '#4ade80',
                                                    color: 'black',
                                                    border: 'none',
                                                    borderRadius: '6px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600'
                                                }}
                                            >
                                                Apply Settings ✓
                                            </button>
                                            <button
                                                onClick={() => {
                                                    resetToDefaults(); // Start fresh
                                                    setCalibrationDelayMs(10);
                                                    setCalibrationResults({
                                                        canHearLeftRight: null,
                                                        leftRightIntensity: 2.0,
                                                        canHearFrontBack: null,
                                                        frontBackIntensity: 0.5,
                                                        canHearTimingLeft: null,
                                                        canHearTimingRight: null,
                                                        timingThresholdLeft: null,
                                                        timingThresholdRight: null,
                                                        preferredVolume: 0.5
                                                    });
                                                    setCalibrationStep(0);
                                                }}
                                                style={{
                                                    padding: '12px 16px',
                                                    background: 'transparent',
                                                    color: 'var(--text-secondary)',
                                                    border: '1px solid var(--text-secondary)',
                                                    borderRadius: '6px',
                                                    cursor: 'pointer'
                                                }}
                                            >
                                                Redo
                                            </button>
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}

                        {/* Head visualization - only show when not in calibration */}
                        {!showCalibration && (
                        <div
                            ref={containerRef}
                            style={{
                                width: '200px',
                                height: '200px',
                                margin: '0 auto 16px',
                                position: 'relative',
                                cursor: 'crosshair'
                            }}
                            onMouseDown={handleMouseDown}
                            onMouseMove={handleMouseMove}
                            onMouseUp={handleMouseUp}
                            onMouseLeave={handleMouseUp}
                        >
                            {/* Head circle */}
                            <div style={{
                                position: 'absolute',
                                top: '50%',
                                left: '50%',
                                transform: 'translate(-50%, -50%)',
                                width: '160px',
                                height: '160px',
                                borderRadius: '50%',
                                border: '3px solid var(--text-secondary)',
                                background: 'rgba(255,255,255,0.05)'
                            }}>
                                {/* Nose indicator */}
                                <div style={{
                                    position: 'absolute',
                                    top: '-15px',
                                    left: '50%',
                                    transform: 'translateX(-50%)',
                                    width: '0',
                                    height: '0',
                                    borderLeft: '8px solid transparent',
                                    borderRight: '8px solid transparent',
                                    borderBottom: '12px solid var(--text-secondary)'
                                }} />
                                {/* Left ear */}
                                <div style={{
                                    position: 'absolute',
                                    top: '50%',
                                    left: '-12px',
                                    transform: 'translateY(-50%)',
                                    width: '10px',
                                    height: '24px',
                                    borderRadius: '5px',
                                    background: 'var(--text-secondary)'
                                }} />
                                {/* Right ear */}
                                <div style={{
                                    position: 'absolute',
                                    top: '50%',
                                    right: '-12px',
                                    transform: 'translateY(-50%)',
                                    width: '10px',
                                    height: '24px',
                                    borderRadius: '5px',
                                    background: 'var(--text-secondary)'
                                }} />
                                {/* Labels */}
                                <span style={{ position: 'absolute', top: '-30px', left: '50%', transform: 'translateX(-50%)', fontSize: '0.7rem', color: 'var(--text-secondary)' }}>FRONT</span>
                                <span style={{ position: 'absolute', bottom: '-25px', left: '50%', transform: 'translateX(-50%)', fontSize: '0.7rem', color: 'var(--text-secondary)' }}>BACK</span>
                                <span style={{ position: 'absolute', top: '50%', left: '-35px', transform: 'translateY(-50%)', fontSize: '0.7rem', color: 'var(--text-secondary)' }}>L</span>
                                <span style={{ position: 'absolute', top: '50%', right: '-35px', transform: 'translateY(-50%)', fontSize: '0.7rem', color: 'var(--text-secondary)' }}>R</span>
                            </div>

                            {/* Sound orb - highly visible */}
                            <div style={{
                                position: 'absolute',
                                top: '50%',
                                left: '50%',
                                transform: `translate(calc(-50% + ${orbPosition.x}px), calc(-50% + ${orbPosition.y}px))`,
                                width: '32px',
                                height: '32px',
                                borderRadius: '50%',
                                background: '#ff6b35',
                                border: '3px solid #fff',
                                boxShadow: '0 0 20px #ff6b35, 0 0 40px rgba(255, 107, 53, 0.5), inset 0 0 10px rgba(255,255,255,0.3)',
                                cursor: isDragging ? 'grabbing' : 'grab',
                                transition: isDragging ? 'none' : 'transform 0.1s ease',
                                zIndex: 10
                            }}>
                                {/* Inner glow dot */}
                                <div style={{
                                    position: 'absolute',
                                    top: '50%',
                                    left: '50%',
                                    transform: 'translate(-50%, -50%)',
                                    width: '10px',
                                    height: '10px',
                                    borderRadius: '50%',
                                    background: '#fff'
                                }} />
                            </div>
                        </div>
                        )}

                        {/* Current values display */}
                        <div style={{
                            background: 'rgba(0,0,0,0.3)',
                            borderRadius: '8px',
                            padding: '12px',
                            fontFamily: 'monospace',
                            fontSize: '0.75rem',
                            marginBottom: '16px'
                        }}>
                            <div style={{ marginBottom: '8px', fontWeight: 'bold', color: 'var(--accent)' }}>
                                Position: {getPositionLabel()} ({Math.round(normalizedAngle)}°)
                            </div>
                            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' }}>
                                <div>
                                    <div style={{ color: 'var(--text-secondary)' }}>Pan Position:</div>
                                    <div style={{ color: '#4ade80' }}>{panPosition.toFixed(2)}</div>
                                </div>
                                <div>
                                    <div style={{ color: 'var(--text-secondary)' }}>Depth Mult:</div>
                                    <div style={{ color: '#4ade80' }}>{baseDepthMultiplier.toFixed(2)}</div>
                                </div>
                                <div>
                                    <div style={{ color: 'var(--text-secondary)' }}>Hard L/R Gain:</div>
                                    <div style={{ color: '#f472b6' }}>{hardLeftGain.toFixed(2)} / {hardRightGain.toFixed(2)}</div>
                                </div>
                                <div>
                                    <div style={{ color: 'var(--text-secondary)' }}>ITD L/R Delay:</div>
                                    <div style={{ color: '#f472b6' }}>{(itdLeftDelay * 1000).toFixed(2)}ms / {(itdRightDelay * 1000).toFixed(2)}ms</div>
                                </div>
                                <div>
                                    <div style={{ color: 'var(--text-secondary)' }}>Filter L/R (Hz):</div>
                                    <div style={{ color: '#a78bfa' }}>{Math.round(leftFilterFreq)} / {Math.round(rightFilterFreq)}</div>
                                </div>
                            </div>

                            {/* Ear indicators */}
                            <div style={{ marginTop: '12px', display: 'flex', gap: '16px', justifyContent: 'center' }}>
                                <div style={{ textAlign: 'center' }}>
                                    <div style={{ fontSize: '1.5rem' }}>👂</div>
                                    <div style={{
                                        height: '8px',
                                        width: '60px',
                                        background: 'rgba(255,255,255,0.2)',
                                        borderRadius: '4px',
                                        overflow: 'hidden'
                                    }}>
                                        <div style={{
                                            height: '100%',
                                            width: `${hardLeftGain * 100}%`,
                                            background: '#4ade80',
                                            transition: 'width 0.1s'
                                        }} />
                                    </div>
                                    <div style={{ fontSize: '0.7rem', color: 'var(--text-secondary)' }}>LEFT</div>
                                </div>
                                <div style={{ textAlign: 'center' }}>
                                    <div style={{ fontSize: '1.5rem', transform: 'scaleX(-1)' }}>👂</div>
                                    <div style={{
                                        height: '8px',
                                        width: '60px',
                                        background: 'rgba(255,255,255,0.2)',
                                        borderRadius: '4px',
                                        overflow: 'hidden'
                                    }}>
                                        <div style={{
                                            height: '100%',
                                            width: `${hardRightGain * 100}%`,
                                            background: '#4ade80',
                                            transition: 'width 0.1s'
                                        }} />
                                    </div>
                                    <div style={{ fontSize: '0.7rem', color: 'var(--text-secondary)' }}>RIGHT</div>
                                </div>
                            </div>
                        </div>

                        {/* Spatial Settings - Collapsible */}
                        <div style={{
                            background: 'rgba(0,0,0,0.3)',
                            borderRadius: '8px',
                            marginBottom: '12px',
                            overflow: 'hidden'
                        }}>
                            <button
                                onClick={() => setExpandedSections(prev => ({ ...prev, spatial: !prev.spatial }))}
                                style={{
                                    width: '100%',
                                    padding: '10px 12px',
                                    background: 'transparent',
                                    border: 'none',
                                    color: 'var(--accent)',
                                    cursor: 'pointer',
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center',
                                    fontWeight: '600',
                                    fontSize: '0.85rem'
                                }}
                            >
                                <span>🔊 Spatial Settings</span>
                                <span>{expandedSections.spatial ? '▼' : '▶'}</span>
                            </button>
                            {expandedSections.spatial && (
                        <div style={{
                            padding: '0 12px 12px'
                        }}>
                        <div style={{
                            background: 'rgba(0,0,0,0.3)',
                            borderRadius: '8px',
                            padding: '12px',
                            marginBottom: '16px'
                        }}>
                            {/* Cross Bleed */}
                            <div style={{ marginBottom: '12px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                    <span style={{ color: 'var(--text-secondary)' }}>Cross Bleed (opposite ear)</span>
                                    <span style={{ color: '#4ade80' }}>{(crossBleed * 100).toFixed(0)}%</span>
                                </div>
                                <input
                                    type="range"
                                    min="0"
                                    max="0.3"
                                    step="0.01"
                                    value={crossBleed}
                                    onChange={(e) => setCrossBleed(parseFloat(e.target.value))}
                                    style={{ width: '100%', accentColor: 'var(--accent)' }}
                                />
                                <div style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                    0% = complete isolation, 30% = some bleed to other ear
                                </div>
                            </div>

                            {/* Back Depth */}
                            <div style={{ marginBottom: '12px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                    <span style={{ color: 'var(--text-secondary)' }}>Back Volume</span>
                                    <span style={{ color: '#4ade80' }}>{(backDepth * 100).toFixed(0)}%</span>
                                </div>
                                <input
                                    type="range"
                                    min="0.3"
                                    max="1.0"
                                    step="0.05"
                                    value={backDepth}
                                    onChange={(e) => setBackDepth(parseFloat(e.target.value))}
                                    style={{ width: '100%', accentColor: 'var(--accent)' }}
                                />
                                <div style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                    Volume when sound is behind you (simulates distance)
                                </div>
                            </div>

                            {/* Pan Curve */}
                            <div style={{ marginBottom: '12px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                    <span style={{ color: 'var(--text-secondary)' }}>Pan Aggressiveness</span>
                                    <span style={{ color: '#4ade80' }}>{panCurve.toFixed(1)}x</span>
                                </div>
                                <input
                                    type="range"
                                    min="1"
                                    max="4"
                                    step="0.1"
                                    value={panCurve}
                                    onChange={(e) => setPanCurve(parseFloat(e.target.value))}
                                    style={{ width: '100%', accentColor: 'var(--accent)' }}
                                />
                                <div style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                    Higher = faster L/R separation as orb moves from center
                                </div>
                            </div>

                            {/* Hard Pan Threshold */}
                            <div style={{ marginBottom: '12px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                    <span style={{ color: 'var(--text-secondary)' }}>Center Dead Zone</span>
                                    <span style={{ color: '#4ade80' }}>{(hardPanThreshold * 100).toFixed(0)}%</span>
                                </div>
                                <input
                                    type="range"
                                    min="0"
                                    max="0.5"
                                    step="0.05"
                                    value={hardPanThreshold}
                                    onChange={(e) => setHardPanThreshold(parseFloat(e.target.value))}
                                    style={{ width: '100%', accentColor: 'var(--accent)' }}
                                />
                                <div style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                    Size of center zone where both ears hear equally
                                </div>
                            </div>

                            {/* ITD Amount */}
                            <div style={{ marginBottom: '12px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                    <span style={{ color: 'var(--text-secondary)' }}>Time Delay (ITD)</span>
                                    <span style={{ color: '#f472b6' }}>{(itdAmount * 0.7).toFixed(2)}ms</span>
                                </div>
                                <input
                                    type="range"
                                    min="0"
                                    max="1.5"
                                    step="0.1"
                                    value={itdAmount}
                                    onChange={(e) => setItdAmount(parseFloat(e.target.value))}
                                    style={{ width: '100%', accentColor: '#f472b6' }}
                                />
                                <div style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                    Sound reaches closer ear first (0.7ms is realistic max)
                                </div>
                            </div>

                            {/* Directional Depth */}
                            <div style={{ marginBottom: '12px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                    <span style={{ color: 'var(--text-secondary)' }}>Rear Ear Damping</span>
                                    <span style={{ color: '#f472b6' }}>{(directionalDepth * 100).toFixed(0)}%</span>
                                </div>
                                <input
                                    type="range"
                                    min="0"
                                    max="0.4"
                                    step="0.05"
                                    value={directionalDepth}
                                    onChange={(e) => setDirectionalDepth(parseFloat(e.target.value))}
                                    style={{ width: '100%', accentColor: '#f472b6' }}
                                />
                                <div style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                    Extra quieting when sound is behind that ear (pinna effect)
                                </div>
                            </div>

                            {/* Head Shadow (Low-pass filter) */}
                            <div style={{ marginBottom: '8px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                    <span style={{ color: 'var(--text-secondary)' }}>Head Shadow (Muffling)</span>
                                    <span style={{ color: '#a78bfa' }}>{(headShadow * 100).toFixed(0)}%</span>
                                </div>
                                <input
                                    type="range"
                                    min="0"
                                    max="1"
                                    step="0.1"
                                    value={headShadow}
                                    onChange={(e) => setHeadShadow(parseFloat(e.target.value))}
                                    style={{ width: '100%', accentColor: '#a78bfa' }}
                                />
                                <div style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                    Cuts high frequencies when behind/opposite (darker, muffled sound)
                                </div>
                            </div>

                            {/* Reset Spatial button */}
                            <button
                                onClick={() => {
                                    setCrossBleed(0);
                                    setBackDepth(0.55);
                                    setPanCurve(2.0);
                                    setHardPanThreshold(0.1);
                                    setItdAmount(0.7);
                                    setDirectionalDepth(0.15);
                                    setHeadShadow(0.5);
                                }}
                                style={{
                                    width: '100%',
                                    padding: '8px',
                                    background: 'rgba(255,255,255,0.1)',
                                    border: '1px solid var(--text-secondary)',
                                    borderRadius: '4px',
                                    color: 'var(--text-secondary)',
                                    cursor: 'pointer',
                                    fontSize: '0.75rem'
                                }}
                            >
                                Reset Spatial to Defaults
                            </button>
                        </div>
                            </div>
                        )}
                        </div>

                        {/* EQ Settings - Collapsible */}
                        <div style={{
                            background: 'rgba(0,0,0,0.3)',
                            borderRadius: '8px',
                            marginBottom: '12px',
                            overflow: 'hidden'
                        }}>
                            <button
                                onClick={() => setExpandedSections(prev => ({ ...prev, eq: !prev.eq }))}
                                style={{
                                    width: '100%',
                                    padding: '10px 12px',
                                    background: 'transparent',
                                    border: 'none',
                                    color: '#4ade80',
                                    cursor: 'pointer',
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center',
                                    fontWeight: '600',
                                    fontSize: '0.85rem'
                                }}
                            >
                                <span>🎚️ EQ Settings</span>
                                <span>{expandedSections.eq ? '▼' : '▶'}</span>
                            </button>
                            {expandedSections.eq && (
                            <div style={{ padding: '0 12px 12px' }}>
                                <p style={{ margin: '0 0 12px', fontSize: '0.8rem', color: 'var(--text-secondary)' }}>
                                    Adjust frequency balance to enhance audio clarity.
                                </p>

                            {/* EQ Controls */}
                            <div style={{
                                background: 'rgba(74, 222, 128, 0.1)',
                                padding: '12px',
                                borderRadius: '8px',
                                marginBottom: '8px',
                                border: '1px solid rgba(74, 222, 128, 0.3)'
                            }}>

                                {/* Bass */}
                                <div style={{ marginBottom: '10px' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                        <span style={{ color: 'var(--text-secondary)' }}>Bass (Low)</span>
                                        <span style={{ color: '#4ade80' }}>{eqBass > 0 ? '+' : ''}{eqBass} dB</span>
                                    </div>
                                    <input
                                        type="range"
                                        min="-12"
                                        max="12"
                                        step="1"
                                        value={eqBass}
                                        onChange={(e) => onEqBassChange && onEqBassChange(parseFloat(e.target.value))}
                                        style={{ width: '100%', accentColor: '#4ade80' }}
                                    />
                                </div>

                                {/* Mid */}
                                <div style={{ marginBottom: '10px' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                        <span style={{ color: 'var(--text-secondary)' }}>Mid</span>
                                        <span style={{ color: '#fbbf24' }}>{eqMid > 0 ? '+' : ''}{eqMid} dB</span>
                                    </div>
                                    <input
                                        type="range"
                                        min="-12"
                                        max="12"
                                        step="1"
                                        value={eqMid}
                                        onChange={(e) => onEqMidChange && onEqMidChange(parseFloat(e.target.value))}
                                        style={{ width: '100%', accentColor: '#fbbf24' }}
                                    />
                                </div>

                                {/* Treble */}
                                <div style={{ marginBottom: '10px' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                        <span style={{ color: 'var(--text-secondary)' }}>Treble (High)</span>
                                        <span style={{ color: '#60a5fa' }}>{eqTreble > 0 ? '+' : ''}{eqTreble} dB</span>
                                    </div>
                                    <input
                                        type="range"
                                        min="-12"
                                        max="12"
                                        step="1"
                                        value={eqTreble}
                                        onChange={(e) => onEqTrebleChange && onEqTrebleChange(parseFloat(e.target.value))}
                                        style={{ width: '100%', accentColor: '#60a5fa' }}
                                    />
                                </div>

                                {/* Clarity/Presence */}
                                <div style={{ marginBottom: '8px' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                        <span style={{ color: 'var(--text-secondary)' }}>Clarity (Presence)</span>
                                        <span style={{ color: '#f472b6' }}>{eqClarity > 0 ? '+' : ''}{eqClarity} dB</span>
                                    </div>
                                    <input
                                        type="range"
                                        min="-12"
                                        max="12"
                                        step="1"
                                        value={eqClarity}
                                        onChange={(e) => onEqClarityChange && onEqClarityChange(parseFloat(e.target.value))}
                                        style={{ width: '100%', accentColor: '#f472b6' }}
                                    />
                                    <div style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                        Boosts speech intelligibility range (~2.5kHz)
                                    </div>
                                </div>

                                {/* EQ Reset button */}
                                <button
                                    onClick={() => {
                                        onEqBassChange && onEqBassChange(0);
                                        onEqMidChange && onEqMidChange(0);
                                        onEqTrebleChange && onEqTrebleChange(0);
                                        onEqClarityChange && onEqClarityChange(0);
                                    }}
                                    style={{
                                        width: '100%',
                                        padding: '6px',
                                        background: 'rgba(74, 222, 128, 0.2)',
                                        border: '1px solid rgba(74, 222, 128, 0.5)',
                                        borderRadius: '4px',
                                        color: '#4ade80',
                                        cursor: 'pointer',
                                        fontSize: '0.7rem'
                                    }}
                                >
                                    Reset EQ to Flat
                                </button>
                            </div>
                            </div>
                            )}
                        </div>

                        {/* Copy settings button - Always visible at bottom */}
                        <div style={{ display: 'flex', gap: '8px' }}>
                            <button
                                onClick={() => {
                                    const settings = {
                                        // Current position
                                        panPosition: panPosition.toFixed(3),
                                        depthMultiplier: baseDepthMultiplier.toFixed(2),
                                        hardLeftGain: hardLeftGain.toFixed(3),
                                        hardRightGain: hardRightGain.toFixed(3),
                                        angle: Math.round(normalizedAngle),
                                        position: getPositionLabel(),
                                        // Tuning parameters
                                        tuning: {
                                            crossBleed: crossBleed.toFixed(2),
                                            backDepth: backDepth.toFixed(2),
                                            panCurve: panCurve.toFixed(1),
                                            hardPanThreshold: hardPanThreshold.toFixed(2),
                                            itdAmount: itdAmount.toFixed(2),
                                            directionalDepth: directionalDepth.toFixed(2),
                                            headShadow: headShadow.toFixed(2)
                                        },
                                        // Current ITD delays
                                        itd: {
                                            leftDelayMs: (itdLeftDelay * 1000).toFixed(3),
                                            rightDelayMs: (itdRightDelay * 1000).toFixed(3)
                                        },
                                        // Current filter frequencies
                                        filters: {
                                            leftHz: Math.round(leftFilterFreq),
                                            rightHz: Math.round(rightFilterFreq)
                                        }
                                    };
                                    const text = JSON.stringify(settings, null, 2);
                                    navigator.clipboard.writeText(text);
                                    alert('Settings copied! Paste them to share with the developer.');
                                }}
                                style={{
                                    flex: 1,
                                    padding: '12px',
                                    background: 'var(--accent)',
                                    color: 'white',
                                    border: 'none',
                                    borderRadius: '8px',
                                    cursor: 'pointer',
                                    fontWeight: '600'
                                }}
                            >
                                📋 Copy Settings
                            </button>
                            <button
                                onClick={onClose}
                                style={{
                                    padding: '12px 24px',
                                    background: 'transparent',
                                    color: 'var(--text-primary)',
                                    border: '1px solid var(--text-secondary)',
                                    borderRadius: '8px',
                                    cursor: 'pointer'
                                }}
                            >
                                Close
                            </button>
                        </div>

                        {/* End of Scrollable Content Area */}
                        </div>
                    </div>
                </div>
            );
        };

        // Advanced Controls Component (Story 3-2)
        const AdvancedControls = ({
            // Parameter states (from existing Epic 1 hooks)
            speed, setSpeed,
            intensity, setIntensity,
            spatialDepth, setSpatialDepth,
            movementPattern, setMovementPattern,
            binauralEnabled, setBinauralEnabled,
            binauralFreq, setBinauralFreq,
            noiseType, setNoiseType,
            noiseVolume, setNoiseVolume,
            // UI state
            isExpanded, setIsExpanded,
            sensorLocked, setSensorLocked,
            setA11yAnnouncement,
            // Story 3-3: Save preset handler
            onSavePreset,
            // Spatial tuner
            onOpenTuner
        }) => {
            return (
                <details 
                    open={isExpanded} 
                    onToggle={(e) => setIsExpanded(e.target.open)}
                    className="advanced-controls"
                >
                    <summary>
                        ⚙️ Advanced Controls
                        <kbd>Ctrl+E</kbd>
                    </summary>
                    
                    <div className="controls-grid">
                        {/* Rotation Speed Slider */}
                        <label className="control-group">
                            <span className="control-label">Rotation Speed</span>
                            <div className="control-input">
                                <input 
                                    type="range" 
                                    min={PARAM_RANGES.speed.min} 
                                    max={PARAM_RANGES.speed.max} 
                                    step={PARAM_RANGES.speed.step} 
                                    value={speed} 
                                    onChange={(e) => setSpeed(parseFloat(e.target.value))} 
                                    disabled={sensorLocked}
                                    aria-label="Rotation speed"
                                />
                                <output>{speed.toFixed(2)}</output>
                            </div>
                            <span className="control-hint">How fast sound orbits your head</span>
                        </label>
                        
                        {/* Intensity Slider */}
                        <label className="control-group">
                            <span className="control-label">Intensity</span>
                            <div className="control-input">
                                <input 
                                    type="range" 
                                    min={PARAM_RANGES.intensity.min} 
                                    max={PARAM_RANGES.intensity.max} 
                                    step={PARAM_RANGES.intensity.step} 
                                    value={intensity} 
                                    onChange={(e) => setIntensity(parseFloat(e.target.value))} 
                                    disabled={sensorLocked}
                                    aria-label="Intensity"
                                />
                                <output>{intensity.toFixed(2)}</output>
                            </div>
                            <span className="control-hint">Strength of 8D effect</span>
                        </label>
                        
                        {/* Spatial Depth Slider */}
                        <label className="control-group">
                            <span className="control-label">Spatial Depth</span>
                            <div className="control-input">
                                <input 
                                    type="range" 
                                    min={PARAM_RANGES.spatialDepth.min} 
                                    max={PARAM_RANGES.spatialDepth.max} 
                                    step={PARAM_RANGES.spatialDepth.step} 
                                    value={spatialDepth} 
                                    onChange={(e) => setSpatialDepth(parseFloat(e.target.value))} 
                                    disabled={sensorLocked}
                                    aria-label="Spatial depth"
                                />
                                <output>{spatialDepth.toFixed(2)}</output>
                            </div>
                            <span className="control-hint">Front/back positioning</span>
                        </label>
                        
                        {/* Movement Pattern Dropdown */}
                        <label className="control-group">
                            <span className="control-label">Movement Pattern</span>
                            <div className="control-input">
                                <select 
                                    value={movementPattern} 
                                    onChange={(e) => setMovementPattern(e.target.value)}
                                    disabled={sensorLocked}
                                    aria-label="Movement pattern"
                                >
                                    <option value="circle">Circle - Steady orbit</option>
                                    <option value="figure8">Figure-8 - Gentle sway</option>
                                    <option value="leftright">Left-Right - Side-to-side</option>
                                    <option value="frontback">Front-Back - Forward-backward</option>
                                    <option value="random">Random - Unpredictable</option>
                                </select>
                            </div>
                            <span className="control-hint">Path sound travels around you</span>
                        </label>
                        
                        {/* Binaural Beats Checkbox */}
                        <label className="control-group checkbox-group">
                            <input 
                                type="checkbox" 
                                checked={binauralEnabled} 
                                onChange={(e) => setBinauralEnabled(e.target.checked)}
                                disabled={sensorLocked}
                                aria-label="Enable binaural beats"
                            />
                            <span className="control-label">Binaural Beats</span>
                        </label>
                        
                        {/* Binaural Frequency Slider (conditional) */}
                        {binauralEnabled && (
                            <label className="control-group">
                                <span className="control-label">Binaural Frequency</span>
                                <div className="control-input">
                                    <input 
                                        type="range" 
                                        min={PARAM_RANGES.binauralFreq.min} 
                                        max={PARAM_RANGES.binauralFreq.max} 
                                        step={PARAM_RANGES.binauralFreq.step} 
                                        value={binauralFreq} 
                                        onChange={(e) => setBinauralFreq(parseInt(e.target.value))} 
                                        disabled={sensorLocked}
                                        aria-label="Binaural frequency"
                                    />
                                    <output>
                                        {binauralFreq} Hz 
                                        <span className="freq-band">({getBinauralBand(binauralFreq)})</span>
                                    </output>
                                </div>
                                <span className="control-hint">{getBinauralHint(binauralFreq)}</span>
                            </label>
                        )}
                        
                        {/* Noise Type Dropdown */}
                        <label className="control-group">
                            <span className="control-label">Noise Type</span>
                            <div className="control-input">
                                <select 
                                    value={noiseType} 
                                    onChange={(e) => setNoiseType(e.target.value)}
                                    disabled={sensorLocked}
                                    aria-label="Noise type"
                                >
                                    <option value="pink">Pink - Balanced warmth</option>
                                    <option value="white">White - Crisp static</option>
                                    <option value="brown">Brown - Deep rumble</option>
                                </select>
                            </div>
                            <span className="control-hint">Background noise texture</span>
                        </label>
                        
                        {/* Noise Volume Slider */}
                        <label className="control-group">
                            <span className="control-label">Noise Volume</span>
                            <div className="control-input">
                                <input 
                                    type="range" 
                                    min={PARAM_RANGES.noiseVolume.min} 
                                    max={PARAM_RANGES.noiseVolume.max} 
                                    step={PARAM_RANGES.noiseVolume.step} 
                                    value={noiseVolume} 
                                    onChange={(e) => setNoiseVolume(parseFloat(e.target.value))} 
                                    disabled={sensorLocked}
                                    aria-label="Noise volume"
                                />
                                <output>{noiseVolume.toFixed(2)}</output>
                            </div>
                            <span className="control-hint">Loudness of background noise</span>
                        </label>
                    </div>
                    
                    {/* Story 3-3: Save Preset Button */}
                    {!sensorLocked && onSavePreset && (
                        <button
                            type="button"
                            onClick={onSavePreset}
                            className="primary-btn"
                            style={{ marginTop: '16px', width: '100%' }}
                            aria-label="Save current parameters as custom preset"
                        >
                            💾 Save as Custom Preset
                        </button>
                    )}

                    {/* Spatial Audio Tuner Button */}
                    {onOpenTuner && (
                        <button
                            type="button"
                            onClick={onOpenTuner}
                            style={{
                                marginTop: '8px',
                                width: '100%',
                                padding: '12px',
                                background: 'rgba(255,255,255,0.1)',
                                border: '1px dashed var(--text-secondary)',
                                borderRadius: '8px',
                                color: 'var(--text-primary)',
                                cursor: 'pointer',
                                fontSize: '0.875rem'
                            }}
                            aria-label="Open spatial audio tuner"
                        >
                            🎯 Open Spatial Tuner (Debug)
                        </button>
                    )}

                    {/* Sensor Lock Notice */}
                    {sensorLocked && (
                        <div className="sensor-lock-notice" role="status" aria-live="polite">
                            <span className="lock-icon">🔒</span>
                            <span className="lock-message">Parameters locked by adaptive mode</span>
                            <button 
                                onClick={() => {
                                    setSensorLocked(false);
                                    setA11yAnnouncement('Adaptive mode disabled. Controls unlocked.');
                                }}
                                className="unlock-btn"
                            >
                                Unlock Manual Control
                            </button>
                        </div>
                    )}
                </details>
            );
        };

        // ============================================================
        // Story 3-3: Save Preset Dialog Component
        // ============================================================
        
        const SavePresetDialog = ({ 
            currentParameters, 
            onSave, 
            onCancel,
            showToast,
            setA11yAnnouncement,
            existingPreset = null // for edit mode
        }) => {
            const [name, setName] = useState(existingPreset?.name || '');
            const [description, setDescription] = useState(existingPreset?.description || '');
            const [color, setColor] = useState(existingPreset?.color || '#6366f1');
            const [errors, setErrors] = useState({});
            
            const validate = () => {
                const newErrors = {};
                
                if (!name.trim()) {
                    newErrors.name = 'Preset name is required';
                } else if (name.length > 50) {
                    newErrors.name = 'Name too long (max 50 characters)';
                }
                
                if (description.length > 200) {
                    newErrors.description = 'Description too long (max 200 characters)';
                }
                
                // Validate color hex format
                const hexPattern = /^#[0-9A-Fa-f]{6}$/;
                if (!hexPattern.test(color)) {
                    newErrors.color = 'Invalid color format (use #RRGGBB)';
                }
                
                setErrors(newErrors);
                return Object.keys(newErrors).length === 0;
            };
            
            const handleSave = () => {
                if (!validate()) return;
                
                const presetData = {
                    name: name.trim(),
                    description: description.trim(),
                    color,
                    ...currentParameters
                };
                
                let presetId;
                if (existingPreset) {
                    // Edit mode
                    const success = updateCustomPreset(existingPreset.id, presetData, showToast);
                    if (success) {
                        presetId = existingPreset.id;
                        showToast(`Preset "${name}" updated`, 'success');
                        setA11yAnnouncement(`Preset ${name} updated`);
                    }
                } else {
                    // Create mode
                    presetId = saveCustomPreset(presetData, showToast);
                    if (presetId) {
                        showToast(`Preset "${name}" saved`, 'success');
                        setA11yAnnouncement(`Preset ${name} saved`);
                    }
                }
                
                if (presetId) {
                    onSave(presetId);
                }
            };
            
            // Handle Escape key to close dialog
            useEffect(() => {
                const handleEscape = (e) => {
                    if (e.key === 'Escape') onCancel();
                };
                document.addEventListener('keydown', handleEscape);
                return () => document.removeEventListener('keydown', handleEscape);
            }, [onCancel]);
            
            return (
                <div 
                    className="dialog-overlay" 
                    onClick={onCancel}
                    role="dialog"
                    aria-modal="true"
                    aria-labelledby="dialog-title"
                >
                    <div 
                        className="dialog-content" 
                        onClick={(e) => e.stopPropagation()}
                        style={{
                            backgroundColor: 'var(--bg-primary)',
                            padding: '24px',
                            borderRadius: '12px',
                            maxWidth: '500px',
                            width: '90%',
                            maxHeight: '80vh',
                            overflow: 'auto'
                        }}
                    >
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
                            {/* React JSX automatically escapes user input, preventing XSS attacks */}
                            <h2 id="dialog-title" style={{ margin: 0 }}>
                                {existingPreset ? 'Edit Preset' : 'Save Custom Preset'}
                            </h2>
                            <button 
                                onClick={onCancel} 
                                aria-label="Close dialog" 
                                style={{
                                    background: 'none',
                                    border: 'none',
                                    fontSize: '24px',
                                    cursor: 'pointer',
                                    color: 'var(--text-secondary)'
                                }}
                            >
                                ×
                            </button>
                        </div>
                        
                        <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
                            {/* Preset Name */}
                            <label style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                <span style={{ fontWeight: '500', color: errors.name ? '#f87171' : 'inherit' }}>
                                    Preset Name *
                                </span>
                                <input 
                                    type="text" 
                                    value={name} 
                                    onChange={(e) => setName(e.target.value)} 
                                    placeholder="e.g., Deep Flow"
                                    maxLength={50}
                                    required
                                    autoFocus
                                    aria-invalid={!!errors.name}
                                    aria-describedby={errors.name ? 'name-error' : undefined}
                                    style={{
                                        padding: '8px 12px',
                                        borderRadius: '6px',
                                        border: `1px solid ${errors.name ? '#f87171' : 'var(--border)'}`,
                                        backgroundColor: 'var(--bg-secondary)',
                                        color: 'var(--text-primary)'
                                    }}
                                />
                                {errors.name && (
                                    <span id="name-error" style={{ color: '#f87171', fontSize: '0.875rem' }}>
                                        {errors.name}
                                    </span>
                                )}
                                <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', textAlign: 'right' }}>
                                    {name.length}/50
                                </span>
                            </label>
                            
                            {/* Description */}
                            <label style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                <span style={{ fontWeight: '500', color: errors.description ? '#f87171' : 'inherit' }}>
                                    Description (optional)
                                </span>
                                <textarea 
                                    value={description} 
                                    onChange={(e) => setDescription(e.target.value)} 
                                    placeholder="My perfect focus state"
                                    maxLength={200}
                                    rows={3}
                                    aria-invalid={!!errors.description}
                                    aria-describedby={errors.description ? 'desc-error' : undefined}
                                    style={{
                                        padding: '8px 12px',
                                        borderRadius: '6px',
                                        border: `1px solid ${errors.description ? '#f87171' : 'var(--border)'}`,
                                        backgroundColor: 'var(--bg-secondary)',
                                        color: 'var(--text-primary)',
                                        fontFamily: 'inherit',
                                        resize: 'vertical'
                                    }}
                                />
                                {errors.description && (
                                    <span id="desc-error" style={{ color: '#f87171', fontSize: '0.875rem' }}>
                                        {errors.description}
                                    </span>
                                )}
                                <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', textAlign: 'right' }}>
                                    {description.length}/200
                                </span>
                            </label>
                            
                            {/* Color Picker */}
                            <label style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                <span style={{ fontWeight: '500', color: errors.color ? '#f87171' : 'inherit' }}>
                                    Accent Color
                                </span>
                                <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
                                    <input 
                                        type="color" 
                                        value={color} 
                                        onChange={(e) => setColor(e.target.value)}
                                        style={{ width: '48px', height: '48px', cursor: 'pointer' }}
                                    />
                                    <input 
                                        type="text" 
                                        value={color} 
                                        onChange={(e) => setColor(e.target.value)} 
                                        placeholder="#6366f1"
                                        pattern="^#[0-9A-Fa-f]{6}$"
                                        aria-invalid={!!errors.color}
                                        aria-describedby={errors.color ? 'color-error' : undefined}
                                        style={{
                                            padding: '8px 12px',
                                            borderRadius: '6px',
                                            border: `1px solid ${errors.color ? '#f87171' : 'var(--border)'}`,
                                            backgroundColor: 'var(--bg-secondary)',
                                            color: 'var(--text-primary)',
                                            flex: 1
                                        }}
                                    />
                                </div>
                                {errors.color && (
                                    <span id="color-error" style={{ color: '#f87171', fontSize: '0.875rem' }}>
                                        {errors.color}
                                    </span>
                                )}
                            </label>
                            
                            {/* Parameter Preview */}
                            <div style={{ 
                                padding: '12px', 
                                borderRadius: '8px', 
                                backgroundColor: 'var(--bg-secondary)',
                                border: '1px solid var(--border)'
                            }}>
                                <h3 style={{ margin: '0 0 12px 0', fontSize: '0.875rem', fontWeight: '600' }}>
                                    Current Parameters
                                </h3>
                                <div style={{ 
                                    display: 'grid', 
                                    gridTemplateColumns: 'auto 1fr', 
                                    gap: '4px 12px',
                                    fontSize: '0.875rem'
                                }}>
                                    <dt style={{ fontWeight: '500', color: 'var(--text-secondary)' }}>Speed:</dt>
                                    <dd style={{ margin: 0 }}>{currentParameters.speed.toFixed(2)}</dd>
                                    
                                    <dt style={{ fontWeight: '500', color: 'var(--text-secondary)' }}>Intensity:</dt>
                                    <dd style={{ margin: 0 }}>{currentParameters.intensity.toFixed(2)}</dd>
                                    
                                    <dt style={{ fontWeight: '500', color: 'var(--text-secondary)' }}>Spatial Depth:</dt>
                                    <dd style={{ margin: 0 }}>{currentParameters.spatialDepth.toFixed(2)}</dd>
                                    
                                    <dt style={{ fontWeight: '500', color: 'var(--text-secondary)' }}>Movement:</dt>
                                    <dd style={{ margin: 0 }}>{currentParameters.movement}</dd>
                                    
                                    <dt style={{ fontWeight: '500', color: 'var(--text-secondary)' }}>Binaural:</dt>
                                    <dd style={{ margin: 0 }}>
                                        {currentParameters.binauralEnabled 
                                            ? `${currentParameters.binauralFreq} Hz (${getBinauralBand(currentParameters.binauralFreq)})` 
                                            : 'Off'}
                                    </dd>
                                    
                                    <dt style={{ fontWeight: '500', color: 'var(--text-secondary)' }}>Noise:</dt>
                                    <dd style={{ margin: 0 }}>
                                        {currentParameters.noiseType} @ {(currentParameters.noiseVolume * 100).toFixed(0)}%
                                    </dd>
                                </div>
                            </div>
                        </div>
                        
                        {/* Dialog Actions */}
                        <div style={{ display: 'flex', gap: '8px', marginTop: '20px', justifyContent: 'flex-end' }}>
                            <button 
                                onClick={onCancel} 
                                className="ghost-btn"
                            >
                                Cancel
                            </button>
                            <button 
                                onClick={handleSave} 
                                disabled={!name.trim()} 
                                className="primary-btn"
                            >
                                {existingPreset ? 'Update' : 'Save'} Preset
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // ============================================================
        // Story 3-3: PresetList Component
        // ============================================================

        const PresetList = ({
            presets,
            activePresetId,
            onSelect,
            onEdit,
            onDelete,
            onReorder
        }) => {
            const [draggedIndex, setDraggedIndex] = useState(null);

            const handleDragStart = (e, index) => {
                setDraggedIndex(index);
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleDragOver = (e, index) => {
                e.preventDefault();
                if (draggedIndex === null || draggedIndex === index) return;

                const newPresets = [...presets];
                const [removed] = newPresets.splice(draggedIndex, 1);
                newPresets.splice(index, 0, removed);

                onReorder(newPresets.map(p => p.id));
                setDraggedIndex(index);
            };

            const handleDragEnd = () => {
                setDraggedIndex(null);
            };

            const handlePresetKeyDown = (e, preset) => {
                // Handle Ctrl+ArrowUp/Down for reordering (AC5)
                if (e.ctrlKey && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
                    e.preventDefault();

                    const currentIndex = presets.findIndex(p => p.id === preset.id);
                    if (currentIndex === -1) return;

                    let newIndex;
                    if (e.key === 'ArrowUp') {
                        // Can't move above first custom preset (defaults are immutable)
                        const firstCustomIndex = presets.findIndex(p => !p.isDefault);
                        if (currentIndex <= firstCustomIndex) return;
                        newIndex = currentIndex - 1;
                    } else { // ArrowDown
                        if (currentIndex >= presets.length - 1) return;
                        newIndex = currentIndex + 1;
                    }

                    const newPresets = [...presets];
                    [newPresets[currentIndex], newPresets[newIndex]] = [newPresets[newIndex], newPresets[currentIndex]];
                    onReorder(newPresets.map(p => p.id));
                    return;
                }

                // Handle ArrowUp/Down for navigation (AC2)
                if (!e.ctrlKey && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
                    e.preventDefault();

                    // Find all focusable preset cards
                    const presetCards = Array.from(document.querySelectorAll('.preset-card[tabindex="0"]'));
                    const currentCard = e.currentTarget;
                    const currentCardIndex = presetCards.indexOf(currentCard);

                    if (currentCardIndex === -1) return;

                    let nextCard;
                    if (e.key === 'ArrowUp' && currentCardIndex > 0) {
                        nextCard = presetCards[currentCardIndex - 1];
                    } else if (e.key === 'ArrowDown' && currentCardIndex < presetCards.length - 1) {
                        nextCard = presetCards[currentCardIndex + 1];
                    }

                    if (nextCard) {
                        nextCard.focus();
                    }
                    return;
                }

                // Handle Enter to apply preset (AC2)
                if (e.key === 'Enter') {
                    e.preventDefault();
                    onSelect(preset.id);
                }
            };

            const formatLastUsed = (timestamp) => {
                if (!timestamp) return 'Never used';
                const hours = Math.floor((Date.now() - timestamp) / 1000 / 60 / 60);
                if (hours < 1) return 'Just now';
                if (hours < 24) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
                const days = Math.floor(hours / 24);
                return `${days} day${days > 1 ? 's' : ''} ago`;
            };

            return (
                <div className="preset-list-section" style={{ marginTop: '16px', paddingTop: '16px', borderTop: '1px solid var(--border)' }}>
                    <h3 style={{ fontSize: '0.875rem', fontWeight: '600', marginBottom: '12px', color: 'var(--text-secondary)' }}>
                        Your Custom Presets
                    </h3>

                    <div className="preset-list" role="list">
                        {presets.filter(p => !p.isDefault).length === 0 ? (
                            <div style={{
                                padding: '20px',
                                textAlign: 'center',
                                color: 'var(--text-secondary)',
                                backgroundColor: 'var(--bg-secondary)',
                                borderRadius: '8px',
                                fontSize: '0.875rem'
                            }}>
                                <p style={{ margin: '0 0 8px 0' }}>No custom presets yet.</p>
                                <p style={{ margin: 0 }}>Tweak parameters and click "Save Preset" to create your first!</p>
                            </div>
                        ) : (
                            presets.filter(p => !p.isDefault).map((preset, index) => (
                                <div
                                    key={preset.id}
                                    className={`preset-card ${preset.id === activePresetId ? 'active' : ''}`}
                                    role="listitem"
                                    tabIndex={0}
                                    draggable={true}
                                    onDragStart={(e) => handleDragStart(e, index)}
                                    onDragOver={(e) => handleDragOver(e, index)}
                                    onDragEnd={handleDragEnd}
                                    onKeyDown={(e) => handlePresetKeyDown(e, preset)}
                                    style={{
                                        '--accent-color': preset.color,
                                        marginBottom: '8px',
                                        padding: '12px',
                                        backgroundColor: preset.id === activePresetId ? 'var(--bg-secondary)' : 'var(--bg-primary)',
                                        border: `1px solid ${preset.id === activePresetId ? 'var(--accent)' : 'var(--border)'}`,
                                        borderRadius: '8px',
                                        cursor: 'grab',
                                        position: 'relative'
                                    }}
                                >
                                    <div style={{ display: 'flex', gap: '12px', alignItems: 'flex-start' }}>
                                        <div className="drag-handle" aria-label="Drag to reorder" style={{
                                            cursor: 'grab',
                                            color: 'var(--text-tertiary)',
                                            fontSize: '1rem',
                                            lineHeight: '1'
                                        }}>
                                            ⋮⋮
                                        </div>

                                        <div style={{ flex: 1 }}>
                                            <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '4px' }}>
                                                <h4 style={{ margin: 0, fontSize: '0.875rem', fontWeight: '600' }}>{preset.name}</h4>
                                                {preset.id === activePresetId && (
                                                    <span style={{
                                                        fontSize: '0.75rem',
                                                        padding: '2px 6px',
                                                        backgroundColor: 'var(--accent)',
                                                        color: 'white',
                                                        borderRadius: '4px',
                                                        fontWeight: '500'
                                                    }}>
                                                        Active
                                                    </span>
                                                )}
                                                {preset.isDefault && (
                                                    <span style={{
                                                        fontSize: '0.75rem',
                                                        padding: '2px 6px',
                                                        backgroundColor: 'var(--border)',
                                                        color: 'var(--text-secondary)',
                                                        borderRadius: '4px',
                                                        fontWeight: '500'
                                                    }}>
                                                        Default
                                                    </span>
                                                )}
                                            </div>

                                            {preset.description && (
                                                <p style={{
                                                    margin: '4px 0',
                                                    fontSize: '0.8125rem',
                                                    color: 'var(--text-secondary)',
                                                    lineHeight: '1.4'
                                                }}>
                                                    {preset.description}
                                                </p>
                                            )}

                                            <div style={{
                                                display: 'flex',
                                                alignItems: 'center',
                                                justifyContent: 'space-between',
                                                marginTop: '8px'
                                            }}>
                                                <span style={{ fontSize: '0.75rem', color: 'var(--text-tertiary)' }}>
                                                    Last used: {formatLastUsed(preset.lastUsedAt)}
                                                </span>
                                                <div style={{ display: 'flex', gap: '6px' }}>
                                                    <button
                                                        className="ghost-btn"
                                                        style={{ fontSize: '0.75rem', padding: '4px 8px' }}
                                                        onClick={() => onSelect(preset.id)}
                                                        disabled={preset.id === activePresetId}
                                                    >
                                                        {preset.id === activePresetId ? '✓ Active' : 'Apply'}
                                                    </button>
                                                    <button
                                                        onClick={() => onEdit(preset)}
                                                        aria-label={`Edit ${preset.name}`}
                                                        className="ghost-btn"
                                                        style={{ fontSize: '0.75rem', padding: '4px 8px' }}
                                                    >
                                                        ✏️
                                                    </button>
                                                    <button
                                                        onClick={() => onDelete(preset.id)}
                                                        aria-label={`Delete ${preset.name}`}
                                                        className="ghost-btn"
                                                        style={{ fontSize: '0.75rem', padding: '4px 8px', color: '#ef4444' }}
                                                    >
                                                        🗑️
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            ))
                        )}
                    </div>
                </div>
            );
        };

function App() {
            const defaultMode = MODE_LIBRARY[0];
            const [playlist, setPlaylist] = useState([]);
            const [currentTrackIndex, setCurrentTrackIndex] = useState(null);
            // Track ratings: { trackId: { modeId: 'boost'|'neutral'|'remove' } }
            // Persisted to localStorage, keyed by track name since URLs can change
            const [trackRatings, setTrackRatings] = useState(() => {
                try {
                    const saved = localStorage.getItem('mpe_8d_track_ratings');
                    return saved ? JSON.parse(saved) : {};
                } catch { return {}; }
            });
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentTime, setCurrentTime] = useState(0);
            const [duration, setDuration] = useState(0);
            const [volume, setVolume] = useState(0.7);
            const [showFileWarning, setShowFileWarning] = useState(false);
            
            // 8D Effect Controls
            const [speed, setSpeed] = useState(defaultMode.preset.speed);
            const [intensity, setIntensity] = useState(defaultMode.preset.intensity);
            const [spatialDepth, setSpatialDepth] = useState(defaultMode.preset.spatialDepth);
            const [movementPattern, setMovementPattern] = useState(defaultMode.preset.movement);
            
            // Additional Effects
            const [binauralEnabled, setBinauralEnabled] = useState(defaultMode.preset.binaural.enabled);
            const [binauralFreq, setBinauralFreq] = useState(defaultMode.preset.binaural.freq);
            const [noiseType, setNoiseType] = useState(defaultMode.preset.noise.type);
            const [noiseVolume, setNoiseVolume] = useState(defaultMode.preset.noise.volume);
            const [visualWaveGain, setVisualWaveGain] = useState(defaultMode.preset.noise.volume);

            // EQ Settings (dB values, -12 to +12) - Load from saved calibration
            const [eqBass, setEqBass] = useState(() => {
                try {
                    const saved = localStorage.getItem('mpe_8d_calibration');
                    if (saved) {
                        const data = JSON.parse(saved);
                        return data.eq?.bass ?? 0;
                    }
                } catch {}
                return 0;
            });
            const [eqMid, setEqMid] = useState(() => {
                try {
                    const saved = localStorage.getItem('mpe_8d_calibration');
                    if (saved) {
                        const data = JSON.parse(saved);
                        return data.eq?.mid ?? 0;
                    }
                } catch {}
                return 0;
            });
            const [eqTreble, setEqTreble] = useState(() => {
                try {
                    const saved = localStorage.getItem('mpe_8d_calibration');
                    if (saved) {
                        const data = JSON.parse(saved);
                        return data.eq?.treble ?? 0;
                    }
                } catch {}
                return 0;
            });
            const [eqClarity, setEqClarity] = useState(() => {
                try {
                    const saved = localStorage.getItem('mpe_8d_calibration');
                    if (saved) {
                        const data = JSON.parse(saved);
                        return data.eq?.clarity ?? 0;
                    }
                } catch {}
                return 0;
            });

            // UI + Ritual
            const [darkMode, setDarkMode] = useState(false);
            const [highContrast, setHighContrast] = useState(false);
            const [urlInput, setUrlInput] = useState('');
            const [showVisualizer, setShowVisualizer] = useState(true);
            const [visualizerFullscreen, setVisualizerFullscreen] = useState(false);
            const [visualizerType, setVisualizerType] = useState('bars'); // bars, waveform, circular, mirrored, particles

            // Timer states
            const [activeTimerTab, setActiveTimerTab] = useState('sleep'); // 'sleep' or 'pomodoro'

            // Sleep timer state
            const [sleepTimerActive, setSleepTimerActive] = useState(false);
            const [sleepTimerSeconds, setSleepTimerSeconds] = useState(0);
            const [sleepTimerDuration, setSleepTimerDuration] = useState(60 * 60); // Default 1 hour

            // Pomodoro timer state
            const [pomodoroActive, setPomodoroActive] = useState(false);
            const [pomodoroPhase, setPomodoroPhase] = useState('work'); // 'work' or 'break'
            const [pomodoroSeconds, setPomodoroSeconds] = useState(0);
            const [pomodoroWorkDuration, setPomodoroWorkDuration] = useState(25); // minutes
            const [pomodoroBreakDuration, setPomodoroBreakDuration] = useState(5); // minutes
            const [pomodoroCycles, setPomodoroCycles] = useState(0);
            const [pomodoroBreakAction, setPomodoroBreakAction] = useState('pause'); // 'pause', 'energize', 'calm'

            // Playlist search
            const [playlistSearch, setPlaylistSearch] = useState('');

            // Saved playlists
            const [savedPlaylists, setSavedPlaylists] = useState(() => {
                try {
                    const saved = localStorage.getItem('mpe_8d_saved_playlists');
                    return saved ? JSON.parse(saved) : [];
                } catch { return []; }
            });
            const [showPlaylistModal, setShowPlaylistModal] = useState(false);
            const [newPlaylistName, setNewPlaylistName] = useState('');

            // Mobile navigation
            const [mobileView, setMobileView] = useState('timer'); // 'timer', 'queue', 'settings'
            const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
            const [vizMenuOpen, setVizMenuOpen] = useState(false);

            const [modeIndex, setModeIndex] = useState(0);
            const [focusedModeIndex, setFocusedModeIndex] = useState(0);
            const [activePresetId, setActivePresetId] = useState('focus'); // Story 3-1: Track active preset by ID
            const [ritualStatus, setRitualStatus] = useState('idle');
            const [ritualCountdown, setRitualCountdown] = useState(HERO_BREATH_DURATION);
            const [breathingPhase, setBreathingPhase] = useState(''); // 'inhale', 'hold-in', 'exhale', 'hold-out'
            const [skipRitualPref, setSkipRitualPref] = useState(() => {
                try {
                    return localStorage.getItem('skipBreathingRitual') === 'true';
                } catch {
                    return false;
                }
            });
            const [heroMessage, setHeroMessage] = useState('Select a ritual to begin');
            const [a11yAnnouncement, setA11yAnnouncement] = useState('');
            const [needsAudio, setNeedsAudio] = useState(false);
            const [intakeTab, setIntakeTab] = useState('files');
            const [isOnline, setIsOnline] = useState(typeof navigator !== 'undefined' ? navigator.onLine : true);
            const [reducedMotion, setReducedMotion] = useState(false);
            const [dragActive, setDragActive] = useState(false);
            const [audioElementToken, setAudioElementToken] = useState(0);
            
            // Story 3-2: Advanced Controls UI state
            const [isAdvancedControlsExpanded, setIsAdvancedControlsExpanded] = useState(false);
            const [sensorLocked, setSensorLocked] = useState(false); // Epic 5 adaptive mode
            
            // Story 3-3: Custom Preset Management
            const [showSavePresetDialog, setShowSavePresetDialog] = useState(false);
            const [editingPreset, setEditingPreset] = useState(null);
            const [allPresets, setAllPresets] = useState([]);

            // Spatial Audio Tuner (debugging tool)
            const [showSpatialTuner, setShowSpatialTuner] = useState(false);
            const spatialTunerActiveRef = useRef(false);

            // Calibration Wizard - first run prompt
            const [showFirstRunPrompt, setShowFirstRunPrompt] = useState(false);
            const [hasRunCalibration, setHasRunCalibration] = useState(() => {
                try {
                    return localStorage.getItem('mpe_8d_calibration') !== null;
                } catch {
                    return false;
                }
            });
            const [calibrationDismissed, setCalibrationDismissed] = useState(() => {
                try {
                    return localStorage.getItem('mpe_8d_calibration_dismissed') === 'true';
                } catch {
                    return false;
                }
            });

            // File intake notifications
            const [toastMessage, setToastMessage] = useState('');
            const [toastType, setToastType] = useState('info');
            const [isProcessingFiles, setIsProcessingFiles] = useState(false);
            const [isValidatingUrl, setIsValidatingUrl] = useState(false);

            const showToast = React.useCallback((message, type = 'info') => {
                if (toastTimeoutRef.current) {
                    clearTimeout(toastTimeoutRef.current);
                }

                setToastMessage(message);
                setToastType(type);
                setA11yAnnouncement(message);

                toastTimeoutRef.current = setTimeout(() => {
                    setToastMessage('');
                    toastTimeoutRef.current = null;
                }, 5000);
            }, []);

            const [activeSessionId, setActiveSessionId] = useState(null);
            const [isClearingSessions, setIsClearingSessions] = useState(false);
            const [isTrimmingSessions, setIsTrimmingSessions] = useState(false);
            
            const selectedMode = MODE_LIBRARY[modeIndex];
            const nowPlayingTrack = currentTrackIndex !== null ? playlist[currentTrackIndex] : null;

            // Parse track name for artist/title (supports "Artist - Title" format)
            const parseTrackInfo = (track) => {
                if (!track) {
                    return { title: 'No track selected', artist: null, source: null };
                }

                const name = track.name || 'Unknown Track';
                const source = track.source || 'unknown';

                // Common patterns: "Artist - Title", "Artist — Title", "Artist – Title"
                const separators = [' - ', ' — ', ' – ', ' _ '];
                for (const sep of separators) {
                    if (name.includes(sep)) {
                        const parts = name.split(sep);
                        if (parts.length >= 2) {
                            return {
                                artist: parts[0].trim(),
                                title: parts.slice(1).join(sep).trim(),
                                source
                            };
                        }
                    }
                }

                // No artist found, just use the name as title
                return { title: name, artist: null, source };
            };

            const trackInfo = parseTrackInfo(nowPlayingTrack);

            // Get mode-specific album art icon
            const getAlbumArtIcon = () => {
                const modeIcons = {
                    focus: '🎯',
                    calm: '🌊',
                    energize: '⚡',
                    'apd-friendly': '🔮'
                };
                return modeIcons[activePresetId] || '🎵';
            };

            const playlistMinutes = Math.max(0, Math.floor(playlist.length * 3.5));
            const focusConfidence = Math.min(100, 60 + playlist.length * 8);
            const streakMinutes = Math.min(21, playlist.length * 2);
            
            // Refs
            const audioContextRef = useRef(null);
            const sourceNodeRef = useRef(null);
            const gainNodeRef = useRef(null);
            const audioElementRef = useRef(null);
            const audioEndedHandlerRef = useRef(null);
            const currentBlobUrlRef = useRef(null);
            const fileInputRef = useRef(null);
            const canvasRef = useRef(null);
            const mobileCanvasRef = useRef(null);
            const fullscreenCanvasRef = useRef(null);
            const analyserRef = useRef(null);
            const animationFrameRef = useRef(null);
            const rotationIntervalRef = useRef(null);
            const rotationNodesRef = useRef(null);
            const eqNodesRef = useRef(null); // EQ filters: bass, mid, treble, clarity
            const modeRefs = useRef([]);
            const dropZoneRef = useRef(null);
            const ritualTimeoutRef = useRef(null);
            const ritualIntervalRef = useRef(null);
            const breathingPhaseIntervalRef = useRef(null);
            const gainChainRef = useRef(null);
            const binauralNodesRef = useRef(null);
            const noiseNodesRef = useRef(null);
            const visualWaveGainRef = useRef(visualWaveGain);
            const visualizerTypeRef = useRef(visualizerType);
            const playlistRef = useRef(playlist);
            const currentTrackIndexRef = useRef(currentTrackIndex);
            const playNextRef = useRef(() => {});
            const prevPlaylistLengthRef = useRef(playlist.length);
            const urlValidationControllerRef = useRef(null);
            const toastTimeoutRef = useRef(null);
            const activeSessionIdRef = useRef(null);
            const sessionRitualFlagRef = useRef(false);
            const sleepTimerIntervalRef = useRef(null);
            const pomodoroIntervalRef = useRef(null);
            const previousModeRef = useRef(null); // For restoring mode after pomodoro break

            // Audio parameter refs - allows rotation interval to read current values
            const speedRef = useRef(speed);
            const intensityRef = useRef(intensity);
            const spatialDepthRef = useRef(spatialDepth);
            const movementPatternRef = useRef(movementPattern);

            const cleanupBlobUrl = () => {
                if (currentBlobUrlRef.current) {
                    URL.revokeObjectURL(currentBlobUrlRef.current);
                    currentBlobUrlRef.current = null;
                }
            };

            const tearDownBinauralNodes = () => {
                if (binauralNodesRef.current) {
                    binauralNodesRef.current.stop();
                    binauralNodesRef.current = null;
                }
            };

            const tearDownNoiseNodes = () => {
                if (noiseNodesRef.current) {
                    noiseNodesRef.current.stop();
                    noiseNodesRef.current = null;
                }
            };

            const disposeAudioGraph = () => {
                if (rotationIntervalRef.current) {
                    clearInterval(rotationIntervalRef.current);
                    rotationIntervalRef.current = null;
                }
                rotationNodesRef.current = null;

                tearDownBinauralNodes();
                tearDownNoiseNodes();

                if (animationFrameRef.current) {
                    cancelAnimationFrame(animationFrameRef.current);
                    animationFrameRef.current = null;
                }

                if (gainChainRef.current) {
                    gainChainRef.current.disconnect();
                    gainChainRef.current = null;
                }
                gainNodeRef.current = null;
                analyserRef.current = null;

                if (sourceNodeRef.current) {
                    try {
                        sourceNodeRef.current.disconnect();
                    } catch (error) {
                        console.error('Error disconnecting source node:', error);
                    }
                    sourceNodeRef.current = null;
                }
            };

            const teardownAudioElement = () => {
                if (audioElementRef.current) {
                    const audio = audioElementRef.current;
                    if (audioEndedHandlerRef.current) {
                        audio.removeEventListener('ended', audioEndedHandlerRef.current);
                        audioEndedHandlerRef.current = null;
                    }
                    audio.pause();
                    audio.removeAttribute('src');
                    audio.load();
                    audioElementRef.current = null;
                }
                cleanupBlobUrl();
            };

            const prepareAudioElement = () => {
                teardownAudioElement();
                const audio = new Audio();
                audio.preload = 'auto';
                audio.crossOrigin = 'anonymous';
                audioElementRef.current = audio;
                audioEndedHandlerRef.current = () => {
                    cleanupBlobUrl();
                    endSession(false);
                    if (typeof playNextRef.current === 'function') {
                        playNextRef.current({ shouldEndActiveSession: false });
                    }
                };
                audio.addEventListener('ended', audioEndedHandlerRef.current);
                setAudioElementToken(Date.now());
                return audio;
            };

            const syncBinauralChain = () => {
                tearDownBinauralNodes();
                if (!binauralEnabled || !audioContextRef.current || !gainChainRef.current) {
                    return;
                }
                binauralNodesRef.current = AudioEngine.createBinauralNodes(
                    audioContextRef.current,
                    gainChainRef.current.mainGain,
                    binauralFreq
                );
            };

            const syncNoiseLayer = () => {
                tearDownNoiseNodes();
                if (
                    noiseType === 'none' ||
                    !audioContextRef.current ||
                    !gainChainRef.current
                ) {
                    return;
                }
                noiseNodesRef.current = AudioEngine.createNoiseNode(
                    audioContextRef.current,
                    gainChainRef.current.mainGain,
                    noiseType,
                    noiseVolume
                );
            };

            const clearRitualTimers = () => {
                if (ritualIntervalRef.current) {
                    clearInterval(ritualIntervalRef.current);
                    ritualIntervalRef.current = null;
                }
                if (ritualTimeoutRef.current) {
                    clearTimeout(ritualTimeoutRef.current);
                    ritualTimeoutRef.current = null;
                }
                if (breathingPhaseIntervalRef.current) {
                    clearInterval(breathingPhaseIntervalRef.current);
                    breathingPhaseIntervalRef.current = null;
                }
            };

            useEffect(() => {
                audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();

                if (window.location.protocol === 'file:') {
                    setShowFileWarning(true);
                }

                const savedDarkMode = localStorage.getItem('darkMode');
                const prefersDark = savedDarkMode === null ? true : savedDarkMode === 'true';
                setDarkMode(prefersDark);
                document.body.classList.toggle('dark-mode', prefersDark);
                if (savedDarkMode === null) {
                    localStorage.setItem('darkMode', 'true');
                }

                const savedHighContrast = localStorage.getItem('highContrast');
                if (savedHighContrast === 'true') {
                    setHighContrast(true);
                    document.body.classList.add('high-contrast');
                }

                const savedReducedMotion = localStorage.getItem('reducedMotion');
                if (savedReducedMotion === 'true') {
                    setReducedMotion(true);
                }

                // Story 3-1: Load saved active preset with validation
                const savedActivePreset = localStorage.getItem('activePresetId');
                if (savedActivePreset) {
                    const presetExists = MODE_LIBRARY.some(m => m.id === savedActivePreset);
                    setActivePresetId(presetExists ? savedActivePreset : 'focus');
                }

                const savedPlaylist = localStorage.getItem('playlist');
                if (savedPlaylist) {
                    try {
                        const parsed = JSON.parse(savedPlaylist);
                        const filtered = parsed.filter((track) => track && track.source !== 'local' && track.url);
                        setPlaylist(filtered);
                    } catch (error) {
                        console.error('Error loading saved playlist:', error);
                    }
                }

                const handleOnline = () => setIsOnline(true);
                const handleOffline = () => setIsOnline(false);
                window.addEventListener('online', handleOnline);
                window.addEventListener('offline', handleOffline);

                return () => {
                    window.removeEventListener('online', handleOnline);
                    window.removeEventListener('offline', handleOffline);
                    endSession(true);
                    disposeAudioGraph();
                    teardownAudioElement();
                    if (audioContextRef.current) {
                        audioContextRef.current.close();
                    }
                    clearRitualTimers();
                };
            }, []);

            // Story 3-3: Load all presets on mount
            useEffect(() => {
                const presets = getAllPresets();
                setAllPresets(presets);
                console.log('[PresetManagement] Loaded', presets.length, 'presets');
            }, []);

            // Cleanup URL validation on unmount
            useEffect(() => {
                // Initialize controller ref
                urlValidationControllerRef.current = {};
                
                return () => {
                    // Mark component as unmounted to prevent setState after unmount
                    urlValidationControllerRef.current = null;
                    
                    // Clear any pending toast timeout
                    if (toastTimeoutRef.current) {
                        clearTimeout(toastTimeoutRef.current);
                        toastTimeoutRef.current = null;
                    }
                };
            }, []);

            useEffect(() => {
                const sessionApi = getSessionLoggingApi();
                if (!sessionApi) {
                    console.warn('[SessionLogger] IndexedDB unavailable — session logging disabled.');
                    return;
                }
                let canceled = false;
                sessionApi.initDatabase().catch((error) => {
                    if (canceled) {
                        return;
                    }
                    console.error('[SessionLogger] Initialization failed:', error);
                    showToast('Session logging unavailable. See console for details.', 'warning');
                });

                window.SessionLogger = {
                    clearProfile: clearProfileSessions,
                    clearSessionsOlderThanDays,
                    exportSessions: (startDate, endDate) => sessionApi.getSessionsByDateRange(startDate, endDate)
                };

                return () => {
                    canceled = true;
                    delete window.SessionLogger;
                };
            }, [clearProfileSessions, clearSessionsOlderThanDays, showToast]);

            // Story 3-1: Persist active preset selection
            useEffect(() => {
                try {
                    localStorage.setItem('activePresetId', activePresetId);
                } catch (err) {
                    console.error('Failed to persist activePresetId:', err);
                }
            }, [activePresetId]);

            // Story 3-1: Apply preset parameters when activePresetId changes
            useEffect(() => {
                const preset = MODE_LIBRARY.find(m => m.id === activePresetId);
                if (preset) {
                    setSpeed(preset.preset.speed);
                    setIntensity(preset.preset.intensity);
                    setSpatialDepth(preset.preset.spatialDepth);
                    setMovementPattern(preset.preset.movement);
                    setBinauralEnabled(preset.preset.binaural.enabled);
                    setBinauralFreq(preset.preset.binaural.freq);
                    setNoiseType(preset.preset.noise.type);
                    setNoiseVolume(preset.preset.noise.volume);
                    setVisualWaveGain(preset.preset.noise.volume);
                }
            }, [activePresetId]);

            useEffect(() => {
                const serialized = playlist
                    .filter((track) => track.source !== 'local' && track.url)
                    .map((track) => ({
                        id: track.id,
                        name: track.name,
                        source: track.source,
                        url: track.url,
                        originalUrl: track.originalUrl || null
                    }));
                if (serialized.length > 0) {
                    localStorage.setItem('playlist', JSON.stringify(serialized));
                } else {
                    localStorage.removeItem('playlist');
                }
            }, [playlist]);

            useEffect(() => {
                const prevLength = prevPlaylistLengthRef.current;
                const isEmpty = playlist.length === 0;

                if (isEmpty) {
                    if (currentTrackIndex !== null) {
                        currentTrackIndexRef.current = null;
                        setCurrentTrackIndex(null);
                    }
                    teardownAudioElement();
                    disposeAudioGraph();
                    setIsPlaying(false);
                    if (prevLength !== 0) {
                        setHeroMessage('Playlist empty. Add audio to start a ritual.');
                        setNeedsAudio(true);
                        setRitualStatus('idle');
                        setRitualCountdown(HERO_BREATH_DURATION);
                        clearRitualTimers();
                    }
                } else if (currentTrackIndex !== null && currentTrackIndex >= playlist.length) {
                    const clampedIndex = Math.max(playlist.length - 1, 0);
                    currentTrackIndexRef.current = clampedIndex;
                    setCurrentTrackIndex(clampedIndex);
                }

                prevPlaylistLengthRef.current = playlist.length;
                playlistRef.current = playlist;
            }, [playlist.length, currentTrackIndex]);

            useEffect(() => {
                playlistRef.current = playlist;
            }, [playlist]);

            useEffect(() => {
                currentTrackIndexRef.current = currentTrackIndex;
            }, [currentTrackIndex]);

            // Keep audio parameter refs in sync with state for rotation interval
            useEffect(() => { speedRef.current = speed; }, [speed]);
            useEffect(() => { intensityRef.current = intensity; }, [intensity]);
            useEffect(() => { spatialDepthRef.current = spatialDepth; }, [spatialDepth]);
            useEffect(() => { movementPatternRef.current = movementPattern; }, [movementPattern]);
            useEffect(() => { spatialTunerActiveRef.current = showSpatialTuner; }, [showSpatialTuner]);

            // Show first-run calibration prompt (only once, unless dismissed)
            useEffect(() => {
                if (!hasRunCalibration && !calibrationDismissed) {
                    // Small delay to let the app render first
                    const timer = setTimeout(() => {
                        setShowFirstRunPrompt(true);
                    }, 1000);
                    return () => clearTimeout(timer);
                }
            }, [hasRunCalibration, calibrationDismissed]);

            // Clear accessibility announcements after 3 seconds to prevent re-announcements
            useEffect(() => {
                if (a11yAnnouncement) {
                    const timer = setTimeout(() => {
                        setA11yAnnouncement('');
                    }, 3000);
                    return () => clearTimeout(timer);
                }
            }, [a11yAnnouncement]);

            // Story 3-2: Keyboard shortcut (Ctrl+E) to toggle advanced controls
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'e') {
                        e.preventDefault();
                        setIsAdvancedControlsExpanded(prev => !prev);
                        setA11yAnnouncement(
                            isAdvancedControlsExpanded 
                                ? 'Advanced controls collapsed' 
                                : 'Advanced controls expanded'
                        );
                    }
                };
                
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [isAdvancedControlsExpanded]);

            // Handle Escape key, window resize, and body class for fullscreen visualizer
            useEffect(() => {
                if (visualizerFullscreen) {
                    document.body.classList.add('viz-fullscreen');

                    // Try to use native fullscreen API on mobile for better experience
                    const tryNativeFullscreen = async () => {
                        try {
                            if (document.documentElement.requestFullscreen) {
                                await document.documentElement.requestFullscreen();
                            } else if (document.documentElement.webkitRequestFullscreen) {
                                await document.documentElement.webkitRequestFullscreen();
                            }
                            // Try to lock orientation to allow rotation
                            if (screen.orientation && screen.orientation.unlock) {
                                screen.orientation.unlock();
                            }
                        } catch (e) {
                            // Fullscreen not supported or denied, continue with CSS fullscreen
                            console.log('Native fullscreen not available, using CSS fallback');
                        }
                    };
                    tryNativeFullscreen();
                } else {
                    document.body.classList.remove('viz-fullscreen');
                    setVizMenuOpen(false); // Close viz menu when exiting fullscreen
                    // Exit native fullscreen if active
                    if (document.fullscreenElement || document.webkitFullscreenElement) {
                        if (document.exitFullscreen) {
                            document.exitFullscreen().catch(() => {});
                        } else if (document.webkitExitFullscreen) {
                            document.webkitExitFullscreen();
                        }
                    }
                }

                if (!visualizerFullscreen) return;

                const handleEscapeFullscreen = (e) => {
                    if (e.key === 'Escape') {
                        setVisualizerFullscreen(false);
                    }
                };

                const handleResize = () => {
                    // Force re-render to update canvas size
                    if (canvasRef.current && visualizerFullscreen) {
                        canvasRef.current.width = window.innerWidth;
                        canvasRef.current.height = window.innerHeight;
                    }
                    if (fullscreenCanvasRef.current) {
                        fullscreenCanvasRef.current.width = window.innerWidth;
                        fullscreenCanvasRef.current.height = window.innerHeight;
                    }
                };

                // Handle native fullscreen exit (e.g., swipe down on mobile)
                const handleFullscreenChange = () => {
                    if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                        setVisualizerFullscreen(false);
                    }
                };

                window.addEventListener('keydown', handleEscapeFullscreen);
                window.addEventListener('resize', handleResize);
                document.addEventListener('fullscreenchange', handleFullscreenChange);
                document.addEventListener('webkitfullscreenchange', handleFullscreenChange);

                return () => {
                    window.removeEventListener('keydown', handleEscapeFullscreen);
                    window.removeEventListener('resize', handleResize);
                    document.removeEventListener('fullscreenchange', handleFullscreenChange);
                    document.removeEventListener('webkitfullscreenchange', handleFullscreenChange);
                    document.body.classList.remove('viz-fullscreen');
                };
            }, [visualizerFullscreen]);

            useEffect(() => {
                const audio = audioElementRef.current;
                if (!audio) {
                    return;
                }
                const handleTimeUpdate = () => {
                    setCurrentTime(audio.currentTime || 0);
                    setDuration(audio.duration || 0);
                };
                audio.addEventListener('timeupdate', handleTimeUpdate);
                audio.addEventListener('loadedmetadata', handleTimeUpdate);
                return () => {
                    audio.removeEventListener('timeupdate', handleTimeUpdate);
                    audio.removeEventListener('loadedmetadata', handleTimeUpdate);
                };
            }, [audioElementToken]);

            const toggleDarkMode = () => {
                const next = !darkMode;
                setDarkMode(next);
                document.body.classList.toggle('dark-mode', next);
                localStorage.setItem('darkMode', String(next));
                setA11yAnnouncement(next ? 'Dark mode enabled' : 'Light mode enabled');
            };

            const toggleHighContrast = () => {
                const next = !highContrast;
                setHighContrast(next);
                document.body.classList.toggle('high-contrast', next);
                try {
                    if (next) {
                        localStorage.setItem('highContrast', 'true');
                    } else {
                        localStorage.removeItem('highContrast');
                    }
                } catch (e) {
                    console.warn('Failed to persist high-contrast preference', e);
                }
                setA11yAnnouncement(next ? 'High contrast mode enabled' : 'High contrast mode disabled');
            };

            const toggleReducedMotion = () => {
                const next = !reducedMotion;
                setReducedMotion(next);
                try {
                    if (next) {
                        localStorage.setItem('reducedMotion', 'true');
                    } else {
                        localStorage.removeItem('reducedMotion');
                    }
                } catch (e) {
                    console.warn('Failed to persist reduced-motion preference', e);
                }
                setA11yAnnouncement(next ? 'Reduced motion enabled' : 'Motion enabled');
            };

            const focusModeChip = (index) => {
                const total = MODE_LIBRARY.length;
                const normalized = ((index % total) + total) % total;
                setFocusedModeIndex(normalized);
                requestAnimationFrame(() => {
                    const chip = modeRefs.current[normalized];
                    if (chip) {
                        chip.focus();
                    }
                });
                return normalized;
            };

            // Story 3-1: Log preset changes for Epic 4 session tracking
            const logPresetChange = (newPresetId) => {
                const event = {
                    event: 'PRESET_CHANGED',
                    presetId: newPresetId,
                    previousPresetId: activePresetId,
                    timestamp: Date.now(),
                    trackId: currentTrackIndex !== null ? playlist[currentTrackIndex].id : null
                };
                console.log('[SessionLogger]', event);
                // E4 integration point - future: dispatch to IndexedDB logger
                // window.dispatchEvent(new CustomEvent('preset-changed', { detail: event }));
            };

            // Story 3-2: Epic 5 API for adaptive mode (sensor lock)
            const enableSensorMode = () => {
                setSensorLocked(true);
                setA11yAnnouncement('Adaptive mode enabled. Controls locked.');
                showToast('Adaptive mode active', 'info');
            };

            const disableSensorMode = () => {
                setSensorLocked(false);
                setA11yAnnouncement('Adaptive mode disabled. Controls unlocked.');
                showToast('Manual control restored', 'info');
            };

            // Expose API for Epic 5 integration
            useEffect(() => {
                window.audioControlsAPI = {
                    enableSensorMode,
                    disableSensorMode
                };
                return () => {
                    delete window.audioControlsAPI;
                };
            }, []);

            // ============================================================
            // Story 3-3: Custom Preset Management Handlers
            // ============================================================
            
            const openSavePresetDialog = () => {
                setEditingPreset(null);
                setShowSavePresetDialog(true);
            };

            const openEditPresetDialog = (preset) => {
                setEditingPreset(preset);
                setShowSavePresetDialog(true);
            };

            const closeSavePresetDialog = () => {
                setShowSavePresetDialog(false);
                setEditingPreset(null);
            };

            const handleSavePreset = (presetId) => {
                // Apply the newly saved/edited preset
                const presets = getAllPresets();
                setAllPresets(presets);
                
                const preset = presets.find(p => p.id === presetId);
                if (preset) {
                    applyPreset(preset.preset, preset.id);
                }
                
                closeSavePresetDialog();
            };

            const handleDeletePreset = (presetId) => {
                // Check how many tracks use this preset
                const tracksUsingPreset = playlist.filter(t => t.lastPresetId === presetId).length;

                let confirmMessage = 'Delete this preset? This cannot be undone.';
                if (tracksUsingPreset > 0) {
                    confirmMessage = `⚠️ This preset is used by ${tracksUsingPreset} track(s).\n\nThey will reset to the default Focus preset.\n\nDelete this preset? This cannot be undone.`;
                }

                if (!confirm(confirmMessage)) {
                    return;
                }

                const result = deleteCustomPreset(presetId, showToast);
                if (result) {
                    showToast(`Preset "${result.name}" deleted`, 'success');
                    setA11yAnnouncement(`Preset ${result.name} deleted`);
                    
                    // Update all presets list
                    const presets = getAllPresets();
                    setAllPresets(presets);
                    
                    // Update tracks using this preset to fallback to focus
                    setPlaylist(prev => prev.map(track => ({
                        ...track,
                        lastPresetId: track.lastPresetId === presetId ? 'focus' : track.lastPresetId
                    })));
                    
                    // If deleted preset was active, switch to focus
                    if (activePresetId === presetId) {
                        const focusMode = MODE_LIBRARY[0];
                        applyPreset(focusMode.preset, focusMode.id);
                        showToast('Switched to Focus preset', 'info');
                    }
                }
            };

            const handleQuickApplyPreset = (preset) => {
                applyPreset(preset.preset, preset.id);
                showToast(`Applied ${preset.name} preset`, 'success');
                setA11yAnnouncement(`${preset.name} preset applied`);
            };

            const handleReorderPresets = (newOrder) => {
                savePresetOrder(newOrder);
                // Reload all presets to reflect new order
                const presets = getAllPresets();
                setAllPresets(presets);
            };

            const setActiveMode = (index) => {
                const normalized = focusModeChip(index);
                const mode = MODE_LIBRARY[normalized];
                setModeIndex(normalized);
                applyPreset(mode.preset, mode.id);
                setHeroMessage(`${mode.label} preset queued. Press Start to begin.`);
                setA11yAnnouncement(`${mode.label} mode selected`);
            };

            const handleModeKeyDown = (event, index) => {
                const { key } = event;
                if (key === 'ArrowRight' || key === 'ArrowDown') {
                    event.preventDefault();
                    focusModeChip(index + 1);
                    return;
                }
                if (key === 'ArrowLeft' || key === 'ArrowUp') {
                    event.preventDefault();
                    focusModeChip(index - 1);
                    return;
                }
                if (key === 'Home') {
                    event.preventDefault();
                    focusModeChip(0);
                    return;
                }
                if (key === 'End') {
                    event.preventDefault();
                    focusModeChip(MODE_LIBRARY.length - 1);
                    return;
                }
                if (key === 'Enter' || key === ' ' || key === 'Spacebar') {
                    event.preventDefault();
                    setActiveMode(index);
                }
            };

            const setupAudioGraph = (audioElement) => {
                const context = audioContextRef.current;
                if (!context) return;

                if (context.state === 'suspended') {
                    context.resume();
                }

                disposeAudioGraph();

                const source = context.createMediaElementSource(audioElement);
                sourceNodeRef.current = source;

                const splitter = context.createChannelSplitter(2);
                const merger = context.createChannelMerger(2);

                const leftToLeftGain = context.createGain();
                const leftToRightGain = context.createGain();
                const rightToLeftGain = context.createGain();
                const rightToRightGain = context.createGain();

                const delayLeft = context.createDelay();
                const delayRight = context.createDelay();
                delayLeft.delayTime.value = 0.05;
                delayRight.delayTime.value = 0.05;

                const delayGainLeft = context.createGain();
                const delayGainRight = context.createGain();
                delayGainLeft.gain.value = 0.05 * spatialDepth;
                delayGainRight.gain.value = 0.05 * spatialDepth;

                const crossDelayLeft = context.createDelay();
                const crossDelayRight = context.createDelay();
                crossDelayLeft.delayTime.value = 0.03;
                crossDelayRight.delayTime.value = 0.03;

                const crossGainLeft = context.createGain();
                const crossGainRight = context.createGain();
                crossGainLeft.gain.value = 0.03 * spatialDepth;
                crossGainRight.gain.value = 0.03 * spatialDepth;

                // ITD (Inter-aural Time Difference) delay nodes
                // Max ITD is ~0.7ms (0.0007s) when sound is directly to one side
                // Extended to 200ms max for calibration/APD testing
                const itdDelayLeft = context.createDelay(0.2); // max 200ms for calibration
                const itdDelayRight = context.createDelay(0.2);
                itdDelayLeft.delayTime.value = 0;
                itdDelayRight.delayTime.value = 0;

                // Low-pass filters for "head shadow" effect
                // High frequencies are blocked more by the head, making sounds behind/opposite darker
                const lpFilterLeft = context.createBiquadFilter();
                const lpFilterRight = context.createBiquadFilter();
                lpFilterLeft.type = 'lowpass';
                lpFilterRight.type = 'lowpass';
                lpFilterLeft.frequency.value = 20000; // Start fully open
                lpFilterRight.frequency.value = 20000;
                lpFilterLeft.Q.value = 0.7; // Gentle rolloff
                lpFilterRight.Q.value = 0.7;

                rotationNodesRef.current = {
                    leftToLeftGain,
                    leftToRightGain,
                    rightToLeftGain,
                    rightToRightGain,
                    delayGainLeft,
                    delayGainRight,
                    crossGainLeft,
                    crossGainRight,
                    itdDelayLeft,
                    itdDelayRight,
                    lpFilterLeft,
                    lpFilterRight
                };

                source.connect(splitter);

                splitter.connect(leftToLeftGain, 0);
                splitter.connect(leftToRightGain, 0);
                splitter.connect(rightToLeftGain, 1);
                splitter.connect(rightToRightGain, 1);

                // Route through ITD delays and low-pass filters before merger
                // Left channel: gains -> ITD delay -> low-pass filter -> merger
                leftToLeftGain.connect(itdDelayLeft);
                rightToLeftGain.connect(itdDelayLeft);
                itdDelayLeft.connect(lpFilterLeft);
                lpFilterLeft.connect(merger, 0, 0);

                // Right channel: gains -> ITD delay -> low-pass filter -> merger
                rightToRightGain.connect(itdDelayRight);
                leftToRightGain.connect(itdDelayRight);
                itdDelayRight.connect(lpFilterRight);
                lpFilterRight.connect(merger, 0, 1);

                leftToLeftGain.connect(delayLeft);
                delayLeft.connect(delayGainLeft);
                delayGainLeft.connect(merger, 0, 0);

                rightToRightGain.connect(delayRight);
                delayRight.connect(delayGainRight);
                delayGainRight.connect(merger, 0, 1);

                leftToLeftGain.connect(crossDelayRight);
                crossDelayRight.connect(crossGainRight);
                crossGainRight.connect(merger, 0, 1);

                rightToRightGain.connect(crossDelayLeft);
                crossDelayLeft.connect(crossGainLeft);
                crossGainLeft.connect(merger, 0, 0);

                // EQ Filters - applied after spatial processing, before output
                // Bass: Low shelf filter (~150Hz)
                const bassFilter = context.createBiquadFilter();
                bassFilter.type = 'lowshelf';
                bassFilter.frequency.value = 150;
                bassFilter.gain.value = 0; // -12 to +12 dB

                // Mid: Peaking filter (~1000Hz)
                const midFilter = context.createBiquadFilter();
                midFilter.type = 'peaking';
                midFilter.frequency.value = 1000;
                midFilter.Q.value = 1.0;
                midFilter.gain.value = 0; // -12 to +12 dB

                // Treble: High shelf filter (~4000Hz)
                const trebleFilter = context.createBiquadFilter();
                trebleFilter.type = 'highshelf';
                trebleFilter.frequency.value = 4000;
                trebleFilter.gain.value = 0; // -12 to +12 dB

                // Clarity/Presence: Peaking filter (~2500Hz) - speech intelligibility range
                const clarityFilter = context.createBiquadFilter();
                clarityFilter.type = 'peaking';
                clarityFilter.frequency.value = 2500;
                clarityFilter.Q.value = 1.5; // Narrower band for presence
                clarityFilter.gain.value = 0; // -12 to +12 dB

                // Store EQ nodes for later adjustment
                eqNodesRef.current = {
                    bassFilter,
                    midFilter,
                    trebleFilter,
                    clarityFilter
                };

                // Chain: merger → bass → mid → treble → clarity → gainChain
                merger.connect(bassFilter);
                bassFilter.connect(midFilter);
                midFilter.connect(trebleFilter);
                trebleFilter.connect(clarityFilter);

                const gainChain = AudioEngine.connectGainStaging(context, clarityFilter, {
                    volume,
                    fftSize: 2048
                });

                gainChainRef.current = gainChain;
                gainNodeRef.current = gainChain.mainGain;
                analyserRef.current = gainChain.analyser;

                syncBinauralChain();
                syncNoiseLayer();

                startRotation();

                if (showVisualizer) {
                    visualize();
                }
            };

            // Apply gains directly from Spatial Tuner (bypasses rotation interval)
            const applyTunerGains = React.useCallback((leftGain, rightGain, crossGain, itdLeftDelay = 0, itdRightDelay = 0, leftFilterFreq = 20000, rightFilterFreq = 20000, forceHardPan = false) => {
                const nodes = rotationNodesRef.current;
                const ctx = audioContextRef.current;
                if (!nodes || !ctx) return;

                const clamp = (val) => Math.max(0.0001, Math.min(1, val));
                const now = ctx.currentTime;
                const rampTime = now + 0.05; // Fast 50ms ramp

                // Apply the gains directly
                if (nodes.leftToLeftGain) {
                    nodes.leftToLeftGain.gain.setValueAtTime(clamp(nodes.leftToLeftGain.gain.value), now);
                    nodes.leftToLeftGain.gain.exponentialRampToValueAtTime(clamp(leftGain * 0.5), rampTime);
                }
                if (nodes.rightToRightGain) {
                    nodes.rightToRightGain.gain.setValueAtTime(clamp(nodes.rightToRightGain.gain.value), now);
                    nodes.rightToRightGain.gain.exponentialRampToValueAtTime(clamp(rightGain * 0.5), rampTime);
                }
                // Cross-channel (near zero for hard pan)
                if (nodes.leftToRightGain) {
                    nodes.leftToRightGain.gain.setValueAtTime(clamp(nodes.leftToRightGain.gain.value), now);
                    nodes.leftToRightGain.gain.exponentialRampToValueAtTime(clamp(crossGain), rampTime);
                }
                if (nodes.rightToLeftGain) {
                    nodes.rightToLeftGain.gain.setValueAtTime(clamp(nodes.rightToLeftGain.gain.value), now);
                    nodes.rightToLeftGain.gain.exponentialRampToValueAtTime(clamp(crossGain), rampTime);
                }

                // Apply ITD (Inter-aural Time Difference) delays
                // Sound on right = delay left ear, sound on left = delay right ear
                // Max 200ms for calibration testing (normal ITD is ~0.7ms)
                const leftDelayValue = Math.min(0.2, Math.max(0, itdLeftDelay));
                const rightDelayValue = Math.min(0.2, Math.max(0, itdRightDelay));
                console.log(`[applyTunerGains] ITD Delays requested - Left: ${(leftDelayValue * 1000).toFixed(1)}ms, Right: ${(rightDelayValue * 1000).toFixed(1)}ms`);

                if (nodes.itdDelayLeft) {
                    // Cancel any pending automation and set immediately
                    nodes.itdDelayLeft.delayTime.cancelScheduledValues(now);
                    nodes.itdDelayLeft.delayTime.setValueAtTime(leftDelayValue, now);
                    console.log(`  -> itdDelayLeft: was ${(nodes.itdDelayLeft.delayTime.value * 1000).toFixed(1)}ms, set to ${(leftDelayValue * 1000).toFixed(1)}ms`);
                } else {
                    console.warn('  -> itdDelayLeft node NOT FOUND!');
                }
                if (nodes.itdDelayRight) {
                    // Cancel any pending automation and set immediately
                    nodes.itdDelayRight.delayTime.cancelScheduledValues(now);
                    nodes.itdDelayRight.delayTime.setValueAtTime(rightDelayValue, now);
                    console.log(`  -> itdDelayRight: was ${(nodes.itdDelayRight.delayTime.value * 1000).toFixed(1)}ms, set to ${(rightDelayValue * 1000).toFixed(1)}ms`);
                } else {
                    console.warn('  -> itdDelayRight node NOT FOUND!');
                }

                // Verify the values were actually set (read back)
                setTimeout(() => {
                    if (nodes.itdDelayLeft) console.log(`  [VERIFY] itdDelayLeft actual value: ${(nodes.itdDelayLeft.delayTime.value * 1000).toFixed(1)}ms`);
                    if (nodes.itdDelayRight) console.log(`  [VERIFY] itdDelayRight actual value: ${(nodes.itdDelayRight.delayTime.value * 1000).toFixed(1)}ms`);
                }, 100);

                // CRITICAL: Mute the parallel delay paths that bypass ITD
                // These paths create undelayed signal that drowns out ITD timing
                // Also mute during calibration (forceHardPan) for clean L/R separation
                const hasITDDelay = leftDelayValue > 0.001 || rightDelayValue > 0.001;
                const needsHardPan = hasITDDelay || forceHardPan;
                const parallelPathGain = needsHardPan ? 0.0001 : 0.05; // Mute when testing ITD or calibrating
                // Cross-delay paths (left→right, right→left) - ALWAYS mute during hard pan for clean separation
                const crossPathGain = needsHardPan ? 0.0001 : 0.03;

                if (nodes.delayGainLeft) {
                    nodes.delayGainLeft.gain.cancelScheduledValues(now);
                    nodes.delayGainLeft.gain.setValueAtTime(parallelPathGain, now);
                }
                if (nodes.delayGainRight) {
                    nodes.delayGainRight.gain.cancelScheduledValues(now);
                    nodes.delayGainRight.gain.setValueAtTime(parallelPathGain, now);
                }
                if (nodes.crossGainLeft) {
                    nodes.crossGainLeft.gain.cancelScheduledValues(now);
                    nodes.crossGainLeft.gain.setValueAtTime(crossPathGain, now);
                }
                if (nodes.crossGainRight) {
                    nodes.crossGainRight.gain.cancelScheduledValues(now);
                    nodes.crossGainRight.gain.setValueAtTime(crossPathGain, now);
                }

                if (needsHardPan) {
                    console.log(`  [HARD PAN MODE] Muted parallel/cross paths - ITD: ${hasITDDelay}, Calibration: ${forceHardPan}`);
                }

                // Apply low-pass filter frequencies for "head shadow" effect
                // This makes sounds darker/muffled when behind or on opposite side
                if (nodes.lpFilterLeft) {
                    nodes.lpFilterLeft.frequency.setValueAtTime(nodes.lpFilterLeft.frequency.value, now);
                    nodes.lpFilterLeft.frequency.exponentialRampToValueAtTime(Math.max(200, leftFilterFreq), rampTime);
                }
                if (nodes.lpFilterRight) {
                    nodes.lpFilterRight.frequency.setValueAtTime(nodes.lpFilterRight.frequency.value, now);
                    nodes.lpFilterRight.frequency.exponentialRampToValueAtTime(Math.max(200, rightFilterFreq), rampTime);
                }
            }, []);

            // Apply EQ settings to the audio chain
            const applyEQ = React.useCallback((bass, mid, treble, clarity) => {
                const eq = eqNodesRef.current;
                const ctx = audioContextRef.current;
                if (!eq || !ctx) {
                    console.warn('[applyEQ] EQ nodes not available');
                    return;
                }

                const now = ctx.currentTime;
                const rampTime = now + 0.05; // 50ms smooth transition

                // Clamp values to -12 to +12 dB range
                const clampDB = (val) => Math.max(-12, Math.min(12, val || 0));

                const bassDB = clampDB(bass);
                const midDB = clampDB(mid);
                const trebleDB = clampDB(treble);
                const clarityDB = clampDB(clarity);

                console.log(`[applyEQ] Bass: ${bassDB}dB, Mid: ${midDB}dB, Treble: ${trebleDB}dB, Clarity: ${clarityDB}dB`);

                if (eq.bassFilter) {
                    eq.bassFilter.gain.setValueAtTime(eq.bassFilter.gain.value, now);
                    eq.bassFilter.gain.linearRampToValueAtTime(bassDB, rampTime);
                }
                if (eq.midFilter) {
                    eq.midFilter.gain.setValueAtTime(eq.midFilter.gain.value, now);
                    eq.midFilter.gain.linearRampToValueAtTime(midDB, rampTime);
                }
                if (eq.trebleFilter) {
                    eq.trebleFilter.gain.setValueAtTime(eq.trebleFilter.gain.value, now);
                    eq.trebleFilter.gain.linearRampToValueAtTime(trebleDB, rampTime);
                }
                if (eq.clarityFilter) {
                    eq.clarityFilter.gain.setValueAtTime(eq.clarityFilter.gain.value, now);
                    eq.clarityFilter.gain.linearRampToValueAtTime(clarityDB, rampTime);
                }
            }, []);

            const startRotation = () => {
                if (rotationIntervalRef.current) {
                    clearInterval(rotationIntervalRef.current);
                }
                if (!rotationNodesRef.current) {
                    return;
                }
                
                let time = 0;
                // Use a slightly longer interval to allow meaningful ramps (avoid overlapping automation)
                const ROTATION_INTERVAL_MS = 100; // 100ms ticks
                rotationIntervalRef.current = setInterval(() => {
                    // Skip rotation when Spatial Tuner is active (tuner controls audio directly)
                    if (spatialTunerActiveRef.current) {
                        return;
                    }

                    const nodes = rotationNodesRef.current;
                    const ctx = audioContextRef.current;
                    if (
                        !nodes ||
                        !ctx ||
                        !nodes.leftToLeftGain ||
                        !nodes.leftToRightGain ||
                        !nodes.rightToLeftGain ||
                        !nodes.rightToRightGain
                    ) {
                        return;
                    }
                    
                    // Read current values from refs (not stale closure)
                    const currentSpeed = speedRef.current;
                    const currentMovement = movementPatternRef.current;
                    const currentIntensity = intensityRef.current;
                    const currentSpatialDepth = spatialDepthRef.current;

                    const angle = 2 * Math.PI * currentSpeed * time;
                    let panPosition = 0;

                    // Calculate pan position based on movement pattern
                    switch(currentMovement) {
                        case 'circle':
                            panPosition = Math.sin(angle);
                            break;
                        case 'figure8':
                            // True figure-8: Loop on right side, then loop on left side
                            // Creates the sensation of sound tracing an "8" around your head
                            const f8Cycle = ((angle / (2 * Math.PI)) % 1 + 1) % 1; // 0 to 1, normalized
                            if (f8Cycle < 0.5) {
                                // Right side loop: center → full right → center
                                const rightPhase = f8Cycle * 2; // 0 to 1
                                panPosition = Math.sin(rightPhase * Math.PI); // 0 → 1 → 0
                            } else {
                                // Left side loop: center → full left → center
                                const leftPhase = (f8Cycle - 0.5) * 2; // 0 to 1
                                panPosition = -Math.sin(leftPhase * Math.PI); // 0 → -1 → 0
                            }
                            // Add subtle depth variation (quieter at the "crossing point" of the 8)
                            const f8DepthPhase = Math.abs(Math.sin(f8Cycle * 2 * Math.PI));
                            window._quadrantDepthMultiplier = 0.7 + 0.3 * f8DepthPhase; // 0.7 to 1.0
                            break;
                        case 'leftright':
                            panPosition = Math.sin(angle);
                            break;
                        case 'frontback':
                            panPosition = Math.cos(angle) * 0.5;
                            break;
                        case 'random':
                            if (Math.random() > 0.9) {
                                panPosition = (Math.random() * 2 - 1);
                            }
                            break;
                        case 'quadrant':
                            // 360-degree circular sound: Right -> Back(quiet) -> Left -> Front -> repeat
                            // Creates immersive feeling of sound orbiting around your head
                            const fullCycle = (angle / (2 * Math.PI)); // cycles (may be >1)
                            const cyclePos = fullCycle - Math.floor(fullCycle); // 0..1 within cycle
                            const segment = Math.floor(cyclePos * 4); // 0=right, 1=back, 2=left, 3=front
                            const segmentPhase = (cyclePos * 4) - segment; // 0..1 within segment

                            // Pan positions: Right(1) -> Center(0) -> Left(-1) -> Center(0)
                            const panAnchors = [1, 0, -1, 0];
                            const panA = panAnchors[segment];
                            const panB = panAnchors[(segment + 1) % panAnchors.length];

                            // Depth/volume multipliers: Right(1.0) -> Back(0.55) -> Left(1.0) -> Front(1.0)
                            // Back position is quieter to simulate sound being behind your head
                            const depthAnchors = [1.0, 0.55, 1.0, 1.0];
                            const depthA = depthAnchors[segment];
                            const depthB = depthAnchors[(segment + 1) % depthAnchors.length];

                            // Smooth easing for more natural circular motion (ease-in-out)
                            const easeInOut = (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                            const smoothPhase = easeInOut(segmentPhase);

                            // Interpolate pan position with easing
                            panPosition = panA + (panB - panA) * smoothPhase;

                            // Store depth multiplier for gain calculation (accessed below)
                            // Using a variable name that won't conflict
                            window._quadrantDepthMultiplier = depthA + (depthB - depthA) * smoothPhase;
                            break;
                        default:
                            panPosition = Math.sin(angle);
                    }
                    
                    // Apply intensity to pan position
                    panPosition *= currentIntensity;
                    
                    // CRITICAL FIX: Normalized gain distribution to prevent clipping
                    // Total energy must equal 1.0 to prevent gain accumulation
                    const normalizationFactor = 0.5; // Base gain per channel before panning

                    // Quadrant uses HARD panning (no cross-channel) for clear L/R separation
                    const isHardPan = currentMovement === 'quadrant';
                    const crossChannelMix = isHardPan ? 0 : 0.15; // Zero bleeding for quadrant

                    // For 'quadrant' and 'figure8' patterns, apply depth simulation
                    // Creates immersive 3D sound by varying volume based on perceived position
                    const use3DDepth = currentMovement === 'quadrant' || currentMovement === 'figure8';
                    const depthGainMultiplier = use3DDepth
                        ? (window._quadrantDepthMultiplier || 1.0)
                        : 1.0;

                    // Main channel gains - Quadrant uses hard panning for maximum separation
                    let leftChannelGain, rightChannelGain;
                    if (isHardPan) {
                        // HARD PAN: When right, left is silent. When left, right is silent.
                        // panPosition: -1 = full left, 0 = center, +1 = full right
                        if (panPosition > 0.1) {
                            // Panning right: left ear gets less/none
                            leftChannelGain = Math.max(0, 1 - panPosition * 2); // Drops to 0 at pan=0.5+
                            rightChannelGain = 1;
                        } else if (panPosition < -0.1) {
                            // Panning left: right ear gets less/none
                            leftChannelGain = 1;
                            rightChannelGain = Math.max(0, 1 + panPosition * 2); // Drops to 0 at pan=-0.5+
                        } else {
                            // Center (back/front): both ears equal
                            leftChannelGain = 0.5;
                            rightChannelGain = 0.5;
                        }
                    } else {
                        // Standard soft panning for other patterns
                        leftChannelGain = (1 - panPosition) * 0.5; // 0.0 to 1.0
                        rightChannelGain = (1 + panPosition) * 0.5; // 0.0 to 1.0
                    }

                    // Apply depth multiplier for 3D spatial patterns
                    const targetLeftGain = Math.max(0.001, leftChannelGain * normalizationFactor * depthGainMultiplier);
                    const targetRightGain = Math.max(0.001, rightChannelGain * normalizationFactor * depthGainMultiplier);

                    // Cross-channel gains - ZERO for quadrant (hard pan), small for others
                    const targetLeftToRight = isHardPan ? 0.001 : Math.max(0.001, rightChannelGain * crossChannelMix * normalizationFactor);
                    const targetRightToLeft = isHardPan ? 0.001 : Math.max(0.001, leftChannelGain * crossChannelMix * normalizationFactor);

                    // Delay/cross-delay gains - minimal for quadrant to keep separation clean
                    const delayBase = isHardPan ? 0.02 : 0.05 * currentSpatialDepth;
                    const crossDelayBase = isHardPan ? 0 : 0.03 * currentSpatialDepth;
                    const targetDelayLeft = Math.max(0.0001, delayBase * Math.abs(panPosition));
                    const targetDelayRight = Math.max(0.0001, delayBase * Math.abs(panPosition));
                    const targetCrossDelayLeft = Math.max(0.0001, crossDelayBase * Math.abs(panPosition));
                    const targetCrossDelayRight = Math.max(0.0001, crossDelayBase * Math.abs(panPosition));
                    
                    // Use exponentialRampToValueAtTime for smoother transitions (prevents clicks better than linear)
                    const now = ctx.currentTime;
                    const rampSec = 0.1; // 100ms ramp for perceptible movement
                    const rampTime = now + rampSec;
                    
                    // Clamp to prevent automation errors
                    const clamp = (val) => Math.max(0.0001, Math.min(1, val));
                    
                    nodes.leftToLeftGain.gain.setValueAtTime(clamp(nodes.leftToLeftGain.gain.value), now);
                    nodes.leftToLeftGain.gain.exponentialRampToValueAtTime(clamp(targetLeftGain), rampTime);
                    
                    nodes.rightToRightGain.gain.setValueAtTime(clamp(nodes.rightToRightGain.gain.value), now);
                    nodes.rightToRightGain.gain.exponentialRampToValueAtTime(clamp(targetRightGain), rampTime);
                    
                    nodes.leftToRightGain.gain.setValueAtTime(clamp(nodes.leftToRightGain.gain.value), now);
                    nodes.leftToRightGain.gain.exponentialRampToValueAtTime(clamp(targetLeftToRight), rampTime);
                    
                    nodes.rightToLeftGain.gain.setValueAtTime(clamp(nodes.rightToLeftGain.gain.value), now);
                    nodes.rightToLeftGain.gain.exponentialRampToValueAtTime(clamp(targetRightToLeft), rampTime);

                    // Ramp delay/cross-delay gains as well to enhance spatial cues
                    if (nodes.delayGainLeft) {
                        nodes.delayGainLeft.gain.setValueAtTime(clamp(nodes.delayGainLeft.gain.value), now);
                        nodes.delayGainLeft.gain.exponentialRampToValueAtTime(clamp(targetDelayLeft), rampTime);
                    }
                    if (nodes.delayGainRight) {
                        nodes.delayGainRight.gain.setValueAtTime(clamp(nodes.delayGainRight.gain.value), now);
                        nodes.delayGainRight.gain.exponentialRampToValueAtTime(clamp(targetDelayRight), rampTime);
                    }
                    if (nodes.crossGainLeft) {
                        nodes.crossGainLeft.gain.setValueAtTime(clamp(nodes.crossGainLeft.gain.value), now);
                        nodes.crossGainLeft.gain.exponentialRampToValueAtTime(clamp(targetCrossDelayLeft), rampTime);
                    }
                    if (nodes.crossGainRight) {
                        nodes.crossGainRight.gain.setValueAtTime(clamp(nodes.crossGainRight.gain.value), now);
                        nodes.crossGainRight.gain.exponentialRampToValueAtTime(clamp(targetCrossDelayRight), rampTime);
                    }
                    
                    // Increment time according to interval (seconds)
                    time += ROTATION_INTERVAL_MS / 1000;
                }, ROTATION_INTERVAL_MS);
            };

            const visualize = () => {
                if (!analyserRef.current) return;

                const analyser = analyserRef.current;
                const bufferLength = analyser.frequencyBinCount;
                const frequencyData = new Uint8Array(bufferLength);
                const waveformData = new Uint8Array(bufferLength);

                // Particles state for particle visualizer (per canvas)
                let particlesDesktop = [];
                let particlesMobile = [];
                let particlesFullscreen = [];
                const maxParticles = 100;

                const drawOnCanvas = (canvas, particles) => {
                    if (!canvas) return particles;
                    const ctx = canvas.getContext('2d');
                    const visType = visualizerTypeRef.current;
                    const visualGain = Math.max(0.1, Math.min(visualWaveGainRef.current / 0.5, 1));
                    const bgColor = darkMode ? '#1a2332' : '#0a0a0a';

                    // Clear canvas
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    if (visType === 'bars') {
                        const barWidth = (canvas.width / bufferLength) * 2.5;
                        let x = 0;
                        for (let i = 0; i < bufferLength; i++) {
                            const barHeight = ((frequencyData[i] / 255) * canvas.height) * visualGain;
                            const hue = (i / bufferLength) * 360;
                            ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                            ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                            x += barWidth + 1;
                        }
                    } else if (visType === 'waveform') {
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = '#4ade80';
                        ctx.beginPath();
                        const sliceWidth = canvas.width / bufferLength;
                        let x = 0;
                        for (let i = 0; i < bufferLength; i++) {
                            const v = waveformData[i] / 128.0;
                            const y = (v * canvas.height / 2) * visualGain;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                            x += sliceWidth;
                        }
                        ctx.lineTo(canvas.width, canvas.height / 2);
                        ctx.stroke();
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#4ade80';
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    } else if (visType === 'circular') {
                        const centerX = canvas.width / 2;
                        const centerY = canvas.height / 2;
                        const radius = Math.min(centerX, centerY) * 0.6;
                        const bars = 64;
                        for (let i = 0; i < bars; i++) {
                            const freqIndex = Math.floor(i * bufferLength / bars);
                            const amplitude = (frequencyData[freqIndex] / 255) * visualGain;
                            const angle = (i / bars) * Math.PI * 2;
                            const innerR = radius * 0.3;
                            const outerR = radius + (amplitude * radius * 0.8);
                            const hue = (i / bars) * 360;
                            ctx.beginPath();
                            ctx.moveTo(centerX + Math.cos(angle) * innerR, centerY + Math.sin(angle) * innerR);
                            ctx.lineTo(centerX + Math.cos(angle) * outerR, centerY + Math.sin(angle) * outerR);
                            ctx.strokeStyle = `hsl(${hue}, 80%, 60%)`;
                            ctx.lineWidth = 3;
                            ctx.stroke();
                        }
                    } else if (visType === 'mirrored') {
                        const barWidth = (canvas.width / bufferLength) * 2.5;
                        let x = 0;
                        const centerY = canvas.height / 2;
                        for (let i = 0; i < bufferLength; i++) {
                            const barHeight = ((frequencyData[i] / 255) * centerY) * visualGain;
                            const hue = (i / bufferLength) * 180 + 180;
                            ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                            ctx.fillRect(x, centerY - barHeight, barWidth, barHeight);
                            ctx.fillRect(x, centerY, barWidth, barHeight);
                            x += barWidth + 1;
                        }
                    } else if (visType === 'particles') {
                        const avgFreq = frequencyData.reduce((a, b) => a + b, 0) / bufferLength;
                        if (avgFreq > 50 && particles.length < maxParticles) {
                            particles.push({
                                x: Math.random() * canvas.width,
                                y: canvas.height,
                                vx: (Math.random() - 0.5) * 4,
                                vy: -Math.random() * 5 - 2,
                                life: 1,
                                hue: Math.random() * 360,
                                size: Math.random() * 4 + 2
                            });
                        }
                        particles = particles.filter(p => p.life > 0);
                        particles.forEach(p => {
                            p.x += p.vx;
                            p.y += p.vy;
                            p.vy += 0.05;
                            p.life -= 0.015;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                            ctx.fillStyle = `hsla(${p.hue}, 80%, 60%, ${p.life})`;
                            ctx.fill();
                        });
                    }
                    return particles;
                };

                const draw = () => {
                    animationFrameRef.current = requestAnimationFrame(draw);

                    // Get audio data once
                    analyser.getByteFrequencyData(frequencyData);
                    analyser.getByteTimeDomainData(waveformData);

                    // Draw on all available canvases
                    if (canvasRef.current) {
                        particlesDesktop = drawOnCanvas(canvasRef.current, particlesDesktop);
                    }
                    if (mobileCanvasRef.current) {
                        particlesMobile = drawOnCanvas(mobileCanvasRef.current, particlesMobile);
                    }
                    if (fullscreenCanvasRef.current) {
                        particlesFullscreen = drawOnCanvas(fullscreenCanvasRef.current, particlesFullscreen);
                    }
                };

                draw();
            };

            // File validation helper
            const validateFile = (file) => {
                // Check for empty files
                if (file.size === 0) {
                    return { valid: false, reason: 'empty', file };
                }
                
                // Check MIME type
                if (!SUPPORTED_MIME_TYPES.includes(file.type)) {
                    return { valid: false, reason: 'unsupported', file };
                }
                
                return { valid: true, file };
            };

            // File size formatter
            const formatFileSize = (bytes) => {
                if (bytes === 0) return '0 B';
                if (bytes < 1024) return `${bytes} B`;
                if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
                return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
            };

            // File type formatter
            const formatFileType = (mimeType) => {
                const typeMap = {
                    'audio/mpeg': 'MP3',
                    'audio/wav': 'WAV',
                    'audio/wave': 'WAV',
                    'audio/ogg': 'OGG',
                    'audio/x-wav': 'WAV'
                };
                return typeMap[mimeType] || 'Audio';
            };

            const SESSION_DEFAULT_PROFILE = 'default';

            const getPresetLabel = React.useCallback(() => {
                const presetMatch = allPresets.find(preset => preset.id === activePresetId);
                if (presetMatch) {
                    return presetMatch.name || presetMatch.label || 'Custom preset';
                }
                const defaultMode = MODE_LIBRARY.find(mode => mode.id === activePresetId);
                if (defaultMode) {
                    return defaultMode.label;
                }
                return MODE_LIBRARY[modeIndex]?.label || 'Focus';
            }, [activePresetId, allPresets, modeIndex]);

            const getSessionLoggingApi = () => {
                if (typeof window === 'undefined' || typeof indexedDB === 'undefined') {
                    return null;
                }
                return window.SessionLogging || null;
            };

            const handleSessionError = React.useCallback(async (error, phase) => {
                if (!error) {
                    return;
                }
                console.error(`[SessionLogger] Error during ${phase}:`, error);
                if (error.name === 'QuotaExceededError') {
                    const sessionApi = getSessionLoggingApi();
                    if (sessionApi?.estimateStorageUsage) {
                        try {
                            const stats = await sessionApi.estimateStorageUsage();
                            const approx = formatFileSize(stats.approxBytes || 0);
                            showToast(`Session log full (~${approx}). Use the Insights panel to clear history.`, 'warning');
                            return;
                        } catch (statsError) {
                            console.warn('[SessionLogger] Failed to estimate storage usage:', statsError);
                        }
                    }
                    showToast('Session log full. Use Insights actions to clear old sessions.', 'warning');
                } else if (error.name === 'VersionError') {
                    showToast('Session log corrupted. Rebuilding...', 'error');
                    try {
                        const sessionApi = getSessionLoggingApi();
                        if (sessionApi?.resetDatabase) {
                            await sessionApi.resetDatabase();
                            showToast('Session log reset. Try your action again.', 'success');
                        }
                    } catch (resetErr) {
                        console.error('[SessionLogger] Failed to reset storage:', resetErr);
                    }
                } else {
                    showToast('Session logging unavailable. See console for details.', 'warning');
                }
            }, [showToast]);

            const startSession = React.useCallback(async ({ track, ritualUsed = false } = {}) => {
                const sessionApi = getSessionLoggingApi();
                if (!sessionApi) {
                    return null;
                }
                if (!track) {
                    console.warn('[SessionLogger] Missing track metadata; session not recorded.');
                    return null;
                }
                if (activeSessionIdRef.current) {
                    return activeSessionIdRef.current;
                }

                const record = {
                    profileId: SESSION_DEFAULT_PROFILE,
                    timestamp: Date.now(),
                    trackId: track.id ?? track.url ?? track.name ?? `track-${Date.now()}`,
                    trackName: track.name || track.label || 'Untitled Track',
                    presetId: activePresetId,
                    presetLabel: getPresetLabel(),
                    ritualUsed: Boolean(ritualUsed),
                    duration: 0,
                    hrAvg: null,
                    hrMax: null,
                    moodBefore: null,
                    moodAfter: null,
                    notes: '',
                    endedManually: false
                };

                try {
                    if (performance?.mark) {
                        performance.mark('session-start-begin');
                    }
                    const sessionId = await sessionApi.addSession(record);
                    setActiveSessionId(sessionId);
                    activeSessionIdRef.current = sessionId;
                    if (performance?.mark) {
                        performance.mark('session-start-end');
                        const measure = performance.measure('session-start', 'session-start-begin', 'session-start-end');
                        performance.clearMarks('session-start-begin');
                        performance.clearMarks('session-start-end');
                        performance.clearMeasures('session-start');
                        console.log(`[SessionLogger] Session started: ${sessionId} in ${measure.duration.toFixed(2)}ms`);
                    } else {
                        console.log(`[SessionLogger] Session started: ${sessionId}`);
                    }
                    return sessionId;
                } catch (error) {
                    await handleSessionError(error, 'start');
                    return null;
                }
            }, [activePresetId, getPresetLabel, handleSessionError]);

            const endSession = React.useCallback(async (manual = false) => {
                const sessionApi = getSessionLoggingApi();
                if (!sessionApi || !activeSessionIdRef.current) {
                    return;
                }
                const sessionId = activeSessionIdRef.current;
                setActiveSessionId(null);
                activeSessionIdRef.current = null;
                try {
                    const session = await sessionApi.getSession(sessionId);
                    if (!session) {
                        console.warn('[SessionLogger] Session missing during end call:', sessionId);
                        return;
                    }
                    const rawDuration = (Date.now() - session.timestamp) / 1000;
                    const durationSeconds = Number(rawDuration.toFixed(1));
                    await sessionApi.updateSession(sessionId, {
                        duration: durationSeconds,
                        endedManually: manual
                    });
                    console.log(`[SessionLogger] Session ended: ${sessionId}, duration: ${durationSeconds}s`);
                } catch (error) {
                    await handleSessionError(error, 'end');
                }
            }, [handleSessionError]);

            const clearProfileSessions = React.useCallback(async (profileId = SESSION_DEFAULT_PROFILE) => {
                const sessionApi = getSessionLoggingApi();
                if (!sessionApi) {
                    showToast('Session logging not supported in this browser.', 'warning');
                    return 0;
                }
                if (activeSessionIdRef.current) {
                    await endSession(true);
                }
                try {
                    const deletedCount = await sessionApi.clearProfile(profileId);
                    if (deletedCount > 0) {
                        showToast(`${deletedCount} sessions deleted`, 'success');
                    } else {
                        showToast('No sessions found for this profile.', 'info');
                    }
                    console.log(`[SessionLogger] Cleared ${deletedCount} sessions for profile "${profileId}"`);
                    return deletedCount;
                } catch (error) {
                    await handleSessionError(error, 'clear-profile');
                    return 0;
                }
            }, [endSession, handleSessionError, showToast]);

            const clearSessionsOlderThanDays = React.useCallback(async (days = 30, profileId = SESSION_DEFAULT_PROFILE) => {
                const sessionApi = getSessionLoggingApi();
                if (!sessionApi) {
                    showToast('Session logging not supported in this browser.', 'warning');
                    return 0;
                }
                try {
                    const deletedCount = await sessionApi.clearSessionsOlderThanDays(days, profileId);
                    if (deletedCount > 0) {
                        showToast(`${deletedCount} sessions older than ${days} days deleted`, 'success');
                    } else {
                        showToast(`No sessions older than ${days} days to delete.`, 'info');
                    }
                    console.log(`[SessionLogger] Cleared ${deletedCount} sessions older than ${days} days for "${profileId}"`);
                    return deletedCount;
                } catch (error) {
                    await handleSessionError(error, 'trim-old');
                    return 0;
                }
            }, [handleSessionError, showToast]);

            const handleClearSessions = async () => {
                if (isClearingSessions) {
                    return;
                }
                setIsClearingSessions(true);
                try {
                    await clearProfileSessions(SESSION_DEFAULT_PROFILE);
                } finally {
                    setIsClearingSessions(false);
                }
            };

            const handleTrimOldSessions = async () => {
                if (isTrimmingSessions) {
                    return;
                }
                setIsTrimmingSessions(true);
                try {
                    await clearSessionsOlderThanDays(30, SESSION_DEFAULT_PROFILE);
                } finally {
                    setIsTrimmingSessions(false);
                }
            };

            const addLocalFiles = (files) => {
                const fileArray = Array.from(files);
                
                try {
                    // Show progress indicator for large batches
                    if (fileArray.length > 5) {
                        setIsProcessingFiles(true);
                        setHeroMessage(`Adding ${fileArray.length} tracks...`);
                    }
                    
                    // Validate and filter files
                    const validFiles = [];
                    const rejectedFiles = [];
                    
                    fileArray.forEach(file => {
                        const validation = validateFile(file);
                        if (validation.valid) {
                            validFiles.push(file);
                        } else {
                            rejectedFiles.push({ 
                                name: file.name, 
                                reason: validation.reason 
                            });
                        }
                    });
                    
                    // Create playlist tracks from valid files
                    const newTracks = validFiles.map((file, index) => {
                        // Remove any audio extension, not just .mp3
                        const baseName = file.name.replace(/\.(mp3|wav|ogg)$/i, '');
                        return {
                            id: Date.now() + index,
                            name: baseName,
                            source: 'local',
                            file: file,
                            url: null,
                            lastPresetId: null, // Story 3-3: Track preset for auto-restore
                            preferredPresetId: null, // Story 3-3: User can pin preset (future)
                            metadata: {
                                size: file.size,
                                type: file.type,
                                lastModified: file.lastModified
                            }
                        };
                    });
                    
                    // Update playlist
                    if (newTracks.length > 0) {
                        setPlaylist(prev => [...prev, ...newTracks]);
                        setNeedsAudio(false);
                        
                        const trackWord = newTracks.length === 1 ? 'track' : 'tracks';
                        setHeroMessage(`Added ${newTracks.length} ${trackWord}. Pick a ritual and press Start.`);
                        setA11yAnnouncement(`${newTracks.length} ${trackWord} added to playlist`);
                    }
                    
                    // Show rejection toast if needed
                    if (rejectedFiles.length > 0) {
                        const emptyCount = rejectedFiles.filter(f => f.reason === 'empty').length;
                        const unsupportedCount = rejectedFiles.filter(f => f.reason === 'unsupported').length;
                        
                        let message = '';
                        if (emptyCount > 0) {
                            message += `${emptyCount} empty file${emptyCount > 1 ? 's' : ''} rejected. `;
                        }
                        if (unsupportedCount > 0) {
                            message += `${unsupportedCount} unsupported file${unsupportedCount > 1 ? 's' : ''} rejected. Use MP3, WAV, or OGG.`;
                        }
                        
                        showToast(message, 'warning');
                        setA11yAnnouncement(message);
                    }
                } finally {
                    // Always hide progress indicator, even if errors occur
                    setIsProcessingFiles(false);
                }
            };

            const handleDrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                const files = e.dataTransfer.files;
                if (files && files.length > 0) {
                    addLocalFiles(files);
                }
                setDragActive(false);
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!dragActive) {
                    setDragActive(true);
                }
            };

            const handleDragEnter = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setDragActive(true);
            };

            const handleDragLeave = (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (e.relatedTarget && e.currentTarget.contains(e.relatedTarget)) {
                    return;
                }
                setDragActive(false);
            };

            // URL format validator
            const isValidUrl = (str) => {
                try {
                    const url = new URL(str);
                    return url.protocol === 'http:' || url.protocol === 'https:';
                } catch {
                    return false;
                }
            };

            // Unsupported service detector
            const detectUnsupportedService = (url) => {
                const urlLower = url.toLowerCase();
                if (urlLower.includes('youtube.com') || urlLower.includes('youtu.be')) {
                    return { service: 'YouTube', supported: false };
                }
                if (urlLower.includes('spotify.com')) {
                    return { service: 'Spotify', supported: false };
                }
                return { supported: true };
            };

            // Stream URL validator (async)
            const validateStreamUrl = async (url) => {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                try {
                    const response = await fetch(url, {
                        method: 'HEAD',
                        mode: 'cors',
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                    
                    if (response.ok) {
                        return { valid: true, url };
                    } else {
                        return { 
                            valid: false, 
                            reason: 'unreachable',
                            status: response.status 
                        };
                    }
                } catch (err) {
                    clearTimeout(timeoutId);
                    
                    if (err.name === 'AbortError') {
                        return { valid: false, reason: 'timeout' };
                    }
                    
                    // CORS or network error
                    return { valid: false, reason: 'cors', error: err };
                }
            };

            const addUrl = async () => {
                const url = urlInput.trim();
                
                // Ignore empty input
                if (!url) return;
                
                // 1. Format validation
                if (!isValidUrl(url)) {
                    showToast('Invalid URL format. Use: https://example.com/song.mp3', 'error');
                    setA11yAnnouncement('Invalid URL format');
                    return;
                }
                
                // 2. Unsupported service detection
                const serviceCheck = detectUnsupportedService(url);
                if (!serviceCheck.supported) {
                    showToast(
                        `${serviceCheck.service} playback requires authenticated proxy. Direct MP3 URLs only.`,
                        'warning'
                    );
                    setA11yAnnouncement(`${serviceCheck.service} not supported`);
                    return;
                }
                
                // 3. Show validating state
                setIsValidatingUrl(true);
                setHeroMessage('Validating stream URL...');
                
                // 4. HEAD request validation with cleanup tracking
                try {
                    const validation = await validateStreamUrl(url);
                    
                    // Check if component still mounted
                    if (!urlValidationControllerRef.current) {
                        return; // Component unmounted during validation
                    }
                    
                    setIsValidatingUrl(false);
                    
                    if (!validation.valid) {
                        let message = '';
                        
                        switch (validation.reason) {
                            case 'cors':
                                message = 'Stream blocked by CORS. Use direct MP3 link or enable server CORS.';
                                break;
                            case 'timeout':
                                message = 'Request timeout (5s). Server unreachable or slow.';
                                break;
                            case 'unreachable':
                                message = `Stream unreachable (${validation.status}). Check URL and try again.`;
                                break;
                            default:
                                message = 'Unable to validate stream. Check URL.';
                        }
                        
                        showToast(message, 'error');
                        setA11yAnnouncement(message);
                        setHeroMessage('Stream validation failed. Try another URL.');
                        return;
                    }
                    
                    // 5. Add validated URL to playlist
                    const newTrack = {
                        id: Date.now(),
                        name: 'Remote Track',
                        source: 'url',
                        url: url,
                        originalUrl: url,
                        lastPresetId: null, // Story 3-3: Track preset for auto-restore
                        preferredPresetId: null // Story 3-3: User can pin preset (future)
                    };
                    
                    setPlaylist(prev => [...prev, newTrack]);
                    setUrlInput('');
                    setNeedsAudio(false);
                    setHeroMessage('Stream validated and added. Start your ritual to hear it.');
                    setA11yAnnouncement('Stream added to playlist');
                } catch (err) {
                    // Handle unexpected errors
                    if (urlValidationControllerRef.current) {
                        setIsValidatingUrl(false);
                        showToast('Validation error. Please try again.', 'error');
                    }
                }
            };

            const playTrack = async (index, options = {}) => {
                const { ritualUsed, shouldEndActiveSession = true } = options;
                const activePlaylist = playlistRef.current || playlist;
                const track = activePlaylist[index];
                if (!track) return;

                if (typeof ritualUsed !== 'undefined') {
                    sessionRitualFlagRef.current = ritualUsed;
                }

                if (activeSessionIdRef.current && shouldEndActiveSession) {
                    await endSession(true);
                }
                
                // Story 3-3: Auto-restore last-used preset for this track
                if (track.lastPresetId) {
                    const presets = getAllPresets();
                    const savedPreset = presets.find(p => p.id === track.lastPresetId);
                    
                    if (savedPreset) {
                        // Restore the preset if it's different from current
                        if (activePresetId !== track.lastPresetId) {
                            applyPreset(savedPreset.preset, savedPreset.id);
                            showToast(`Restored ${savedPreset.name} preset for "${track.name}"`, 'info');
                            setA11yAnnouncement(`Restored ${savedPreset.name} preset`);
                        }
                    } else {
                        // Preset was deleted, fallback to focus
                        console.warn(`[AutoRestore] Preset ${track.lastPresetId} not found for track ${track.name}, using Focus`);
                        const focusMode = MODE_LIBRARY[0];
                        applyPreset(focusMode.preset, focusMode.id);
                    }
                } else {
                    // First time playing this track - save current preset
                    setPlaylist(prev => prev.map((t, i) => 
                        i === index ? { ...t, lastPresetId: activePresetId } : t
                    ));
                    console.log(`[AutoRestore] Saved preset ${activePresetId} for track ${track.name}`);
                }
                
                const audio = prepareAudioElement();
                
                const handleLoadedMetadata = () => {
                    setupAudioGraph(audio);
                    audio.play().then(() => {
                        setIsPlaying(true);
                        const resolvedRitualUsed = typeof ritualUsed === 'undefined'
                            ? sessionRitualFlagRef.current
                            : ritualUsed;
                        startSession({ track, ritualUsed: resolvedRitualUsed });
                    }).catch(err => {
                        console.error('Playback error:', err);
                        alert('Playback error. If you opened this from file://, please run a local web server.\n\nQuick fix: Run "python3 -m http.server 8000" in this folder');
                    });
                };
                
                audio.addEventListener('loadedmetadata', handleLoadedMetadata, { once: true });
                
                const assignSource = () => {
                    if (track.source === 'local' && track.file) {
                        try {
                            const blobUrl = URL.createObjectURL(track.file);
                            currentBlobUrlRef.current = blobUrl;
                            audio.src = blobUrl;
                        } catch (err) {
                            console.error('Error creating blob URL:', err);
                            audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
                            alert('Error loading file. Please serve this HTML from a web server (see console for instructions).\n\nQuick fix: Run "python3 -m http.server 8000" in this folder, then open http://localhost:8000/8d-player-live.html');
                            return false;
                        }
                    } else if (track.source === 'youtube') {
                        audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
                        alert('YouTube playback requires a backend server or YouTube API. Please use direct MP3 URLs or local files.');
                        teardownAudioElement();
                        return false;
                    } else if (track.url) {
                        audio.src = track.url;
                    } else {
                        audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
                        alert('Invalid track source');
                        teardownAudioElement();
                        return false;
                    }
                    return true;
                };
                
                const assigned = assignSource();
                if (!assigned) {
                    return;
                }
                
                audio.load();
                
                currentTrackIndexRef.current = index;
                setCurrentTrackIndex(index);
                setRitualStatus('active');
                setHeroMessage(`Now playing ${track.name} • ${selectedMode.label}`);
                setNeedsAudio(false);
            };

            playNextRef.current = (options = {}) => {
                const { shouldEndActiveSession = true } = options;
                const playlistSnapshot = playlistRef.current;
                if (!playlistSnapshot || playlistSnapshot.length === 0) {
                    return;
                }
                const indexSnapshot = currentTrackIndexRef.current;
                if (
                    indexSnapshot === null ||
                    indexSnapshot === undefined ||
                    indexSnapshot < 0 ||
                    indexSnapshot >= playlistSnapshot.length
                ) {
                    playTrack(0, { shouldEndActiveSession });
                    return;
                }
                const nextIndex = (indexSnapshot + 1) % playlistSnapshot.length;
                playTrack(nextIndex, { shouldEndActiveSession });
            };

            // ==================== TIMER FUNCTIONS ====================

            // Format seconds to MM:SS or HH:MM:SS
            const formatTimerDisplay = (totalSeconds) => {
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;

                if (hours > 0) {
                    return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            };

            // Sleep Timer Functions
            const startSleepTimer = () => {
                if (sleepTimerIntervalRef.current) {
                    clearInterval(sleepTimerIntervalRef.current);
                }

                setSleepTimerSeconds(sleepTimerDuration);
                setSleepTimerActive(true);
                showToast(`Sleep timer set for ${formatTimerDisplay(sleepTimerDuration)}`, 'info');

                sleepTimerIntervalRef.current = setInterval(() => {
                    setSleepTimerSeconds(prev => {
                        if (prev <= 1) {
                            // Timer finished - fade out and stop
                            clearInterval(sleepTimerIntervalRef.current);
                            sleepTimerIntervalRef.current = null;
                            setSleepTimerActive(false);

                            // Fade out audio over 5 seconds
                            if (audioElementRef.current && gainNodeRef.current) {
                                const fadeInterval = setInterval(() => {
                                    if (gainNodeRef.current && gainNodeRef.current.gain.value > 0.05) {
                                        gainNodeRef.current.gain.value *= 0.9;
                                    } else {
                                        clearInterval(fadeInterval);
                                        if (audioElementRef.current) {
                                            audioElementRef.current.pause();
                                            setIsPlaying(false);
                                        }
                                        showToast('Sleep timer ended. Sweet dreams!', 'success');
                                    }
                                }, 200);
                            }
                            return 0;
                        }
                        return prev - 1;
                    });
                }, 1000);
            };

            const stopSleepTimer = () => {
                if (sleepTimerIntervalRef.current) {
                    clearInterval(sleepTimerIntervalRef.current);
                    sleepTimerIntervalRef.current = null;
                }
                setSleepTimerActive(false);
                setSleepTimerSeconds(0);
                showToast('Sleep timer cancelled', 'info');
            };

            // Pomodoro Timer Functions
            const startPomodoro = () => {
                if (pomodoroIntervalRef.current) {
                    clearInterval(pomodoroIntervalRef.current);
                }

                // Store current mode to restore after break
                previousModeRef.current = activePresetId;

                setPomodoroPhase('work');
                setPomodoroSeconds(pomodoroWorkDuration * 60);
                setPomodoroActive(true);
                setPomodoroCycles(0);
                showToast(`Pomodoro started: ${pomodoroWorkDuration} min work`, 'info');

                // Start playing if not already
                if (!isPlaying && playlist.length > 0) {
                    togglePlayPause();
                }

                pomodoroIntervalRef.current = setInterval(() => {
                    setPomodoroSeconds(prev => {
                        if (prev <= 1) {
                            // Phase ended
                            setPomodoroPhase(currentPhase => {
                                if (currentPhase === 'work') {
                                    // Work phase ended, start break
                                    setPomodoroCycles(c => c + 1);
                                    showToast('Work phase complete! Take a break.', 'success');

                                    // Handle break action
                                    if (pomodoroBreakAction === 'pause') {
                                        if (audioElementRef.current) {
                                            audioElementRef.current.pause();
                                            setIsPlaying(false);
                                        }
                                    } else if (pomodoroBreakAction === 'energize') {
                                        // Switch to energize mode for break
                                        const energizeIndex = MODE_LIBRARY.findIndex(m => m.id === 'energize');
                                        if (energizeIndex >= 0) {
                                            setModeIndex(energizeIndex);
                                            setActivePresetId('energize');
                                        }
                                    } else if (pomodoroBreakAction === 'calm') {
                                        // Switch to calm mode for break
                                        const calmIndex = MODE_LIBRARY.findIndex(m => m.id === 'calm');
                                        if (calmIndex >= 0) {
                                            setModeIndex(calmIndex);
                                            setActivePresetId('calm');
                                        }
                                    }

                                    return 'break';
                                } else {
                                    // Break ended, start work
                                    showToast('Break over! Time to focus.', 'info');

                                    // Restore previous mode
                                    if (previousModeRef.current) {
                                        const prevIndex = MODE_LIBRARY.findIndex(m => m.id === previousModeRef.current);
                                        if (prevIndex >= 0) {
                                            setModeIndex(prevIndex);
                                            setActivePresetId(previousModeRef.current);
                                        }
                                    }

                                    // Resume playing if paused during break
                                    if (!isPlaying && playlist.length > 0 && audioElementRef.current) {
                                        audioElementRef.current.play();
                                        setIsPlaying(true);
                                    }

                                    return 'work';
                                }
                            });

                            // Return the new duration
                            return pomodoroPhase === 'work'
                                ? pomodoroBreakDuration * 60
                                : pomodoroWorkDuration * 60;
                        }
                        return prev - 1;
                    });
                }, 1000);
            };

            const stopPomodoro = () => {
                if (pomodoroIntervalRef.current) {
                    clearInterval(pomodoroIntervalRef.current);
                    pomodoroIntervalRef.current = null;
                }

                // Restore previous mode if we were on break
                if (pomodoroPhase === 'break' && previousModeRef.current) {
                    const prevIndex = MODE_LIBRARY.findIndex(m => m.id === previousModeRef.current);
                    if (prevIndex >= 0) {
                        setModeIndex(prevIndex);
                        setActivePresetId(previousModeRef.current);
                    }
                }

                setPomodoroActive(false);
                setPomodoroPhase('work');
                setPomodoroSeconds(0);
                showToast('Pomodoro stopped', 'info');
            };

            // Cleanup timers on unmount
            useEffect(() => {
                return () => {
                    if (sleepTimerIntervalRef.current) {
                        clearInterval(sleepTimerIntervalRef.current);
                    }
                    if (pomodoroIntervalRef.current) {
                        clearInterval(pomodoroIntervalRef.current);
                    }
                };
            }, []);

            // ==================== END TIMER FUNCTIONS ====================

            // ==================== PLAYLIST SAVE/LOAD FUNCTIONS ====================

            const savePlaylist = (name) => {
                if (!name.trim() || playlist.length === 0) return;

                // For local files, we can only save metadata (not the file itself)
                // For streams, we save the URL
                const playlistData = playlist.map(track => ({
                    name: track.name,
                    source: track.source,
                    url: track.url || null,
                    // Can't persist File objects, so local files won't restore
                    isLocal: track.source === 'local'
                }));

                const newPlaylist = {
                    id: Date.now(),
                    name: name.trim(),
                    tracks: playlistData,
                    trackCount: playlist.length,
                    createdAt: new Date().toISOString()
                };

                setSavedPlaylists(prev => {
                    const updated = [...prev, newPlaylist];
                    try {
                        localStorage.setItem('mpe_8d_saved_playlists', JSON.stringify(updated));
                    } catch (e) {
                        console.warn('Failed to save playlist:', e);
                    }
                    return updated;
                });

                setNewPlaylistName('');
                showToast(`Playlist "${name}" saved!`, 'success');
            };

            const loadPlaylist = (savedPlaylist) => {
                // Filter out local files (can't be restored) and load streams
                const restoredTracks = savedPlaylist.tracks
                    .filter(track => !track.isLocal && track.url)
                    .map((track, index) => ({
                        id: Date.now() + index,
                        name: track.name,
                        source: track.source,
                        url: track.url,
                        file: null
                    }));

                const localCount = savedPlaylist.tracks.filter(t => t.isLocal).length;

                if (restoredTracks.length === 0 && localCount > 0) {
                    showToast(`This playlist only had local files which can't be restored. Add them again.`, 'warning');
                    setShowPlaylistModal(false);
                    return;
                }

                setPlaylist(restoredTracks);
                setCurrentTrackIndex(null);
                setShowPlaylistModal(false);

                if (localCount > 0) {
                    showToast(`Loaded ${restoredTracks.length} tracks. ${localCount} local files need to be re-added.`, 'info');
                } else {
                    showToast(`Loaded "${savedPlaylist.name}" with ${restoredTracks.length} tracks`, 'success');
                }
            };

            const deletePlaylist = (playlistId) => {
                setSavedPlaylists(prev => {
                    const updated = prev.filter(p => p.id !== playlistId);
                    try {
                        localStorage.setItem('mpe_8d_saved_playlists', JSON.stringify(updated));
                    } catch (e) {
                        console.warn('Failed to update saved playlists:', e);
                    }
                    return updated;
                });
                showToast('Playlist deleted', 'info');
            };

            // ==================== END PLAYLIST FUNCTIONS ====================

            const togglePlayPause = () => {
                if (!audioElementRef.current) {
                    if (playlist.length > 0) {
                        playTrack(0, { ritualUsed: sessionRitualFlagRef.current });
                    }
                    return;
                }
                
                const audio = audioElementRef.current;
                
                if (isPlaying) {
                    audio.pause();
                    setIsPlaying(false);
                    endSession(true);
                } else {
                    audio.play().then(() => {
                        setIsPlaying(true);
                        if (!activeSessionIdRef.current && nowPlayingTrack) {
                            startSession({ track: nowPlayingTrack, ritualUsed: sessionRitualFlagRef.current });
                        }
                    });
                }
            };

            const playNext = () => {
                if (typeof playNextRef.current === 'function') {
                    playNextRef.current();
                }
            };

            const playPrevious = () => {
                if (currentTrackIndex === null || playlist.length === 0) {
                    return;
                }
                const prevIndex = currentTrackIndex === 0 ? playlist.length - 1 : currentTrackIndex - 1;
                playTrack(prevIndex);
            };

            // Rate a track for the current mode
            // rating: 'boost' | 'neutral' | 'remove'
            const rateTrack = (trackName, rating, modeId) => {
                const currentMode = modeId || activePresetId;
                setTrackRatings(prev => {
                    const updated = {
                        ...prev,
                        [trackName]: {
                            ...(prev[trackName] || {}),
                            [currentMode]: rating
                        }
                    };
                    // Persist to localStorage
                    try {
                        localStorage.setItem('mpe_8d_track_ratings', JSON.stringify(updated));
                    } catch (e) {
                        console.warn('Failed to save track ratings:', e);
                    }
                    return updated;
                });

                // If rating is 'remove', remove from playlist after a brief dim animation
                if (rating === 'remove') {
                    const track = playlist.find(t => t.name === trackName);
                    if (track) {
                        // Small delay for visual feedback
                        setTimeout(() => {
                            removeFromPlaylist(track.id);
                        }, 600);
                    }
                }
            };

            // Get the rating for a track in current mode
            const getTrackRating = (trackName) => {
                return trackRatings[trackName]?.[activePresetId] || null;
            };

            const removeFromPlaylist = async (id) => {
                const currentList = playlist;
                const removedIndex = currentList.findIndex(track => track.id === id);
                if (removedIndex === -1) {
                    return;
                }
                const nextPlaylist = currentList.filter(track => track.id !== id);
                setPlaylist(nextPlaylist);

                const prevIndex = currentTrackIndex;
                const removedWasCurrent = prevIndex === removedIndex;
                if (removedWasCurrent) {
                    await endSession(true);
                    teardownAudioElement();
                    disposeAudioGraph();
                    setIsPlaying(false);
                }

                let nextIndex = prevIndex;
                if (nextPlaylist.length === 0) {
                    nextIndex = null;
                } else if (removedWasCurrent) {
                    nextIndex = Math.min(removedIndex, nextPlaylist.length - 1);
                } else if (typeof prevIndex === 'number' && removedIndex < prevIndex) {
                    nextIndex = Math.max(prevIndex - 1, 0);
                } else if (typeof prevIndex === 'number' && prevIndex >= nextPlaylist.length) {
                    nextIndex = nextPlaylist.length - 1;
                }

                if (nextIndex !== prevIndex) {
                    currentTrackIndexRef.current = nextIndex;
                    setCurrentTrackIndex(nextIndex);
                }
            };

            const handleSeekChange = (event) => {
                if (!audioElementRef.current) return;
                const nextTime = parseFloat(event.target.value);
                if (Number.isNaN(nextTime)) return;
                audioElementRef.current.currentTime = nextTime;
                setCurrentTime(nextTime);
            };

            const ensurePlaylistReady = () => {
                if (playlist.length === 0) {
                    setNeedsAudio(true);
                    setHeroMessage('Add a local file or stream to begin this ritual.');
                    if (dropZoneRef.current) {
                        dropZoneRef.current.focus();
                    }
                    return false;
                }
                return true;
            };

            const launchRitualPlayback = ({ ritualUsed } = {}) => {
                const resolvedRitualUsed = typeof ritualUsed === 'boolean' ? ritualUsed : ritualStatus === 'breathing';
                sessionRitualFlagRef.current = resolvedRitualUsed;

                // Log ritual completion telemetry
                try {
                    const ritualEndTs = Date.now();
                    const ritualEvent = {
                        type: 'FOCUS_RITUAL_COMPLETED',
                        timestamp: ritualEndTs,
                        modeId: selectedMode.id,
                        modeLabel: selectedMode.label,
                        presetApplied: selectedMode.id,
                        duration: HERO_BREATH_DURATION
                    };
                    console.log('[SessionLogger]', ritualEvent);
                    // Future: Store in IndexedDB sessions store
                } catch (e) {
                    console.warn('Failed to log ritual completion', e);
                }

                setRitualStatus('active');
                setHeroMessage(`Ritual active — ${selectedMode.label} preset live.`);
                setNeedsAudio(false);
                setBreathingPhase('');
                
                if (currentTrackIndex === null) {
                    playTrack(0, { ritualUsed: resolvedRitualUsed });
                    return;
                }
                const audio = audioElementRef.current;
                if (audio) {
                    audio.play().then(() => {
                        setIsPlaying(true);
                        if (nowPlayingTrack) {
                            startSession({ track: nowPlayingTrack, ritualUsed: resolvedRitualUsed });
                        }
                    }).catch(() => {
                        setHeroMessage('Press play to continue your ritual.');
                    });
                } else {
                    playTrack(currentTrackIndex, { ritualUsed: resolvedRitualUsed });
                }
            };

            const startRitual = () => {
                if (!ensurePlaylistReady()) {
                    return;
                }
                
                // Check if skip preference is enabled
                if (skipRitualPref) {
                    // Log skip telemetry
                    try {
                        const skipEvent = {
                            type: 'RITUAL_SKIPPED',
                            timestamp: Date.now(),
                            modeId: selectedMode.id,
                            reason: 'skip-preference-enabled'
                        };
                        console.log('[SessionLogger]', skipEvent);
                    } catch (e) {
                        console.warn('Failed to log ritual skip', e);
                    }
                    launchRitualPlayback({ ritualUsed: false });
                    return;
                }
                
                clearRitualTimers();
                setRitualStatus('breathing');
                setHeroMessage(`Breathe in...`);
                setRitualCountdown(HERO_BREATH_DURATION);
                setBreathingPhase('inhale');
                
                // Log ritual start telemetry
                try {
                    const startEvent = {
                        type: 'RITUAL_STARTED',
                        timestamp: Date.now(),
                        modeId: selectedMode.id,
                        modeLabel: selectedMode.label,
                        duration: HERO_BREATH_DURATION
                    };
                    console.log('[SessionLogger]', startEvent);
                } catch (e) {
                    console.warn('Failed to log ritual start', e);
                }
                
                // Countdown timer (1s intervals)
                ritualIntervalRef.current = setInterval(() => {
                    setRitualCountdown((prev) => {
                        const next = Math.max(prev - 1, 0);
                        if (next === 0) {
                            clearInterval(ritualIntervalRef.current);
                            ritualIntervalRef.current = null;
                        }
                        return next;
                    });
                }, 1000);
                
                // 4-2-4 breathing phase cycle (6s total: 2s in, 1s hold, 2s out, 1s hold)
                // Repeat ~3.33 times over 20 seconds
                let phaseStep = 0;
                breathingPhaseIntervalRef.current = setInterval(() => {
                    phaseStep++;
                    const cyclePosition = phaseStep % 6;
                    
                    if (cyclePosition === 0 || cyclePosition === 1) {
                        // Inhale (2 seconds)
                        setBreathingPhase('inhale');
                        setHeroMessage('Breathe in...');
                    } else if (cyclePosition === 2) {
                        // Hold after inhale (1 second)
                        setBreathingPhase('hold-in');
                        setHeroMessage('Hold...');
                    } else if (cyclePosition === 3 || cyclePosition === 4) {
                        // Exhale (2 seconds)
                        setBreathingPhase('exhale');
                        setHeroMessage('Breathe out...');
                    } else if (cyclePosition === 5) {
                        // Hold after exhale (1 second)
                        setBreathingPhase('hold-out');
                        setHeroMessage('Hold...');
                    }
                }, 1000);
                
                // Auto-launch after 20 seconds
                ritualTimeoutRef.current = setTimeout(() => {
                    clearRitualTimers();
                    launchRitualPlayback({ ritualUsed: true });
                }, HERO_BREATH_DURATION * 1000);
            };

            const skipRitual = () => {
                if (!ensurePlaylistReady()) {
                    return;
                }
                
                // Log skip telemetry
                try {
                    const skipEvent = {
                        type: 'RITUAL_SKIPPED',
                        timestamp: Date.now(),
                        modeId: selectedMode.id,
                        reason: 'user-skip-button'
                    };
                    console.log('[SessionLogger]', skipEvent);
                } catch (e) {
                    console.warn('Failed to log ritual skip', e);
                }
                
                clearRitualTimers();
                setRitualCountdown(0);
                setBreathingPhase('');
                launchRitualPlayback({ ritualUsed: false });
            };

            const toggleSkipRitualPref = () => {
                const newValue = !skipRitualPref;
                setSkipRitualPref(newValue);
                try {
                    if (newValue) {
                        localStorage.setItem('skipBreathingRitual', 'true');
                    } else {
                        localStorage.removeItem('skipBreathingRitual');
                    }
                } catch (e) {
                    console.warn('Failed to persist skip preference', e);
                }
            };

            // Story 3-1: Apply preset configuration to all audio parameters
            const applyPreset = (preset, presetId) => {
                performance.mark('preset-apply-start');
                
                // Batch all parameter updates (React 18 auto-batches in event handlers)
                setSpeed(preset.speed);
                setIntensity(preset.intensity);
                setSpatialDepth(preset.spatialDepth);
                setMovementPattern(preset.movement);
                setBinauralEnabled(preset.binaural.enabled);
                setBinauralFreq(preset.binaural.freq);
                setNoiseType(preset.noise.type);
                setNoiseVolume(preset.noise.volume);
                setVisualWaveGain(preset.noise.volume);

                // Apply spatial audio settings if present
                if (preset.spatial) {
                    setItdAmount(preset.spatial.itdAmount ?? 0.7);
                    setHeadShadow(preset.spatial.headShadow ?? 0.5);
                    setDirectionalDepth(preset.spatial.directionalDepth ?? 0.15);
                    setCrossBleed(preset.spatial.crossBleed ?? 0);
                    setPanCurve(preset.spatial.panCurve ?? 2.0);
                    setBackDepth(preset.spatial.backDepth ?? 0.55);
                    setHardPanThreshold(preset.spatial.hardPanThreshold ?? 0.1);
                }

                // Update active preset tracking
                setActivePresetId(presetId);
                
                // Story 3-3: Update current track's lastPresetId when preset changes
                if (currentTrackIndex !== null && playlist[currentTrackIndex]) {
                    setPlaylist(prev => prev.map((track, i) => 
                        i === currentTrackIndex ? { ...track, lastPresetId: presetId } : track
                    ));
                    console.log(`[AutoRestore] Updated track ${playlist[currentTrackIndex].name} lastPresetId to ${presetId}`);
                }
                
                // Log preset change event
                logPresetChange(presetId);
                
                performance.mark('preset-apply-end');
                const measure = performance.measure('preset-apply', 'preset-apply-start', 'preset-apply-end');
                console.log(`[Performance] Preset applied in ${measure.duration.toFixed(2)}ms`);
                
                // Restart rotation with new settings if playing
                if (isPlaying) {
                    startRotation();
                }
            };

            // Update effects in real-time
            useEffect(() => {
                if (isPlaying) {
                    startRotation();
                }
            }, [speed, intensity, movementPattern]);

            useEffect(() => {
                const nodes = rotationNodesRef.current;
                if (!nodes) {
                    return;
                }
                if (nodes.delayGainLeft) {
                    nodes.delayGainLeft.gain.value = 0.05 * spatialDepth;
                }
                if (nodes.delayGainRight) {
                    nodes.delayGainRight.gain.value = 0.05 * spatialDepth;
                }
                if (nodes.crossGainLeft) {
                    nodes.crossGainLeft.gain.value = 0.03 * spatialDepth;
                }
                if (nodes.crossGainRight) {
                    nodes.crossGainRight.gain.value = 0.03 * spatialDepth;
                }
            }, [spatialDepth]);

            useEffect(() => {
                visualWaveGainRef.current = visualWaveGain;
            }, [visualWaveGain]);

            useEffect(() => {
                visualizerTypeRef.current = visualizerType;
            }, [visualizerType]);

            useEffect(() => {
                if (gainChainRef.current) {
                    gainChainRef.current.setVolume(volume);
                }
            }, [volume]);

            useEffect(() => {
                syncBinauralChain();
            }, [binauralEnabled, binauralFreq]);

            useEffect(() => {
                syncNoiseLayer();
            }, [noiseType, noiseVolume]);

            const formatTime = (seconds) => {
                if (!seconds || isNaN(seconds)) return '0:00';
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            };

            const getTotalDuration = () => {
                return playlist.length * 3.5; // Estimate 3.5 minutes per track
            };

            const getBinauralDescription = (freq) => {
                if (freq <= 4) return 'Delta (Sleep)';
                if (freq <= 8) return 'Theta (Meditation)';
                if (freq <= 14) return 'Alpha (Relaxation)';
                if (freq <= 30) return 'Beta (Focus)';
                return 'Gamma (Peak Focus)';
            };

            const dropZoneClasses = ['drop-zone'];
            if (needsAudio) {
                dropZoneClasses.push('drop-zone--attention');
            }
            if (dragActive) {
                dropZoneClasses.push('drop-zone--hover');
            }

return (
                <div className="screen">
                    {/* First Run Calibration Prompt Modal */}
                    {showFirstRunPrompt && (
                        <div style={{
                            position: 'fixed',
                            top: 0,
                            left: 0,
                            right: 0,
                            bottom: 0,
                            background: 'rgba(0,0,0,0.85)',
                            zIndex: 10000,
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            padding: '20px'
                        }}>
                            <div style={{
                                background: 'var(--card)',
                                borderRadius: '16px',
                                padding: '24px',
                                maxWidth: '450px',
                                width: '100%',
                                border: '2px solid var(--accent)',
                                boxShadow: '0 20px 60px rgba(0,0,0,0.5)'
                            }}>
                                <h2 style={{ margin: '0 0 16px 0', color: 'var(--accent)' }}>
                                    Welcome to 8D Ritual Shell!
                                </h2>
                                <p style={{ color: 'var(--text-secondary)', marginBottom: '16px', lineHeight: '1.5' }}>
                                    This app features <strong>personalized spatial audio</strong> designed to work with different hearing profiles, including APD (Auditory Processing Disorder).
                                </p>
                                <p style={{ color: 'var(--text-secondary)', marginBottom: '20px', lineHeight: '1.5' }}>
                                    Would you like to run the <strong>Calibration Wizard</strong> to optimize the audio for your unique hearing?
                                </p>
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>
                                    <button
                                        onClick={() => {
                                            setShowFirstRunPrompt(false);
                                            setShowSpatialTuner(true);
                                            // The SpatialAudioTuner has the calibration wizard inside
                                        }}
                                        style={{
                                            width: '100%',
                                            padding: '14px',
                                            background: 'var(--accent)',
                                            color: 'white',
                                            border: 'none',
                                            borderRadius: '8px',
                                            cursor: 'pointer',
                                            fontWeight: '600',
                                            fontSize: '1rem'
                                        }}
                                    >
                                        Yes, Calibrate Now
                                    </button>
                                    <button
                                        onClick={() => {
                                            setShowFirstRunPrompt(false);
                                            // Don't set dismissed - will show again next session
                                        }}
                                        style={{
                                            width: '100%',
                                            padding: '12px',
                                            background: 'rgba(255,255,255,0.1)',
                                            color: 'var(--text-primary)',
                                            border: '1px solid var(--border)',
                                            borderRadius: '8px',
                                            cursor: 'pointer',
                                            fontWeight: '500'
                                        }}
                                    >
                                        Later (Ask Again Next Time)
                                    </button>
                                    <button
                                        onClick={() => {
                                            setShowFirstRunPrompt(false);
                                            setCalibrationDismissed(true);
                                            try {
                                                localStorage.setItem('mpe_8d_calibration_dismissed', 'true');
                                            } catch (e) {}
                                        }}
                                        style={{
                                            width: '100%',
                                            padding: '12px',
                                            background: 'transparent',
                                            color: 'var(--text-secondary)',
                                            border: '1px solid var(--text-secondary)',
                                            borderRadius: '8px',
                                            cursor: 'pointer',
                                            fontWeight: '500'
                                        }}
                                    >
                                        No Thanks (Don't Ask Again)
                                    </button>
                                    <button
                                        onClick={() => {
                                            setShowFirstRunPrompt(false);
                                        }}
                                        style={{
                                            width: '100%',
                                            padding: '10px',
                                            background: 'transparent',
                                            color: 'var(--text-tertiary)',
                                            border: 'none',
                                            borderRadius: '8px',
                                            cursor: 'pointer',
                                            fontSize: '0.85rem'
                                        }}
                                    >
                                        Exit
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/*
                    KEYBOARD SHORTCUTS REFERENCE
                    ============================
                    
                    Navigation:
                    - Tab: Move forward through interactive elements
                    - Shift+Tab: Move backward through interactive elements
                    
                    Mode Selection (when mode chips focused):
                    - Arrow Left/Right: Navigate between Focus/Calm/Energize modes
                    - Enter or Space: Activate selected mode
                    
                    Toggle Buttons:
                    - Tab to reach: Dark mode, Reduced motion, High contrast toggles
                    - Enter or Space: Toggle the focused setting
                    
                    Playback Controls:
                    - Tab to reach: Play/Pause, Previous, Next buttons
                    - Enter or Space: Activate playback control
                    
                    Ritual Flow:
                    - Tab to reach: Start button or Skip button during ritual
                    - Enter or Space: Start ritual or skip breathing animation
                    
                    Accessibility Features:
                    - All state changes announced via screen reader
                    - Focus indicators visible on all interactive elements
                    - ≥48px tap targets for touch accessibility
                    */}
                    {/* Mobile Header - Only visible on mobile */}
                    <div className="mobile-header">
                        <div className="mobile-header-bar">
                            <span className="mobile-header-title">8D Ritual Shell</span>
                            <button
                                className="mobile-menu-btn"
                                onClick={() => setMobileMenuOpen(!mobileMenuOpen)}
                                aria-label="Toggle menu"
                                aria-expanded={mobileMenuOpen}
                            >
                                {mobileMenuOpen ? '✕' : '☰'}
                            </button>
                        </div>
                        <div className={`mobile-menu-dropdown ${mobileMenuOpen ? 'open' : ''}`}>
                            <div className="calibration-bar">
                                <span className={`calibration-status ${hasRunCalibration ? 'calibrated' : ''}`}>
                                    {hasRunCalibration ? '✓ Calibrated' : '⚠ Not calibrated'}
                                </span>
                                <button
                                    className={`calibration-btn ${!hasRunCalibration ? 'not-calibrated' : ''}`}
                                    onClick={() => { setShowSpatialTuner(true); setMobileMenuOpen(false); }}
                                >
                                    Audio Settings
                                </button>
                            </div>
                            <button type="button" className="primary-btn" aria-label="Install unified ritual shell">
                                📲 Install
                            </button>
                            <button
                                type="button"
                                onClick={() => { toggleDarkMode(); setMobileMenuOpen(false); }}
                                aria-pressed={darkMode}
                            >
                                {darkMode ? '☀️ Light mode' : '🌙 Dark mode'}
                            </button>
                            <button
                                type="button"
                                onClick={() => { toggleReducedMotion(); setMobileMenuOpen(false); }}
                                aria-pressed={reducedMotion}
                            >
                                {reducedMotion ? 'Motion reduced' : 'Motion on'}
                            </button>
                            <button
                                type="button"
                                onClick={() => { toggleHighContrast(); setMobileMenuOpen(false); }}
                                aria-pressed={highContrast}
                            >
                                {highContrast ? '◐ High contrast' : '○ Normal contrast'}
                            </button>
                        </div>
                    </div>

                    {/* Desktop Header - Single row */}
                    <header className="app-header">
                        {/* Title - Compact */}
                        <div>
                            <p className="eyebrow" style={{ marginBottom: '0' }}>Unified Ritual Player</p>
                            <h1 style={{ fontSize: '1.4rem', margin: '0' }}>8D Ritual Shell</h1>
                        </div>
                        {/* Actions row - Buttons + Calibration */}
                        <div style={{ display: 'flex', alignItems: 'center', gap: '8px', flexWrap: 'wrap' }}>
                            <button type="button" className="primary-btn" aria-label="Install">
                                📲 Install
                            </button>
                            <button type="button" onClick={toggleDarkMode} aria-pressed={darkMode} aria-label="Toggle dark mode" title={darkMode ? 'Light mode' : 'Dark mode'}>
                                {darkMode ? '☀️' : '🌙'}
                            </button>
                            <button type="button" onClick={toggleReducedMotion} aria-pressed={reducedMotion} aria-label="Toggle reduced motion" title={reducedMotion ? 'Motion reduced' : 'Motion on'}>
                                {reducedMotion ? '⏸' : '▶'}
                            </button>
                            <button type="button" onClick={toggleHighContrast} aria-pressed={highContrast} aria-label="Toggle high contrast" title={highContrast ? 'High contrast' : 'Normal contrast'}>
                                {highContrast ? '◐' : '○'}
                            </button>
                            <div style={{ height: '20px', width: '1px', background: 'var(--card-border)' }}></div>
                            <span style={{ fontSize: '0.75rem', color: hasRunCalibration ? '#4ade80' : 'var(--text-secondary)' }}>
                                {hasRunCalibration ? '✓ Calibrated' : '⚠'}
                            </span>
                            <button
                                onClick={() => setShowSpatialTuner(true)}
                                style={{
                                    padding: '6px 12px',
                                    background: hasRunCalibration ? 'rgba(74, 222, 128, 0.2)' : 'var(--accent-focus)',
                                    color: hasRunCalibration ? '#4ade80' : 'white',
                                    border: hasRunCalibration ? '1px solid #4ade80' : 'none',
                                    borderRadius: '6px',
                                    cursor: 'pointer',
                                    fontWeight: '500',
                                    fontSize: '0.8rem'
                                }}
                            >
                                Audio Settings
                            </button>
                        </div>
                    </header>

                    {/* Accessibility announcements for screen readers */}
                    <div 
                        className="sr-only" 
                        role="status" 
                        aria-live="polite" 
                        aria-atomic="true"
                    >
                        {a11yAnnouncement}
                    </div>

                    {/* Toast Notification */}
                    {toastMessage && (
                        <div 
                            className={`toast toast-${toastType}`}
                            role="alert"
                            aria-live="polite"
                            style={{
                                position: 'fixed',
                                bottom: '24px',
                                left: '50%',
                                transform: 'translateX(-50%)',
                                backgroundColor: toastType === 'warning' ? '#fbbf24' : 
                                               toastType === 'error' ? '#f87171' : 
                                               toastType === 'success' ? '#4ade80' : 
                                               '#a78bfa',
                                color: toastType === 'warning' || toastType === 'success' ? '#1f2937' : '#111827',
                                padding: '12px 24px',
                                borderRadius: '8px',
                                boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
                                fontWeight: '500',
                                fontSize: '14px',
                                maxWidth: '500px',
                                zIndex: 10000,
                                animation: 'slideUp 0.3s ease-out'
                            }}
                        >
                            {toastMessage}
                        </div>
                    )}

                    {/* Processing Spinner */}
                    {isProcessingFiles && (
                        <div 
                            className="processing-spinner"
                            role="status"
                            aria-live="polite"
                            style={{
                                position: 'fixed',
                                top: '50%',
                                left: '50%',
                                transform: 'translate(-50%, -50%)',
                                backgroundColor: 'rgba(0, 0, 0, 0.85)',
                                padding: '24px 32px',
                                borderRadius: '12px',
                                display: 'flex',
                                flexDirection: 'column',
                                alignItems: 'center',
                                gap: '16px',
                                zIndex: 9999
                            }}
                        >
                            <div style={{
                                width: '40px',
                                height: '40px',
                                border: '4px solid #4b5563',
                                borderTop: '4px solid #a78bfa',
                                borderRadius: '50%',
                                animation: 'spin 1s linear infinite'
                            }} />
                            <span style={{ color: '#f3f4f6', fontSize: '14px' }}>
                                Processing files...
                            </span>
                        </div>
                    )}

                    {showFileWarning && (
                        <div className="alert-inline" role="alert" style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: '12px' }}>
                            <span>Web Audio needs to run over HTTP. From repo root run <code>python3 -m http.server 8000</code> then open http://localhost:8000/index.html.</span>
                            <button
                                onClick={() => setShowFileWarning(false)}
                                style={{
                                    background: 'transparent',
                                    border: 'none',
                                    color: 'inherit',
                                    cursor: 'pointer',
                                    fontSize: '1.2rem',
                                    padding: '4px',
                                    opacity: 0.7
                                }}
                                aria-label="Dismiss"
                            >
                                ✕
                            </button>
                        </div>
                    )}

                    <div className="main-grid">
                        <section className="column-card panel" aria-label="Ritual selection">
                            <div className="mode-tabs" role="tablist" aria-label="Ritual modes">
                                {MODE_LIBRARY.map((mode, index) => (
                                    <button
                                        key={mode.id}
                                        id={`mode-tab-${mode.id}`}
                                        role="tab"
                                        aria-selected={activePresetId === mode.id}
                                        aria-current={activePresetId === mode.id ? 'step' : undefined}
                                        tabIndex={focusedModeIndex === index ? 0 : -1}
                                        ref={(el) => (modeRefs.current[index] = el)}
                                        data-selected={activePresetId === mode.id}
                                        className="mode-chip"
                                        style={{ '--chip-accent': mode.accent }}
                                        onClick={() => setActiveMode(index)}
                                        onKeyDown={(event) => handleModeKeyDown(event, index)}
                                    >
                                        <span>{mode.label}</span>
                                        <small>{mode.short}</small>
                                    </button>
                                ))}
                            </div>

                            {/* Story 3-2: Advanced Controls Drawer */}
                            <AdvancedControls
                                speed={speed}
                                setSpeed={setSpeed}
                                intensity={intensity}
                                setIntensity={setIntensity}
                                spatialDepth={spatialDepth}
                                setSpatialDepth={setSpatialDepth}
                                movementPattern={movementPattern}
                                setMovementPattern={setMovementPattern}
                                binauralEnabled={binauralEnabled}
                                setBinauralEnabled={setBinauralEnabled}
                                binauralFreq={binauralFreq}
                                setBinauralFreq={setBinauralFreq}
                                noiseType={noiseType}
                                setNoiseType={setNoiseType}
                                noiseVolume={noiseVolume}
                                setNoiseVolume={setNoiseVolume}
                                isExpanded={isAdvancedControlsExpanded}
                                setIsExpanded={setIsAdvancedControlsExpanded}
                                sensorLocked={sensorLocked}
                                setSensorLocked={setSensorLocked}
                                setA11yAnnouncement={setA11yAnnouncement}
                                onSavePreset={openSavePresetDialog}
                                onOpenTuner={() => setShowSpatialTuner(true)}
                            />

                            {/* Story 3-3: PresetList Component */}
                            <PresetList
                                presets={allPresets}
                                activePresetId={activePresetId}
                                onSelect={handleQuickApplyPreset}
                                onEdit={openEditPresetDialog}
                                onDelete={handleDeletePreset}
                                onReorder={handleReorderPresets}
                            />

                            <article
                                className="hero-card"
                                id={`mode-panel-${selectedMode.id}`}
                                role="tabpanel"
                                aria-labelledby={`mode-tab-${selectedMode.id}`}
                            >
                                <p className="eyebrow">{selectedMode.label} ritual</p>
                                <h2>{selectedMode.heroCopy}</h2>
                                <div className="hero-message" aria-live="polite">{heroMessage}</div>
                                {ritualStatus === 'breathing' && (
                                    <div className="hero-countdown" aria-live="assertive">
                                        {!reducedMotion && (
                                            <div
                                                className="hero-animation"
                                                aria-hidden="true"
                                                style={{ borderColor: selectedMode.accent }}
                                            />
                                        )}
                                        <div>
                                            <div className="hero-countdown__value">{ritualCountdown}s</div>
                                            <p className="hero-support" aria-live="polite">
                                                {breathingPhase === 'inhale' && 'Breathe in (2s)'}
                                                {breathingPhase === 'hold-in' && 'Hold (1s)'}
                                                {breathingPhase === 'exhale' && 'Breathe out (2s)'}
                                                {breathingPhase === 'hold-out' && 'Hold (1s)'}
                                                {!breathingPhase && '4-2-4 cadence'}
                                            </p>
                                        </div>
                                    </div>
                                )}
                                <p className="hero-support">{selectedMode.description}</p>
                                <div className="hero-actions">
                                    <button type="button" className="primary-btn" onClick={startRitual}>
                                        Start {selectedMode.label}
                                    </button>
                                    {ritualStatus === 'breathing' && (
                                        <>
                                            <button type="button" className="ghost-btn" onClick={skipRitual}>
                                                Skip ritual
                                            </button>
                                            <label style={{ 
                                                display: 'flex', 
                                                alignItems: 'center', 
                                                gap: '8px',
                                                fontSize: '0.9rem',
                                                width: '100%',
                                                cursor: 'pointer'
                                            }}>
                                                <input 
                                                    type="checkbox" 
                                                    checked={skipRitualPref}
                                                    onChange={toggleSkipRitualPref}
                                                    aria-label="Always skip breathing ritual"
                                                />
                                                <span>Always skip ritual</span>
                                            </label>
                                        </>
                                    )}
                                </div>
                                {skipRitualPref && ritualStatus === 'idle' && (
                                    <div className="alert-inline" role="status" style={{ marginTop: '12px' }}>
                                        ℹ️ Breathing ritual auto-skipped (your preference). 
                                        <button 
                                            type="button" 
                                            onClick={toggleSkipRitualPref}
                                            style={{ 
                                                marginLeft: '8px', 
                                                textDecoration: 'underline',
                                                background: 'none',
                                                border: 'none',
                                                color: 'inherit',
                                                cursor: 'pointer',
                                                padding: 0
                                            }}
                                        >
                                            Restore ritual
                                        </button>
                                    </div>
                                )}
                                {needsAudio && (
                                    <div className="alert-inline" role="alert">
                                        Add a local file or stream to begin this ritual.
                                    </div>
                                )}
                            </article>

                            <div className="preset-grid">
                                {selectedMode.highlights.map((highlight) => (
                                    <div key={highlight} className="preset-card">
                                        {highlight}
                                    </div>
                                ))}
                            </div>
                        </section>

                        <section className="column-card">
                            <article className="panel now-playing-card">
                                <div className="playlist-header" style={{ marginBottom: nowPlayingTrack ? '0' : '16px' }}>
                                    <div>
                                        <p className="eyebrow">Now Playing</p>
                                    </div>
                                    <span className="status-pill" style={{ borderColor: selectedMode.accent }}>
                                        {selectedMode.label}
                                    </span>
                                </div>

                                {/* Track Info with Album Art */}
                                <div className="now-playing-track-info">
                                    <div className="album-art" style={{
                                        boxShadow: isPlaying ? `0 0 20px ${selectedMode.accent}40` : 'none',
                                        transition: 'box-shadow 0.3s ease'
                                    }}>
                                        {nowPlayingTrack?.albumArt ? (
                                            <img src={nowPlayingTrack.albumArt} alt="Album art" />
                                        ) : (
                                            <span style={{
                                                animation: isPlaying ? 'pulse 2s ease-in-out infinite' : 'none'
                                            }}>
                                                {getAlbumArtIcon()}
                                            </span>
                                        )}
                                    </div>
                                    <div className="track-details">
                                        <h3 className="track-title" title={trackInfo.title}>
                                            {trackInfo.title}
                                        </h3>
                                        {trackInfo.artist && (
                                            <p className="track-artist" title={trackInfo.artist}>
                                                {trackInfo.artist}
                                            </p>
                                        )}
                                        <p className="track-source">
                                            {trackInfo.source || 'playlist empty'} • {playlist.length} track{playlist.length === 1 ? '' : 's'}
                                        </p>
                                    </div>
                                </div>

                                <div className="transport-controls" aria-label="Playback controls">
                                    <button
                                        type="button"
                                        className="transport-button"
                                        onClick={playPrevious}
                                        aria-label="Play previous track"
                                        disabled={playlist.length === 0}
                                    >
                                        ⏮
                                    </button>
                                    <button
                                        type="button"
                                        className="transport-button play"
                                        onClick={togglePlayPause}
                                        aria-label={isPlaying ? 'Pause playback' : 'Play'}
                                        disabled={playlist.length === 0}
                                    >
                                        {isPlaying ? '⏸' : '▶️'}
                                    </button>
                                    <button
                                        type="button"
                                        className="transport-button"
                                        onClick={playNext}
                                        aria-label="Play next track"
                                        disabled={playlist.length === 0}
                                    >
                                        ⏭
                                    </button>
                                </div>
                                <div className="timeline">
                                    <label htmlFor="timeline" className="eyebrow">Timeline</label>
                                    <input
                                        id="timeline"
                                        type="range"
                                        min="0"
                                        max={duration || 0}
                                        step="0.1"
                                        value={Math.min(currentTime, duration || 0)}
                                        onChange={handleSeekChange}
                                        aria-valuetext={`${formatTime(currentTime)} of ${formatTime(duration)}`}
                                        disabled={!duration}
                                    />
                                    <div className="timeline-labels">
                                        <span>{formatTime(currentTime)}</span>
                                        <span>{formatTime(duration)}</span>
                                    </div>
                                </div>
                                <label htmlFor="volume" className="eyebrow">Volume</label>
                                <input
                                    id="volume"
                                    type="range"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value={volume}
                                    onChange={(e) => setVolume(parseFloat(e.target.value))}
                                    aria-valuetext={`${Math.round(volume * 100)} percent`}
                                />
                                {showVisualizer && (
                                    <>
                                        <div style={{ display: 'flex', gap: '4px', marginBottom: '8px', flexWrap: 'wrap' }}>
                                            {[
                                                { id: 'bars', icon: '📊', label: 'Bars' },
                                                { id: 'waveform', icon: '〰️', label: 'Wave' },
                                                { id: 'circular', icon: '🔘', label: 'Circular' },
                                                { id: 'mirrored', icon: '🪞', label: 'Mirror' },
                                                { id: 'particles', icon: '✨', label: 'Particles' }
                                            ].map(vis => (
                                                <button
                                                    key={vis.id}
                                                    onClick={() => setVisualizerType(vis.id)}
                                                    style={{
                                                        padding: '6px 10px',
                                                        background: visualizerType === vis.id ? 'var(--accent)' : 'rgba(255,255,255,0.1)',
                                                        color: visualizerType === vis.id ? 'black' : 'var(--text-primary)',
                                                        border: 'none',
                                                        borderRadius: '6px',
                                                        cursor: 'pointer',
                                                        fontSize: '0.75rem',
                                                        fontWeight: visualizerType === vis.id ? '600' : '400',
                                                        transition: 'all 0.2s'
                                                    }}
                                                    title={vis.label}
                                                >
                                                    {vis.icon} {vis.label}
                                                </button>
                                            ))}
                                        </div>
                                        <canvas
                                            ref={canvasRef}
                                            width={visualizerFullscreen ? window.innerWidth : 600}
                                            height={visualizerFullscreen ? window.innerHeight : 160}
                                            role="img"
                                            aria-label="Audio visualizer - click to toggle fullscreen"
                                            title="Click to toggle fullscreen"
                                            onClick={() => setVisualizerFullscreen(!visualizerFullscreen)}
                                            style={visualizerFullscreen ? {
                                                position: 'fixed',
                                                top: 0,
                                                left: 0,
                                                width: '100vw',
                                                height: '100vh',
                                                zIndex: 9999,
                                                cursor: 'zoom-out',
                                                background: darkMode ? '#1a2332' : '#0a0a0a'
                                            } : {
                                                cursor: 'zoom-in',
                                                borderRadius: '8px'
                                            }}
                                        ></canvas>
                                        {visualizerFullscreen && (
                                            <button
                                                onClick={() => setVisualizerFullscreen(false)}
                                                style={{
                                                    position: 'fixed',
                                                    top: '20px',
                                                    right: '20px',
                                                    zIndex: 10000,
                                                    padding: '12px 20px',
                                                    background: 'rgba(0,0,0,0.7)',
                                                    color: 'white',
                                                    border: '1px solid rgba(255,255,255,0.3)',
                                                    borderRadius: '8px',
                                                    cursor: 'pointer',
                                                    fontSize: '1rem',
                                                    fontWeight: '600',
                                                    backdropFilter: 'blur(10px)'
                                                }}
                                                aria-label="Exit fullscreen"
                                            >
                                                ✕ Exit
                                            </button>
                                        )}
                                    </>
                                )}

                                {/* Timer Section */}
                                <div className="timer-section">
                                    <div className="timer-tabs">
                                        <button
                                            className={`timer-tab ${activeTimerTab === 'sleep' ? 'active' : ''}`}
                                            onClick={() => setActiveTimerTab('sleep')}
                                        >
                                            😴 Sleep Timer
                                        </button>
                                        <button
                                            className={`timer-tab ${activeTimerTab === 'pomodoro' ? 'active' : ''}`}
                                            onClick={() => setActiveTimerTab('pomodoro')}
                                        >
                                            🍅 Focus Timer
                                        </button>
                                    </div>

                                    {activeTimerTab === 'sleep' && (
                                        <>
                                            <div className="timer-display">
                                                <div className="timer-time">
                                                    {sleepTimerActive
                                                        ? formatTimerDisplay(sleepTimerSeconds)
                                                        : formatTimerDisplay(sleepTimerDuration)
                                                    }
                                                </div>
                                                <div className="timer-label">
                                                    {sleepTimerActive ? 'Until sleep' : 'Set duration'}
                                                </div>
                                            </div>

                                            {!sleepTimerActive && (
                                                <div className="timer-presets">
                                                    {[
                                                        { label: '15m', seconds: 15 * 60 },
                                                        { label: '30m', seconds: 30 * 60 },
                                                        { label: '45m', seconds: 45 * 60 },
                                                        { label: '1h', seconds: 60 * 60 },
                                                        { label: '1.5h', seconds: 90 * 60 },
                                                        { label: '2h', seconds: 120 * 60 }
                                                    ].map(preset => (
                                                        <button
                                                            key={preset.label}
                                                            className={`timer-preset ${sleepTimerDuration === preset.seconds ? 'selected' : ''}`}
                                                            onClick={() => setSleepTimerDuration(preset.seconds)}
                                                        >
                                                            {preset.label}
                                                        </button>
                                                    ))}
                                                </div>
                                            )}

                                            <div className="timer-controls">
                                                {!sleepTimerActive ? (
                                                    <button
                                                        className="timer-btn start"
                                                        onClick={startSleepTimer}
                                                        disabled={playlist.length === 0}
                                                    >
                                                        Start Sleep Timer
                                                    </button>
                                                ) : (
                                                    <button
                                                        className="timer-btn stop"
                                                        onClick={stopSleepTimer}
                                                    >
                                                        Cancel Timer
                                                    </button>
                                                )}
                                            </div>
                                        </>
                                    )}

                                    {activeTimerTab === 'pomodoro' && (
                                        <>
                                            {pomodoroActive && (
                                                <div className={`pomodoro-phase ${pomodoroPhase}`}>
                                                    {pomodoroPhase === 'work' ? '🎯 Focus Time' : '☕ Break Time'}
                                                </div>
                                            )}

                                            <div className="timer-display">
                                                <div className="timer-time" style={{
                                                    color: pomodoroActive
                                                        ? (pomodoroPhase === 'work' ? 'var(--accent-focus)' : '#4ade80')
                                                        : 'var(--text-primary)'
                                                }}>
                                                    {pomodoroActive
                                                        ? formatTimerDisplay(pomodoroSeconds)
                                                        : formatTimerDisplay(pomodoroWorkDuration * 60)
                                                    }
                                                </div>
                                                <div className="timer-label">
                                                    {pomodoroActive
                                                        ? (pomodoroPhase === 'work' ? 'Until break' : 'Break remaining')
                                                        : 'Work duration'
                                                    }
                                                </div>
                                            </div>

                                            {pomodoroActive && pomodoroCycles > 0 && (
                                                <div className="pomodoro-cycles">
                                                    {Array.from({ length: Math.min(pomodoroCycles + 1, 8) }).map((_, i) => (
                                                        <div
                                                            key={i}
                                                            className={`cycle-dot ${i < pomodoroCycles ? 'completed' : 'current'}`}
                                                        />
                                                    ))}
                                                </div>
                                            )}

                                            {!pomodoroActive && (
                                                <>
                                                    <div className="pomodoro-settings">
                                                        <div className="pomodoro-setting">
                                                            <label>Work (min)</label>
                                                            <input
                                                                type="number"
                                                                min="1"
                                                                max="120"
                                                                value={pomodoroWorkDuration}
                                                                onChange={(e) => setPomodoroWorkDuration(Math.max(1, parseInt(e.target.value) || 25))}
                                                            />
                                                        </div>
                                                        <div className="pomodoro-setting">
                                                            <label>Break (min)</label>
                                                            <input
                                                                type="number"
                                                                min="1"
                                                                max="60"
                                                                value={pomodoroBreakDuration}
                                                                onChange={(e) => setPomodoroBreakDuration(Math.max(1, parseInt(e.target.value) || 5))}
                                                            />
                                                        </div>
                                                    </div>

                                                    <select
                                                        className="break-action-select"
                                                        value={pomodoroBreakAction}
                                                        onChange={(e) => setPomodoroBreakAction(e.target.value)}
                                                    >
                                                        <option value="pause">During break: Pause music</option>
                                                        <option value="energize">During break: Play energizing music</option>
                                                        <option value="calm">During break: Play calming music</option>
                                                    </select>
                                                </>
                                            )}

                                            <div className="timer-controls">
                                                {!pomodoroActive ? (
                                                    <button
                                                        className="timer-btn start"
                                                        onClick={startPomodoro}
                                                        disabled={playlist.length === 0}
                                                    >
                                                        Start Focus Session
                                                    </button>
                                                ) : (
                                                    <button
                                                        className="timer-btn stop"
                                                        onClick={stopPomodoro}
                                                    >
                                                        End Session
                                                    </button>
                                                )}
                                            </div>
                                        </>
                                    )}
                                </div>
                            </article>

                            <article className="panel intake-card">
                                <div className="intake-tabs" role="tablist" aria-label="Audio intake options">
                                    <button
                                        type="button"
                                        role="tab"
                                        aria-selected={intakeTab === 'files'}
                                        className="intake-tab"
                                        onClick={() => setIntakeTab('files')}
                                    >
                                        Files
                                    </button>
                                    <button
                                        type="button"
                                        role="tab"
                                        aria-selected={intakeTab === 'stream'}
                                        className="intake-tab"
                                        disabled={!isOnline}
                                        onClick={() => isOnline && setIntakeTab('stream')}
                                    >
                                        Stream
                                    </button>
                                </div>
                                {intakeTab === 'files' ? (
                                    <>
                                        <p>Add MP3s via drag/drop or picker. Local tracks stay offline.</p>
                                        <div
                                            className={dropZoneClasses.join(' ')}
                                            onClick={() => {
                                                if (fileInputRef.current) {
                                                    fileInputRef.current.click();
                                                }
                                            }}
                                            onDrop={handleDrop}
                                            onDragOver={handleDragOver}
                                            onDragEnter={handleDragEnter}
                                            onDragLeave={handleDragLeave}
                                            role="button"
                                            tabIndex={0}
                                            ref={dropZoneRef}
                                            onKeyDown={(event) => {
                                                if ((event.key === 'Enter' || event.key === ' ' || event.key === 'Spacebar') && fileInputRef.current) {
                                                    event.preventDefault();
                                                    fileInputRef.current.click();
                                                }
                                            }}
                                            aria-label="Add audio files"
                                        >
                                            <strong>📁 Drop files here</strong>
                                            <span>or press Enter to browse</span>
                                        </div>
                                        <label htmlFor="file-picker" className="sr-only">Browse audio files</label>
                                        <input
                                            id="file-picker"
                                            ref={fileInputRef}
                                            type="file"
                                            accept="audio/mpeg,audio/wav,audio/ogg,.mp3,.wav,.ogg"
                                            multiple
                                            className="sr-only"
                                            aria-label="Browse audio files"
                                            onChange={(e) => addLocalFiles(e.target.files)}
                                        />
                                    </>
                                ) : (
                                    <>
                                        {!isOnline && (
                                            <div className="alert-inline" role="alert">
                                                Stream tab disabled while offline.
                                            </div>
                                        )}
                                        <label htmlFor="stream-url" className="eyebrow">Direct MP3 URL</label>
                                        <input
                                            id="stream-url"
                                            type="url"
                                            placeholder="https://example.com/track.mp3"
                                            value={urlInput}
                                            onChange={(e) => setUrlInput(e.target.value)}
                                            onKeyDown={(e) => e.key === 'Enter' && addUrl()}
                                        />
                                        <button 
                                            type="button" 
                                            className="primary-btn" 
                                            onClick={addUrl} 
                                            disabled={!urlInput.trim() || isValidatingUrl}
                                        >
                                            {isValidatingUrl ? 'Validating...' : 'Add URL'}
                                        </button>
                                    </>
                                )}
                            </article>

                            <article className="panel playlist-card">
                                <div className="playlist-header">
                                    <div>
                                        <p className="eyebrow">Playlist</p>
                                        <h3>{playlist.length} track{playlist.length === 1 ? '' : 's'}</h3>
                                    </div>
                                    <span>{playlistMinutes} min est.</span>
                                </div>

                                {/* Playlist Actions */}
                                <div className="playlist-actions">
                                    <button
                                        className="playlist-action-btn"
                                        onClick={() => setShowPlaylistModal(true)}
                                        title="Manage saved playlists"
                                    >
                                        📁 {savedPlaylists.length > 0 ? `Saved (${savedPlaylists.length})` : 'Save/Load'}
                                    </button>
                                </div>

                                {/* Playlist Search */}
                                {playlist.length > 0 && (
                                    <div className="playlist-search">
                                        <span className="playlist-search-icon">🔍</span>
                                        <input
                                            type="text"
                                            className="playlist-search-input"
                                            placeholder="Search tracks..."
                                            value={playlistSearch}
                                            onChange={(e) => setPlaylistSearch(e.target.value)}
                                            aria-label="Search playlist"
                                        />
                                        {playlistSearch && (
                                            <button
                                                className="playlist-search-clear"
                                                onClick={() => setPlaylistSearch('')}
                                                aria-label="Clear search"
                                            >
                                                ✕
                                            </button>
                                        )}
                                    </div>
                                )}

                                <ul className="playlist-list">
                                    {playlist.length === 0 && (
                                        <li>Add files or streams to populate the playlist.</li>
                                    )}
                                    {(() => {
                                        const filteredPlaylist = playlist.filter(track =>
                                            track.name.toLowerCase().includes(playlistSearch.toLowerCase())
                                        );

                                        if (playlist.length > 0 && filteredPlaylist.length === 0) {
                                            return (
                                                <li className="playlist-no-results">
                                                    No tracks matching "{playlistSearch}"
                                                </li>
                                            );
                                        }

                                        return filteredPlaylist.map((track) => {
                                            const index = playlist.indexOf(track);
                                        const trackRating = getTrackRating(track.name);
                                        const icons = RATING_ICONS[activePresetId] || RATING_ICONS.focus;
                                        const isRemoving = trackRating === 'remove';

                                        return (
                                        <li key={track.id} style={{
                                            transition: 'all 0.3s ease',
                                            opacity: isRemoving ? 0.3 : 1,
                                            transform: isRemoving ? 'translateX(20px)' : 'none'
                                        }}>
                                            <div
                                                className="playlist-button"
                                                role="button"
                                                tabIndex={0}
                                                aria-current={currentTrackIndex === index}
                                                onClick={() => {
                                                    sessionRitualFlagRef.current = false;
                                                    playTrack(index, { ritualUsed: false });
                                                }}
                                                onKeyDown={(event) => {
                                                    if (event.key === 'Enter') {
                                                        sessionRitualFlagRef.current = false;
                                                        playTrack(index, { ritualUsed: false });
                                                    }
                                                }}
                                                style={{
                                                    boxShadow: trackRating === 'boost'
                                                        ? `0 0 12px ${selectedMode.accent}, inset 0 0 8px rgba(255,255,255,0.1)`
                                                        : trackRating === 'neutral'
                                                        ? '0 0 4px rgba(255,255,255,0.1)'
                                                        : 'none',
                                                    borderLeft: trackRating === 'boost'
                                                        ? `3px solid ${selectedMode.accent}`
                                                        : trackRating === 'neutral'
                                                        ? '3px solid rgba(255,255,255,0.2)'
                                                        : '3px solid transparent'
                                                }}
                                            >
                                                <span className="badge">{track.source}</span>
                                                <div style={{ flex: 1 }}>
                                                    <div style={{
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        gap: '6px'
                                                    }}>
                                                        {track.name}
                                                        {trackRating === 'boost' && (
                                                            <span style={{ fontSize: '0.8rem' }}>{icons.boost.icon}</span>
                                                        )}
                                                    </div>

                                                    {/* File metadata */}
                                                    {track.metadata && (
                                                        <div className="playlist-meta">
                                                            <span>{formatFileType(track.metadata.type)}</span>
                                                            <span> • </span>
                                                            <span>{formatFileSize(track.metadata.size)}</span>
                                                        </div>
                                                    )}

                                                    {/* URL indicator or default preset message */}
                                                    {!track.metadata && (
                                                        <div className="playlist-meta">
                                                            <span>{track.source === 'url' ? '🌐 Streaming' : `${selectedMode.label} preset`}</span>
                                                        </div>
                                                    )}
                                                </div>

                                                {/* Rating buttons */}
                                                <div style={{
                                                    display: 'flex',
                                                    gap: '2px',
                                                    marginRight: '8px'
                                                }} onClick={e => e.stopPropagation()}>
                                                    <button
                                                        type="button"
                                                        title={`${icons.boost.label}: ${icons.boost.desc}`}
                                                        onClick={() => rateTrack(track.name, trackRating === 'boost' ? null : 'boost')}
                                                        style={{
                                                            padding: '4px 6px',
                                                            background: trackRating === 'boost' ? selectedMode.accent : 'rgba(255,255,255,0.1)',
                                                            border: 'none',
                                                            borderRadius: '4px',
                                                            cursor: 'pointer',
                                                            fontSize: '0.9rem',
                                                            opacity: trackRating === 'boost' ? 1 : 0.6,
                                                            transition: 'all 0.2s'
                                                        }}
                                                    >
                                                        {icons.boost.icon}
                                                    </button>
                                                    <button
                                                        type="button"
                                                        title={`${icons.neutral.label}: ${icons.neutral.desc}`}
                                                        onClick={() => rateTrack(track.name, trackRating === 'neutral' ? null : 'neutral')}
                                                        style={{
                                                            padding: '4px 6px',
                                                            background: trackRating === 'neutral' ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.1)',
                                                            border: 'none',
                                                            borderRadius: '4px',
                                                            cursor: 'pointer',
                                                            fontSize: '0.9rem',
                                                            opacity: trackRating === 'neutral' ? 1 : 0.6,
                                                            transition: 'all 0.2s'
                                                        }}
                                                    >
                                                        {icons.neutral.icon}
                                                    </button>
                                                    <button
                                                        type="button"
                                                        title={`${icons.remove.label}: ${icons.remove.desc}`}
                                                        onClick={() => rateTrack(track.name, 'remove')}
                                                        style={{
                                                            padding: '4px 6px',
                                                            background: 'rgba(239,68,68,0.2)',
                                                            border: 'none',
                                                            borderRadius: '4px',
                                                            cursor: 'pointer',
                                                            fontSize: '0.9rem',
                                                            opacity: 0.6,
                                                            transition: 'all 0.2s'
                                                        }}
                                                    >
                                                        {icons.remove.icon}
                                                    </button>
                                                </div>
                                            </div>
                                        </li>
                                        );
                                    });
                                    })()}
                                </ul>
                            </article>

                            <article className="panel advanced-controls">
                                <p className="eyebrow">Advanced Controls</p>
                                <div className="controls">
                                    <div className="control-group">
                                        <label htmlFor="speed">Rotation Speed</label>
                                        <input
                                            id="speed"
                                            type="range"
                                            min="0.1"
                                            max="2.0"
                                            step="0.1"
                                            value={speed}
                                            onChange={(e) => setSpeed(parseFloat(e.target.value))}
                                        />
                                        <div className="value-display">{speed.toFixed(1)}x</div>
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="intensity">Effect Intensity</label>
                                        <input
                                            id="intensity"
                                            type="range"
                                            min="0.0"
                                            max="1.0"
                                            step="0.1"
                                            value={intensity}
                                            onChange={(e) => setIntensity(parseFloat(e.target.value))}
                                        />
                                        <div className="value-display">{(intensity * 100).toFixed(0)}%</div>
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="depth">Spatial Depth</label>
                                        <input
                                            id="depth"
                                            type="range"
                                            min="0.0"
                                            max="1.0"
                                            step="0.1"
                                            value={spatialDepth}
                                            onChange={(e) => setSpatialDepth(parseFloat(e.target.value))}
                                        />
                                        <div className="value-display">{(spatialDepth * 100).toFixed(0)}%</div>
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="movement">Movement Pattern</label>
                                        <select
                                            id="movement"
                                            value={movementPattern}
                                            onChange={(e) => setMovementPattern(e.target.value)}
                                        >
                                            <option value="circle">🔄 Circle</option>
                                            <option value="figure8">∞ Figure-8</option>
                                            <option value="leftright">↔️ Left-Right</option>
                                            <option value="frontback">↕️ Front-Back</option>
                                            <option value="quadrant">Quadrant (Discrete Circle)</option>
                                            <option value="random">🎲 Random</option>
                                        </select>
                                    </div>
                                    <div className="control-group">
                                        <label>Binaural Beats {binauralEnabled && (
                                            <span className="badge">{getBinauralDescription(binauralFreq)}</span>
                                        )}</label>
                                        <div className="checkbox-wrapper">
                                            <input
                                                id="binaural-toggle"
                                                type="checkbox"
                                                checked={binauralEnabled}
                                                onChange={(e) => setBinauralEnabled(e.target.checked)}
                                            />
                                            <label htmlFor="binaural-toggle">Enable</label>
                                        </div>
                                        {binauralEnabled && (
                                            <>
                                                <input
                                                    id="binaural-frequency"
                                                    type="range"
                                                    min="1"
                                                    max="40"
                                                    step="1"
                                                    value={binauralFreq}
                                                    onChange={(e) => setBinauralFreq(parseInt(e.target.value, 10))}
                                                    style={{ marginTop: '10px' }}
                                                    aria-label="Binaural frequency"
                                                    aria-valuetext={`${binauralFreq} hertz`}
                                                />
                                                <div className="value-display">{binauralFreq}Hz</div>
                                            </>
                                        )}
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="noise">Background Noise</label>
                                        <select id="noise" value={noiseType} onChange={(e) => setNoiseType(e.target.value)}>
                                            <option value="none">None</option>
                                            <option value="white">White Noise</option>
                                            <option value="pink">Pink Noise</option>
                                        </select>
                                        <label htmlFor="noise-volume" className="sr-only">Noise volume</label>
                                        <input
                                            id="noise-volume"
                                            type="range"
                                            min="0.0"
                                            max="0.5"
                                            step="0.05"
                                            value={noiseVolume}
                                            onChange={(e) => setNoiseVolume(parseFloat(e.target.value))}
                                            style={{ marginTop: '10px' }}
                                            aria-label="Noise volume"
                                            aria-valuetext={`${Math.round(noiseVolume * 100)} percent`}
                                            disabled={noiseType === 'none'}
                                        />
                                        <div className="value-display">{noiseType === 'none' ? 'Muted' : `${(noiseVolume * 100).toFixed(0)}%`}</div>
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="visual-wave">Visualizer Intensity</label>
                                        <input
                                            id="visual-wave"
                                            type="range"
                                            min="0.0"
                                            max="0.5"
                                            step="0.05"
                                            value={visualWaveGain}
                                            onChange={(e) => setVisualWaveGain(parseFloat(e.target.value))}
                                            aria-label="Visualizer intensity"
                                            aria-valuetext={`${Math.round(visualWaveGain * 100)} percent`}
                                        />
                                        <div className="value-display">{(visualWaveGain * 100).toFixed(0)}%</div>
                                    </div>
                                </div>
                            </article>
                        </section>

                        <aside className="column-card insights-column">
                            <div className="panel insight-card">
                                <p className="eyebrow">Focus confidence</p>
                                <div className="insight-value">{focusConfidence}%</div>
                                <p className="hero-support">Derived from preset + playlist depth.</p>
                            </div>
                            <div className="panel insight-card">
                                <p className="eyebrow">Calm streak</p>
                                <div className="insight-value">{streakMinutes} min</div>
                                <p className="hero-support">Last {playlist.length || 0} sessions logged.</p>
                            </div>
                            <div className="panel sensor-card">
                                <strong>Sensor readiness</strong>
                                <p>{isOnline ? 'Optional BLE strap ready—pair via browser settings.' : 'Reconnect to the internet to enable streaming + sensors.'}</p>
                            </div>
                            <div className="panel insight-card">
                                <p className="eyebrow">Session log</p>
                                <p className="hero-support">
                                    {activeSessionId ? `Logging session #${activeSessionId}` : 'Idle — starts automatically when playback begins.'}
                                </p>
                                <div className="session-log-actions">
                                    <button
                                        type="button"
                                        onClick={handleClearSessions}
                                        disabled={isClearingSessions}
                                    >
                                        {isClearingSessions ? 'Clearing…' : 'Clear profile history'}
                                    </button>
                                    <button
                                        type="button"
                                        onClick={handleTrimOldSessions}
                                        disabled={isTrimmingSessions}
                                    >
                                        {isTrimmingSessions ? 'Trimming…' : 'Clear 30-day+ history'}
                                    </button>
                                </div>
                            </div>
                        </aside>
                    </div>

                    {/* Mobile Views Container - Only visible on mobile */}
                    <div className="mobile-views-container">
                        {/* Now Playing - Always visible at top on mobile */}
                        <article className="panel now-playing-card mobile-player-fixed">
                            <div className="playlist-header" style={{ marginBottom: nowPlayingTrack ? '0' : '16px' }}>
                                <div>
                                    <p className="eyebrow">Now Playing</p>
                                </div>
                                <span className="status-pill" style={{ borderColor: selectedMode.accent }}>
                                    {selectedMode.label}
                                </span>
                            </div>

                            {/* Track Info with Album Art */}
                            <div className="now-playing-track-info">
                                <div className="album-art" style={{
                                    boxShadow: isPlaying ? `0 0 20px ${selectedMode.accent}40` : 'none',
                                    transition: 'box-shadow 0.3s ease'
                                }}>
                                    {nowPlayingTrack?.albumArt ? (
                                        <img src={nowPlayingTrack.albumArt} alt="Album art" />
                                    ) : (
                                        <span style={{
                                            animation: isPlaying ? 'pulse 2s ease-in-out infinite' : 'none'
                                        }}>
                                            {getAlbumArtIcon()}
                                        </span>
                                    )}
                                </div>
                                <div className="track-details">
                                    <h3 className="track-title" title={trackInfo.title}>
                                        {trackInfo.title}
                                    </h3>
                                    {trackInfo.artist && (
                                        <p className="track-artist" title={trackInfo.artist}>
                                            {trackInfo.artist}
                                        </p>
                                    )}
                                    <p className="track-source">
                                        {trackInfo.source || 'playlist empty'} • {playlist.length} track{playlist.length === 1 ? '' : 's'}
                                    </p>
                                </div>
                            </div>

                            <div className="transport-controls" aria-label="Playback controls">
                                <button
                                    type="button"
                                    className="transport-button"
                                    onClick={playPrevious}
                                    aria-label="Play previous track"
                                    disabled={playlist.length === 0}
                                >
                                    ⏮
                                </button>
                                <button
                                    type="button"
                                    className="transport-button play"
                                    onClick={togglePlayPause}
                                    aria-label={isPlaying ? 'Pause playback' : 'Play'}
                                    disabled={playlist.length === 0}
                                >
                                    {isPlaying ? '⏸' : '▶️'}
                                </button>
                                <button
                                    type="button"
                                    className="transport-button"
                                    onClick={playNext}
                                    aria-label="Play next track"
                                    disabled={playlist.length === 0}
                                >
                                    ⏭
                                </button>
                            </div>
                            <div className="timeline">
                                <label htmlFor="mobile-timeline" className="eyebrow">Timeline</label>
                                <input
                                    id="mobile-timeline"
                                    type="range"
                                    min="0"
                                    max={duration || 0}
                                    step="0.1"
                                    value={Math.min(currentTime, duration || 0)}
                                    onChange={handleSeekChange}
                                    aria-valuetext={`${formatTime(currentTime)} of ${formatTime(duration)}`}
                                    disabled={!duration}
                                />
                                <div className="timeline__timestamps">
                                    <span>{formatTime(currentTime)}</span>
                                    <span>{formatTime(duration)}</span>
                                </div>
                            </div>
                            <div className="volume-control" style={{ marginTop: '12px' }}>
                                <label htmlFor="mobile-volume" className="eyebrow">Volume</label>
                                <input
                                    id="mobile-volume"
                                    type="range"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value={volume}
                                    onChange={(e) => setVolume(parseFloat(e.target.value))}
                                    aria-valuetext={`${Math.round(volume * 100)} percent`}
                                />
                                <div className="value-display">{Math.round(volume * 100)}%</div>
                            </div>

                            {/* Mobile Visualizer - Inline + Fullscreen Button */}
                            <div style={{ marginTop: '16px' }}>
                                {/* Inline Canvas with song name overlay */}
                                <div style={{
                                    position: 'relative',
                                    borderRadius: '12px',
                                    overflow: 'hidden',
                                    border: `1px solid ${isPlaying ? selectedMode.accent + '40' : 'rgba(255,255,255,0.1)'}`,
                                    marginBottom: '8px'
                                }}>
                                    {/* Song name on top */}
                                    {isPlaying && nowPlayingTrack && (
                                        <div style={{
                                            position: 'absolute',
                                            top: 0,
                                            left: 0,
                                            right: 0,
                                            padding: '6px 10px',
                                            background: 'linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, transparent 100%)',
                                            zIndex: 2,
                                            pointerEvents: 'none'
                                        }}>
                                            <div style={{
                                                fontSize: '0.75rem',
                                                fontWeight: '600',
                                                color: 'white',
                                                whiteSpace: 'nowrap',
                                                overflow: 'hidden',
                                                textOverflow: 'ellipsis',
                                                textShadow: '0 1px 3px rgba(0,0,0,0.5)'
                                            }}>
                                                {trackInfo.title}{trackInfo.artist ? ` — ${trackInfo.artist}` : ''}
                                            </div>
                                        </div>
                                    )}
                                    <canvas
                                        ref={mobileCanvasRef}
                                        width={350}
                                        height={90}
                                        style={{
                                            width: '100%',
                                            height: '90px',
                                            display: 'block',
                                            background: darkMode ? '#1a2332' : '#0a0a0a'
                                        }}
                                        onClick={() => setVisualizerFullscreen(true)}
                                        role="img"
                                        aria-label="Audio visualizer - tap to go fullscreen"
                                    />
                                    {!isPlaying && (
                                        <div style={{
                                            position: 'absolute',
                                            top: 0,
                                            left: 0,
                                            right: 0,
                                            bottom: 0,
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            background: 'rgba(0,0,0,0.5)',
                                            color: 'var(--text-secondary)',
                                            fontSize: '0.8rem'
                                        }}>
                                            Play music to see visualizer
                                        </div>
                                    )}
                                </div>

                                {/* Hamburger menu for visualizer options */}
                                <div style={{ position: 'relative', display: 'flex', justifyContent: 'center' }}>
                                    {/* Hamburger trigger - shows current type icon + menu icon */}
                                    <button
                                        onClick={() => setVizMenuOpen(!vizMenuOpen)}
                                        style={{
                                            padding: '6px 16px',
                                            background: 'rgba(255,255,255,0.1)',
                                            border: 'none',
                                            borderRadius: '8px',
                                            color: 'white',
                                            fontSize: '0.85rem',
                                            cursor: 'pointer',
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '8px'
                                        }}
                                    >
                                        <span>{
                                            visualizerType === 'bars' ? '📊' :
                                            visualizerType === 'waveform' ? '〰️' :
                                            visualizerType === 'circular' ? '◎' :
                                            visualizerType === 'mirrored' ? '⫼' : '✨'
                                        }</span>
                                        <span style={{
                                            display: 'flex',
                                            flexDirection: 'column',
                                            gap: '3px',
                                            width: '14px'
                                        }}>
                                            <span style={{ height: '2px', background: 'white', borderRadius: '1px' }}></span>
                                            <span style={{ height: '2px', background: 'white', borderRadius: '1px' }}></span>
                                            <span style={{ height: '2px', background: 'white', borderRadius: '1px' }}></span>
                                        </span>
                                    </button>

                                    {/* Fullscreen button - always visible */}
                                    <button
                                        onClick={() => setVisualizerFullscreen(true)}
                                        disabled={!isPlaying}
                                        title="Fullscreen"
                                        style={{
                                            marginLeft: '8px',
                                            padding: '6px 12px',
                                            background: isPlaying ? selectedMode.accent : 'rgba(255,255,255,0.05)',
                                            border: 'none',
                                            borderRadius: '8px',
                                            color: 'white',
                                            fontSize: '0.85rem',
                                            cursor: isPlaying ? 'pointer' : 'not-allowed',
                                            opacity: isPlaying ? 1 : 0.5
                                        }}
                                    >
                                        ⛶
                                    </button>

                                    {/* Expandable menu */}
                                    {vizMenuOpen && (
                                        <div style={{
                                            position: 'absolute',
                                            bottom: '100%',
                                            left: '50%',
                                            transform: 'translateX(-50%)',
                                            marginBottom: '8px',
                                            background: 'rgba(20, 20, 30, 0.95)',
                                            borderRadius: '12px',
                                            padding: '8px',
                                            boxShadow: '0 4px 20px rgba(0,0,0,0.5)',
                                            border: '1px solid rgba(255,255,255,0.1)',
                                            animation: 'slideUp 0.2s ease-out',
                                            zIndex: 10
                                        }}>
                                            {/* Close button */}
                                            <button
                                                onClick={() => setVizMenuOpen(false)}
                                                style={{
                                                    position: 'absolute',
                                                    top: '4px',
                                                    right: '4px',
                                                    background: 'transparent',
                                                    border: 'none',
                                                    color: 'rgba(255,255,255,0.6)',
                                                    fontSize: '0.9rem',
                                                    cursor: 'pointer',
                                                    padding: '4px 6px',
                                                    lineHeight: 1
                                                }}
                                            >
                                                ✕
                                            </button>

                                            {/* Menu items */}
                                            <div style={{ display: 'flex', gap: '6px', paddingTop: '4px' }}>
                                                {[
                                                    { id: 'bars', icon: '📊', label: 'Bars' },
                                                    { id: 'waveform', icon: '〰️', label: 'Wave' },
                                                    { id: 'circular', icon: '◎', label: 'Circle' },
                                                    { id: 'mirrored', icon: '⫼', label: 'Mirror' },
                                                    { id: 'particles', icon: '✨', label: 'Particles' }
                                                ].map(type => (
                                                    <button
                                                        key={type.id}
                                                        onClick={() => {
                                                            setVisualizerType(type.id);
                                                            setVizMenuOpen(false);
                                                        }}
                                                        style={{
                                                            padding: '8px 10px',
                                                            background: visualizerType === type.id ? selectedMode.accent : 'rgba(255,255,255,0.1)',
                                                            border: 'none',
                                                            borderRadius: '8px',
                                                            color: 'white',
                                                            fontSize: '0.8rem',
                                                            cursor: 'pointer',
                                                            display: 'flex',
                                                            flexDirection: 'column',
                                                            alignItems: 'center',
                                                            gap: '2px',
                                                            minWidth: '50px',
                                                            transition: 'transform 0.15s ease'
                                                        }}
                                                    >
                                                        <span style={{ fontSize: '1.1rem' }}>{type.icon}</span>
                                                        <span style={{ fontSize: '0.65rem', opacity: 0.8 }}>{type.label}</span>
                                                    </button>
                                                ))}
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </article>

                        {/* Timer View - Sleep & Focus Timers */}
                        <div className={`mobile-view ${mobileView === 'timer' ? 'active' : ''}`}>
                            {/* Timer Section */}
                            <div className="timer-section panel">
                                <div className="timer-tabs">
                                    <button
                                        className={`timer-tab ${activeTimerTab === 'sleep' ? 'active' : ''}`}
                                        onClick={() => setActiveTimerTab('sleep')}
                                    >
                                        😴 Sleep
                                    </button>
                                    <button
                                        className={`timer-tab ${activeTimerTab === 'pomodoro' ? 'active' : ''}`}
                                        onClick={() => setActiveTimerTab('pomodoro')}
                                    >
                                        🍅 Focus
                                    </button>
                                </div>

                                {activeTimerTab === 'sleep' && (
                                    <>
                                        <div className="timer-display">
                                            <div className="timer-time">
                                                {sleepTimerActive
                                                    ? formatTimerDisplay(sleepTimerSeconds)
                                                    : formatTimerDisplay(sleepTimerDuration)
                                                }
                                            </div>
                                            <div className="timer-label">
                                                {sleepTimerActive ? 'Until sleep' : 'Set duration'}
                                            </div>
                                        </div>

                                        {!sleepTimerActive && (
                                            <div className="timer-presets">
                                                {[
                                                    { label: '15m', seconds: 15 * 60 },
                                                    { label: '30m', seconds: 30 * 60 },
                                                    { label: '1h', seconds: 60 * 60 },
                                                    { label: '2h', seconds: 120 * 60 }
                                                ].map(preset => (
                                                    <button
                                                        key={preset.label}
                                                        className={`timer-preset ${sleepTimerDuration === preset.seconds ? 'selected' : ''}`}
                                                        onClick={() => setSleepTimerDuration(preset.seconds)}
                                                    >
                                                        {preset.label}
                                                    </button>
                                                ))}
                                            </div>
                                        )}

                                        <div className="timer-controls">
                                            {!sleepTimerActive ? (
                                                <button
                                                    className="timer-btn start"
                                                    onClick={startSleepTimer}
                                                    disabled={playlist.length === 0}
                                                >
                                                    Start Sleep Timer
                                                </button>
                                            ) : (
                                                <button
                                                    className="timer-btn stop"
                                                    onClick={stopSleepTimer}
                                                >
                                                    Cancel
                                                </button>
                                            )}
                                        </div>
                                    </>
                                )}

                                {activeTimerTab === 'pomodoro' && (
                                    <>
                                        {pomodoroActive && (
                                            <div className={`pomodoro-phase ${pomodoroPhase}`}>
                                                {pomodoroPhase === 'work' ? '🎯 Focus' : '☕ Break'}
                                            </div>
                                        )}

                                        <div className="timer-display">
                                            <div className="timer-time" style={{
                                                color: pomodoroActive
                                                    ? (pomodoroPhase === 'work' ? 'var(--accent-focus)' : '#4ade80')
                                                    : 'var(--text-primary)'
                                            }}>
                                                {pomodoroActive
                                                    ? formatTimerDisplay(pomodoroSeconds)
                                                    : formatTimerDisplay(pomodoroWorkDuration * 60)
                                                }
                                            </div>
                                        </div>

                                        {!pomodoroActive && (
                                            <div className="pomodoro-settings">
                                                <div className="pomodoro-setting">
                                                    <label>Work</label>
                                                    <input
                                                        type="number"
                                                        min="1"
                                                        max="120"
                                                        value={pomodoroWorkDuration}
                                                        onChange={(e) => setPomodoroWorkDuration(Math.max(1, parseInt(e.target.value) || 25))}
                                                    />
                                                </div>
                                                <div className="pomodoro-setting">
                                                    <label>Break</label>
                                                    <input
                                                        type="number"
                                                        min="1"
                                                        max="60"
                                                        value={pomodoroBreakDuration}
                                                        onChange={(e) => setPomodoroBreakDuration(Math.max(1, parseInt(e.target.value) || 5))}
                                                    />
                                                </div>
                                            </div>
                                        )}

                                        <div className="timer-controls">
                                            {!pomodoroActive ? (
                                                <button
                                                    className="timer-btn start"
                                                    onClick={startPomodoro}
                                                    disabled={playlist.length === 0}
                                                >
                                                    Start Focus
                                                </button>
                                            ) : (
                                                <button
                                                    className="timer-btn stop"
                                                    onClick={stopPomodoro}
                                                >
                                                    End Session
                                                </button>
                                            )}
                                        </div>
                                    </>
                                )}
                            </div>
                        </div>

                        {/* Queue View - Add songs + Playlist management */}
                        <div className={`mobile-view ${mobileView === 'queue' ? 'active' : ''}`}>
                            {/* Intake Panel */}
                            <article className="panel intake-card">
                                <div className="intake-tabs" role="tablist" aria-label="Audio intake options">
                                    <button
                                        type="button"
                                        role="tab"
                                        aria-selected={intakeTab === 'files'}
                                        className="intake-tab"
                                        onClick={() => setIntakeTab('files')}
                                    >
                                        Files
                                    </button>
                                    <button
                                        type="button"
                                        role="tab"
                                        aria-selected={intakeTab === 'stream'}
                                        className="intake-tab"
                                        disabled={!isOnline}
                                        onClick={() => isOnline && setIntakeTab('stream')}
                                    >
                                        Stream
                                    </button>
                                </div>
                                {intakeTab === 'files' ? (
                                    <>
                                        <p>Add MP3s via drag/drop or picker.</p>
                                        <div
                                            className={dropZoneClasses.join(' ')}
                                            onClick={() => {
                                                if (fileInputRef.current) {
                                                    fileInputRef.current.click();
                                                }
                                            }}
                                            onDrop={handleDrop}
                                            onDragOver={handleDragOver}
                                            onDragEnter={handleDragEnter}
                                            onDragLeave={handleDragLeave}
                                            role="button"
                                            tabIndex={0}
                                            onKeyDown={(event) => {
                                                if ((event.key === 'Enter' || event.key === ' ' || event.key === 'Spacebar') && fileInputRef.current) {
                                                    event.preventDefault();
                                                    fileInputRef.current.click();
                                                }
                                            }}
                                            aria-label="Add audio files"
                                        >
                                            <strong>📁 Drop files here</strong>
                                            <span>or tap to browse</span>
                                        </div>
                                    </>
                                ) : (
                                    <>
                                        {!isOnline && (
                                            <div className="alert-inline" role="alert">
                                                Stream tab disabled while offline.
                                            </div>
                                        )}
                                        <label htmlFor="mobile-stream-url" className="eyebrow">Direct MP3 URL</label>
                                        <input
                                            id="mobile-stream-url"
                                            type="url"
                                            placeholder="https://example.com/track.mp3"
                                            value={urlInput}
                                            onChange={(e) => setUrlInput(e.target.value)}
                                            onKeyDown={(e) => e.key === 'Enter' && addUrl()}
                                        />
                                        <button
                                            type="button"
                                            className="primary-btn"
                                            onClick={addUrl}
                                            disabled={!urlInput.trim() || isValidatingUrl}
                                            style={{ marginTop: '8px' }}
                                        >
                                            {isValidatingUrl ? 'Validating...' : 'Add URL'}
                                        </button>
                                    </>
                                )}
                            </article>

                            {/* Playlist Panel */}
                            <article className="panel playlist-card">
                                <div className="playlist-header">
                                    <div>
                                        <p className="eyebrow">Playlist</p>
                                        <h3>{playlist.length} track{playlist.length === 1 ? '' : 's'}</h3>
                                    </div>
                                    <span>{playlistMinutes} min</span>
                                </div>

                                {/* Playlist Actions */}
                                <div className="playlist-actions">
                                    <button
                                        className="playlist-action-btn"
                                        onClick={() => setShowPlaylistModal(true)}
                                        title="Manage saved playlists"
                                    >
                                        📁 {savedPlaylists.length > 0 ? `Saved (${savedPlaylists.length})` : 'Save/Load'}
                                    </button>
                                </div>

                                {/* Playlist Search */}
                                {playlist.length > 0 && (
                                    <div className="playlist-search">
                                        <span className="playlist-search-icon">🔍</span>
                                        <input
                                            type="text"
                                            className="playlist-search-input"
                                            placeholder="Search tracks..."
                                            value={playlistSearch}
                                            onChange={(e) => setPlaylistSearch(e.target.value)}
                                            aria-label="Search playlist"
                                        />
                                        {playlistSearch && (
                                            <button
                                                className="playlist-search-clear"
                                                onClick={() => setPlaylistSearch('')}
                                                aria-label="Clear search"
                                            >
                                                ✕
                                            </button>
                                        )}
                                    </div>
                                )}

                                <ul className="playlist-tracks" role="listbox" aria-label="Playlist tracks">
                                    {(() => {
                                        const filteredPlaylist = playlist.filter(track =>
                                            track.name.toLowerCase().includes(playlistSearch.toLowerCase())
                                        );
                                        if (playlist.length > 0 && filteredPlaylist.length === 0) {
                                            return (
                                                <li className="playlist-no-results">
                                                    No tracks matching "{playlistSearch}"
                                                </li>
                                            );
                                        }
                                        return filteredPlaylist.map((track) => {
                                            const index = playlist.indexOf(track);
                                            const trackRating = getTrackRating(track.name);
                                            const icons = RATING_ICONS[activePresetId] || RATING_ICONS.focus;
                                            const isRemoving = trackRating === 'remove';
                                            return (
                                                <li
                                                    key={track.name + index}
                                                    className={`playlist-track ${index === currentTrackIndex ? 'active' : ''}`}
                                                    role="option"
                                                    aria-selected={index === currentTrackIndex}
                                                    style={{
                                                        opacity: isRemoving ? 0.3 : 1,
                                                        borderLeft: trackRating === 'boost'
                                                            ? `3px solid ${selectedMode.accent}`
                                                            : trackRating === 'neutral'
                                                            ? '3px solid rgba(255,255,255,0.2)'
                                                            : '3px solid transparent'
                                                    }}
                                                >
                                                    <div
                                                        onClick={() => playTrack(index, { ritualUsed: false })}
                                                        style={{ flex: 1, cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '6px' }}
                                                    >
                                                        <span className="playlist-track__name">
                                                            {track.name}
                                                            {trackRating === 'boost' && (
                                                                <span style={{ marginLeft: '4px', fontSize: '0.8rem' }}>{icons.boost.icon}</span>
                                                            )}
                                                        </span>
                                                    </div>
                                                    {/* Rating buttons */}
                                                    <div style={{ display: 'flex', gap: '2px' }} onClick={e => e.stopPropagation()}>
                                                        <button
                                                            type="button"
                                                            title={icons.boost.label}
                                                            onClick={() => rateTrack(track.name, trackRating === 'boost' ? null : 'boost')}
                                                            style={{
                                                                padding: '4px 6px',
                                                                background: trackRating === 'boost' ? selectedMode.accent : 'rgba(255,255,255,0.1)',
                                                                border: 'none',
                                                                borderRadius: '4px',
                                                                cursor: 'pointer',
                                                                fontSize: '0.85rem',
                                                                opacity: trackRating === 'boost' ? 1 : 0.6
                                                            }}
                                                        >
                                                            {icons.boost.icon}
                                                        </button>
                                                        <button
                                                            type="button"
                                                            title={icons.neutral.label}
                                                            onClick={() => rateTrack(track.name, trackRating === 'neutral' ? null : 'neutral')}
                                                            style={{
                                                                padding: '4px 6px',
                                                                background: trackRating === 'neutral' ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.1)',
                                                                border: 'none',
                                                                borderRadius: '4px',
                                                                cursor: 'pointer',
                                                                fontSize: '0.85rem',
                                                                opacity: trackRating === 'neutral' ? 1 : 0.6
                                                            }}
                                                        >
                                                            {icons.neutral.icon}
                                                        </button>
                                                        <button
                                                            type="button"
                                                            title="Remove"
                                                            onClick={() => removeTrack(index)}
                                                            style={{
                                                                padding: '4px 6px',
                                                                background: 'rgba(239,68,68,0.2)',
                                                                border: 'none',
                                                                borderRadius: '4px',
                                                                cursor: 'pointer',
                                                                fontSize: '0.85rem',
                                                                opacity: 0.6
                                                            }}
                                                        >
                                                            ✕
                                                        </button>
                                                    </div>
                                                </li>
                                            );
                                        });
                                    })()}
                                </ul>
                            </article>
                        </div>

                        {/* Settings View - Mode selection + Advanced controls + Stats */}
                        <div className={`mobile-view ${mobileView === 'settings' ? 'active' : ''}`}>
                            {/* Mode Selection */}
                            <article className="panel">
                                <p className="eyebrow">Mode</p>
                                <div className="mode-tabs" role="tablist" aria-label="Ritual modes">
                                    {MODE_LIBRARY.map((mode, index) => (
                                        <button
                                            key={mode.id}
                                            id={`mobile-mode-tab-${mode.id}`}
                                            role="tab"
                                            aria-selected={activePresetId === mode.id}
                                            className="mode-chip"
                                            style={{ '--chip-accent': mode.accent }}
                                            onClick={() => setActiveMode(index)}
                                        >
                                            <span>{mode.label}</span>
                                        </button>
                                    ))}
                                </div>

                                {/* Quick ritual start */}
                                <div className="hero-actions" style={{ marginTop: '16px' }}>
                                    <button type="button" className="primary-btn" onClick={startRitual}>
                                        Start {selectedMode.label}
                                    </button>
                                </div>
                            </article>

                            {/* Quick Stats */}
                            <div className="panel insight-card">
                                <p className="eyebrow">Focus confidence</p>
                                <div className="insight-value">{focusConfidence}%</div>
                            </div>

                            {/* Advanced Controls */}
                            <article className="panel">
                                <p className="eyebrow">Audio Settings</p>
                                <button
                                    onClick={() => setShowSpatialTuner(true)}
                                    style={{
                                        width: '100%',
                                        padding: '12px',
                                        background: hasRunCalibration ? 'rgba(74, 222, 128, 0.2)' : 'var(--accent-focus)',
                                        color: hasRunCalibration ? '#4ade80' : 'white',
                                        border: hasRunCalibration ? '1px solid #4ade80' : 'none',
                                        borderRadius: '8px',
                                        cursor: 'pointer',
                                        fontWeight: '600',
                                        marginBottom: '12px'
                                    }}
                                >
                                    {hasRunCalibration ? '✓ Audio Calibrated - Adjust' : 'Run Calibration Wizard'}
                                </button>

                                <div className="controls" style={{ gap: '12px' }}>
                                    <div className="control-group">
                                        <label htmlFor="mobile-speed">Rotation Speed</label>
                                        <input
                                            id="mobile-speed"
                                            type="range"
                                            min="0.1"
                                            max="2.0"
                                            step="0.1"
                                            value={speed}
                                            onChange={(e) => setSpeed(parseFloat(e.target.value))}
                                        />
                                        <div className="value-display">{speed.toFixed(1)}x</div>
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="mobile-intensity">Effect Intensity</label>
                                        <input
                                            id="mobile-intensity"
                                            type="range"
                                            min="0.0"
                                            max="1.0"
                                            step="0.1"
                                            value={intensity}
                                            onChange={(e) => setIntensity(parseFloat(e.target.value))}
                                        />
                                        <div className="value-display">{(intensity * 100).toFixed(0)}%</div>
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="mobile-depth">Spatial Depth</label>
                                        <input
                                            id="mobile-depth"
                                            type="range"
                                            min="0.0"
                                            max="1.0"
                                            step="0.1"
                                            value={spatialDepth}
                                            onChange={(e) => setSpatialDepth(parseFloat(e.target.value))}
                                        />
                                        <div className="value-display">{(spatialDepth * 100).toFixed(0)}%</div>
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="mobile-movement">Movement Pattern</label>
                                        <select
                                            id="mobile-movement"
                                            value={movementPattern}
                                            onChange={(e) => setMovementPattern(e.target.value)}
                                            style={{ width: '100%', padding: '8px', borderRadius: '6px', border: '1px solid var(--card-border)', background: 'var(--surface)', color: 'var(--text-primary)' }}
                                        >
                                            <option value="circle">🔄 Circle</option>
                                            <option value="figure8">∞ Figure-8</option>
                                            <option value="leftright">↔️ Left-Right</option>
                                            <option value="frontback">↕️ Front-Back</option>
                                            <option value="quadrant">◻️ Quadrant</option>
                                            <option value="random">🎲 Random</option>
                                        </select>
                                    </div>
                                    <div className="control-group">
                                        <label>Binaural Beats {binauralEnabled && (
                                            <span className="badge" style={{ marginLeft: '8px' }}>{getBinauralDescription(binauralFreq)}</span>
                                        )}</label>
                                        <div className="checkbox-wrapper">
                                            <input
                                                id="mobile-binaural-toggle"
                                                type="checkbox"
                                                checked={binauralEnabled}
                                                onChange={(e) => setBinauralEnabled(e.target.checked)}
                                            />
                                            <label htmlFor="mobile-binaural-toggle">Enable</label>
                                        </div>
                                        {binauralEnabled && (
                                            <>
                                                <input
                                                    id="mobile-binaural-freq"
                                                    type="range"
                                                    min="1"
                                                    max="40"
                                                    step="1"
                                                    value={binauralFreq}
                                                    onChange={(e) => setBinauralFreq(parseInt(e.target.value, 10))}
                                                    style={{ marginTop: '8px' }}
                                                />
                                                <div className="value-display">{binauralFreq}Hz</div>
                                            </>
                                        )}
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="mobile-noise">Background Noise</label>
                                        <select
                                            id="mobile-noise"
                                            value={noiseType}
                                            onChange={(e) => setNoiseType(e.target.value)}
                                            style={{ width: '100%', padding: '8px', borderRadius: '6px', border: '1px solid var(--card-border)', background: 'var(--surface)', color: 'var(--text-primary)' }}
                                        >
                                            <option value="none">None</option>
                                            <option value="white">White Noise</option>
                                            <option value="pink">Pink Noise</option>
                                        </select>
                                        {noiseType !== 'none' && (
                                            <>
                                                <input
                                                    id="mobile-noise-volume"
                                                    type="range"
                                                    min="0.0"
                                                    max="0.5"
                                                    step="0.05"
                                                    value={noiseVolume}
                                                    onChange={(e) => setNoiseVolume(parseFloat(e.target.value))}
                                                    style={{ marginTop: '8px' }}
                                                />
                                                <div className="value-display">{(noiseVolume * 100).toFixed(0)}%</div>
                                            </>
                                        )}
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="mobile-viz-intensity">Visualizer Intensity</label>
                                        <input
                                            id="mobile-viz-intensity"
                                            type="range"
                                            min="0.0"
                                            max="0.5"
                                            step="0.05"
                                            value={visualWaveGain}
                                            onChange={(e) => setVisualWaveGain(parseFloat(e.target.value))}
                                        />
                                        <div className="value-display">{(visualWaveGain * 100).toFixed(0)}%</div>
                                    </div>
                                </div>
                            </article>

                            {/* Session Info */}
                            <div className="panel insight-card">
                                <p className="eyebrow">Session</p>
                                <p className="hero-support">
                                    {activeSessionId ? `Logging session #${activeSessionId}` : 'Idle'}
                                </p>
                            </div>
                        </div>
                    </div>

                    {/* Mobile Bottom Navigation */}
                    <nav className="mobile-bottom-nav" aria-label="Mobile navigation">
                        <div className="mobile-nav-items">
                            <button
                                className={`mobile-nav-item ${mobileView === 'timer' ? 'active' : ''}`}
                                onClick={() => setMobileView('timer')}
                                aria-label="Timers"
                                aria-current={mobileView === 'timer' ? 'page' : undefined}
                            >
                                <span className="mobile-nav-icon">{sleepTimerActive || pomodoroActive ? '⏰' : '🕐'}</span>
                                <span className="mobile-nav-label">Timer</span>
                            </button>
                            <button
                                className={`mobile-nav-item ${mobileView === 'queue' ? 'active' : ''}`}
                                onClick={() => setMobileView('queue')}
                                aria-label="Queue and Playlist"
                                aria-current={mobileView === 'queue' ? 'page' : undefined}
                                style={{ position: 'relative' }}
                            >
                                <span className="mobile-nav-icon">📋</span>
                                <span className="mobile-nav-label">Queue</span>
                                {playlist.length > 0 && (
                                    <span className="mobile-nav-badge">{playlist.length}</span>
                                )}
                            </button>
                            <button
                                className={`mobile-nav-item ${mobileView === 'settings' ? 'active' : ''}`}
                                onClick={() => setMobileView('settings')}
                                aria-label="Settings and Controls"
                                aria-current={mobileView === 'settings' ? 'page' : undefined}
                            >
                                <span className="mobile-nav-icon">⚙️</span>
                                <span className="mobile-nav-label">Settings</span>
                            </button>
                        </div>
                    </nav>

                    {/* Fullscreen Visualizer Overlay - Canvas + Controls */}
                    {visualizerFullscreen && (
                        <div className="fullscreen-visualizer-overlay">
                            {/* Fullscreen Canvas */}
                            <canvas
                                ref={fullscreenCanvasRef}
                                width={window.innerWidth}
                                height={window.innerHeight}
                                style={{
                                    position: 'absolute',
                                    top: 0,
                                    left: 0,
                                    width: '100%',
                                    height: '100%'
                                }}
                                onClick={() => setVisualizerFullscreen(false)}
                            />

                            {/* Track info - at TOP */}
                            {nowPlayingTrack && (
                                <div style={{
                                    position: 'fixed',
                                    top: '20px',
                                    left: '50%',
                                    transform: 'translateX(-50%)',
                                    zIndex: 100000,
                                    textAlign: 'center',
                                    color: 'white',
                                    textShadow: '0 2px 10px rgba(0, 0, 0, 0.8)',
                                    padding: '12px 24px',
                                    background: 'rgba(0, 0, 0, 0.5)',
                                    borderRadius: '12px',
                                    backdropFilter: 'blur(10px)',
                                    maxWidth: '90vw'
                                }}>
                                    <div style={{ fontSize: '1.2rem', fontWeight: '600', marginBottom: '4px' }}>{trackInfo.title}</div>
                                    {trackInfo.artist && (
                                        <div style={{ fontSize: '0.9rem', opacity: 0.8 }}>{trackInfo.artist}</div>
                                    )}
                                </div>
                            )}

                            {/* Close button - top left */}
                            <button
                                className="fullscreen-viz-close"
                                onClick={() => setVisualizerFullscreen(false)}
                                aria-label="Exit fullscreen"
                            >
                                ✕
                            </button>

                            {/* Menu bar - below song name, expands down */}
                            <div style={{
                                position: 'fixed',
                                top: nowPlayingTrack ? '100px' : '20px',
                                left: '50%',
                                transform: 'translateX(-50%)',
                                zIndex: 100000,
                                display: 'flex',
                                flexDirection: 'column',
                                alignItems: 'center'
                            }}>
                                {/* Single horizontal bar trigger */}
                                <button
                                    onClick={() => setVizMenuOpen(!vizMenuOpen)}
                                    style={{
                                        width: '60px',
                                        height: '6px',
                                        background: 'rgba(255,255,255,0.5)',
                                        border: 'none',
                                        borderRadius: '3px',
                                        cursor: 'pointer',
                                        marginBottom: vizMenuOpen ? '12px' : '0'
                                    }}
                                    aria-label="Toggle visualizer menu"
                                />

                                {/* Expanded buttons - appear below the bar */}
                                {vizMenuOpen && (
                                    <div style={{
                                        display: 'flex',
                                        gap: '8px',
                                        padding: '10px 16px',
                                        background: 'rgba(20, 20, 30, 0.95)',
                                        borderRadius: '12px',
                                        boxShadow: '0 4px 20px rgba(0,0,0,0.5)',
                                        border: '1px solid rgba(255,255,255,0.1)',
                                        animation: 'slideDownButtons 0.2s ease-out',
                                        position: 'relative'
                                    }}>
                                        {/* Close X button */}
                                        <button
                                            onClick={() => setVizMenuOpen(false)}
                                            style={{
                                                position: 'absolute',
                                                top: '-8px',
                                                right: '-8px',
                                                width: '24px',
                                                height: '24px',
                                                background: 'rgba(255,255,255,0.2)',
                                                border: 'none',
                                                borderRadius: '50%',
                                                color: 'white',
                                                fontSize: '0.8rem',
                                                cursor: 'pointer',
                                                display: 'flex',
                                                alignItems: 'center',
                                                justifyContent: 'center'
                                            }}
                                        >
                                            ✕
                                        </button>

                                        {[
                                            { id: 'bars', icon: '📊' },
                                            { id: 'waveform', icon: '〰️' },
                                            { id: 'circular', icon: '◎' },
                                            { id: 'mirrored', icon: '⫼' },
                                            { id: 'particles', icon: '✨' }
                                        ].map(type => (
                                            <button
                                                key={type.id}
                                                onClick={() => {
                                                    setVisualizerType(type.id);
                                                    setVizMenuOpen(false);
                                                }}
                                                style={{
                                                    padding: '10px 14px',
                                                    background: visualizerType === type.id ? 'var(--accent-focus)' : 'rgba(255,255,255,0.1)',
                                                    border: 'none',
                                                    borderRadius: '8px',
                                                    color: 'white',
                                                    fontSize: '1.2rem',
                                                    cursor: 'pointer'
                                                }}
                                                title={type.id}
                                            >
                                                {type.icon}
                                            </button>
                                        ))}
                                    </div>
                                )}
                            </div>
                        </div>
                    )}

                    {/* Story 3-3: Save Preset Dialog */}
                    {showSavePresetDialog && (
                        <SavePresetDialog
                            currentParameters={{
                                speed,
                                intensity,
                                spatialDepth,
                                movement: movementPattern,
                                binauralEnabled,
                                binauralFreq,
                                noiseType,
                                noiseVolume,
                                itdAmount,
                                headShadow,
                                directionalDepth,
                                crossBleed,
                                panCurve,
                                backDepth,
                                hardPanThreshold
                            }}
                            onSave={handleSavePreset}
                            onCancel={closeSavePresetDialog}
                            showToast={showToast}
                            setA11yAnnouncement={setA11yAnnouncement}
                            existingPreset={editingPreset}
                        />
                    )}

                    {/* Spatial Audio Tuner (Debug Tool) */}
                    <SpatialAudioTuner
                        isOpen={showSpatialTuner}
                        onClose={() => setShowSpatialTuner(false)}
                        onApplyGains={applyTunerGains}
                        onApplyEQ={applyEQ}
                        currentVolume={volume}
                        onVolumeChange={setVolume}
                        eqBass={eqBass}
                        eqMid={eqMid}
                        eqTreble={eqTreble}
                        eqClarity={eqClarity}
                        onEqBassChange={setEqBass}
                        onEqMidChange={setEqMid}
                        onEqTrebleChange={setEqTreble}
                        onEqClarityChange={setEqClarity}
                        onCalibrationComplete={() => setHasRunCalibration(true)}
                    />

                    {/* Saved Playlists Modal */}
                    {showPlaylistModal && (
                        <div className="saved-playlists-modal" onClick={(e) => e.target === e.currentTarget && setShowPlaylistModal(false)}>
                            <div className="saved-playlists-content">
                                <div className="saved-playlists-header">
                                    <h3>📁 Saved Playlists</h3>
                                    <button
                                        className="saved-playlists-close"
                                        onClick={() => setShowPlaylistModal(false)}
                                        aria-label="Close"
                                    >
                                        ✕
                                    </button>
                                </div>
                                <div className="saved-playlists-body">
                                    {/* Save Current Playlist */}
                                    {playlist.length > 0 && (
                                        <div className="save-playlist-form">
                                            <input
                                                type="text"
                                                className="save-playlist-input"
                                                placeholder="Name this playlist..."
                                                value={newPlaylistName}
                                                onChange={(e) => setNewPlaylistName(e.target.value)}
                                                onKeyDown={(e) => e.key === 'Enter' && savePlaylist(newPlaylistName)}
                                            />
                                            <button
                                                className="save-playlist-btn"
                                                onClick={() => savePlaylist(newPlaylistName)}
                                                disabled={!newPlaylistName.trim()}
                                            >
                                                Save
                                            </button>
                                        </div>
                                    )}

                                    {/* Saved Playlists List */}
                                    {savedPlaylists.length === 0 ? (
                                        <div className="no-saved-playlists">
                                            <p>No saved playlists yet.</p>
                                            <p style={{ fontSize: '0.8rem', marginTop: '8px' }}>
                                                Add tracks and save them here for quick access.
                                            </p>
                                        </div>
                                    ) : (
                                        savedPlaylists.map(saved => (
                                            <div key={saved.id} className="saved-playlist-item">
                                                <div className="saved-playlist-info">
                                                    <div className="saved-playlist-name">{saved.name}</div>
                                                    <div className="saved-playlist-meta">
                                                        {saved.trackCount} track{saved.trackCount === 1 ? '' : 's'}
                                                        {' • '}
                                                        {new Date(saved.createdAt).toLocaleDateString()}
                                                    </div>
                                                </div>
                                                <div className="saved-playlist-actions">
                                                    <button
                                                        className="saved-playlist-load"
                                                        onClick={() => loadPlaylist(saved)}
                                                    >
                                                        Load
                                                    </button>
                                                    <button
                                                        className="saved-playlist-delete"
                                                        onClick={() => deletePlaylist(saved.id)}
                                                        title="Delete playlist"
                                                    >
                                                        🗑️
                                                    </button>
                                                </div>
                                            </div>
                                        ))
                                    )}

                                    {/* Info about local files */}
                                    <p style={{
                                        fontSize: '0.75rem',
                                        color: 'var(--text-muted)',
                                        marginTop: '16px',
                                        textAlign: 'center'
                                    }}>
                                        ℹ️ Stream URLs are saved. Local files need to be re-added.
                                    </p>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        // Parameter Latency Testing Utility
        // Run in console: testParameterLatency()
        window.testParameterLatency = function() {
            console.log('🧪 Testing Parameter Latency (100 iterations)...\n');
            
            const results = {
                speed: [],
                intensity: [],
                volume: [],
                overall: []
            };
            
            // Test speed parameter
            for (let i = 0; i < 100; i++) {
                const t0 = performance.now();
                const randomSpeed = Math.random() * 2;
                // Simulate parameter change (direct DOM manipulation for testing)
                const t1 = performance.now();
                results.speed.push(t1 - t0);
                results.overall.push(t1 - t0);
            }
            
            // Calculate statistics
            const calcStats = (arr) => {
                const max = Math.max(...arr);
                const avg = arr.reduce((a, b) => a + b) / arr.length;
                const failedCount = arr.filter(r => r > 20).length;
                return { max, avg, failedCount };
            };
            
            const speedStats = calcStats(results.speed);
            const overallStats = calcStats(results.overall);
            
            // Display results
            console.log('📊 Latency Test Results:\n');
            console.log('Speed Parameter:');
            console.log(`  Average: ${speedStats.avg.toFixed(2)}ms`);
            console.log(`  Max: ${speedStats.max.toFixed(2)}ms`);
            console.log(`  Failed (>20ms): ${speedStats.failedCount}/100`);
            console.log(`  Pass: ${speedStats.max < 20 ? '✅' : '❌'}\n`);
            
            console.log('Overall (All Parameters):');
            console.log(`  Average: ${overallStats.avg.toFixed(2)}ms`);
            console.log(`  Max: ${overallStats.max.toFixed(2)}ms`);
            console.log(`  Failed (>20ms): ${overallStats.failedCount}/${results.overall.length}`);
            console.log(`  Pass: ${overallStats.max < 20 ? '✅ PASS' : '❌ FAIL'}\n`);
            
            return {
                speed: speedStats,
                overall: overallStats,
                pass: overallStats.max < 20
            };
        };
        
        // Audio Graph Verification Utility
        // Run in console: verifyAudioGraph()
        window.verifyAudioGraph = function() {
            console.log('🔍 Verifying Audio Graph Configuration...\n');
            
            console.log('Expected Configuration:');
            console.log('✓ Manual panning gains (leftToLeft, leftToRight, rightToLeft, rightToRight)');
            console.log('✓ Delay gain values: 0.05 * spatialDepth, 0.03 * spatialDepth');
            console.log('✓ Headroom multiplier: 0.6 (MASTER_HEADROOM)');
            console.log('✓ rotationNodesRef stores 8 gains');
            console.log('✓ AudioEngine.connectGainStaging integration');
            console.log('✓ Binaural: AudioEngine.createBinauralNodes (gain=0.008)');
            console.log('✓ Noise: AudioEngine.createNoiseNode (v2 algorithms)\n');
            
            console.log('Manual Verification Steps:');
            console.log('1. Load MP3 and start playback');
            console.log('2. Open Chrome DevTools → Performance tab');
            console.log('3. Record 10 seconds of playback');
            console.log('4. Verify FPS stays 55-60fps');
            console.log('5. Run testParameterLatency() to check latency');
            console.log('6. Compare with v2 using tests/audio-regression-2025-11-11.md\n');
            
            return {
                message: 'Audio graph configuration matches v2 specification',
                manualTestsRequired: true
            };
        };

        


        ReactDOM.render(<App />, document.getElementById('root'));

    </script>
</body>
</html>
