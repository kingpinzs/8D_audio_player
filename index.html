<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8D Audio Player - Live Streaming Edition</title>
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#1a1a2e">
    <link rel="apple-touch-icon" href="./icons/icon-192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./icons/icon-192.png">
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="./audio-engine.js"></script>
    <script src="./session-logging.js"></script>
    <script src="./sensor-consent.js"></script>
    <style>
        :root {
            --bg-1: #f4f6ff;
            --bg-2: #dfe7ff;
            --card-bg: rgba(255, 255, 255, 0.95);
            --card-border: rgba(15, 27, 68, 0.08);
            --surface: rgba(255, 255, 255, 0.7);
            --text-primary: #0c1440;
            --text-secondary: rgba(12, 20, 64, 0.7);
            --shadow-soft: 0 30px 60px rgba(15, 21, 56, 0.2);
            --accent-focus: #6d8bff;
            --accent-calm: #4edbc6;
            --accent-energize: #ffb562;
            --accent-default: #6d8bff;
            --chip-accent: var(--accent-default);
            --danger: #f05d7b;
            --positive: #3ad8a7;
            --grid-gap: 24px;
        }

        body.dark-mode {
            --bg-1: #05071c;
            --bg-2: #0c122d;
            --card-bg: rgba(7, 10, 30, 0.95);
            --card-border: rgba(255, 255, 255, 0.08);
            --surface: rgba(255, 255, 255, 0.04);
            --text-primary: #f5f7ff;
            --text-secondary: rgba(245, 247, 255, 0.7);
            --shadow-soft: 0 40px 90px rgba(0, 0, 0, 0.65);
        }

        /* High-contrast mode: WCAG AA compliant (≥4.5:1 normal text, ≥3:1 large text) */
        body.high-contrast {
            --bg-1: #ffffff;
            --bg-2: #f0f0f0;
            --card-bg: #ffffff;
            --card-border: #000000;
            --surface: #ffffff;
            --text-primary: #000000;
            --text-secondary: #000000;
            --shadow-soft: 0 2px 8px rgba(0, 0, 0, 0.3);
            --accent-focus: #0000ee;
            --accent-calm: #006060;
            --accent-energize: #cc5500;
            --accent-default: #0000ee;
            --danger: #cc0000;
            --positive: #008800;
        }

        /* High-contrast dark mode combination */
        body.dark-mode.high-contrast {
            --bg-1: #000000;
            --bg-2: #1a1a1a;
            --card-bg: #000000;
            --card-border: #ffffff;
            --surface: #000000;
            --text-primary: #ffffff;
            --text-secondary: #ffffff;
            --shadow-soft: 0 2px 8px rgba(255, 255, 255, 0.3);
            --accent-focus: #6699ff;
            --accent-calm: #00ffff;
            --accent-energize: #ffaa00;
            --accent-default: #6699ff;
            --danger: #ff6666;
            --positive: #00ff00;
        }

        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
            min-height: 100vh;
            background-image:
                radial-gradient(circle at 20% 20%, rgba(109, 139, 255, 0.25), transparent 45%),
                radial-gradient(circle at 80% 0%, rgba(255, 175, 123, 0.22), transparent 40%),
                linear-gradient(135deg, var(--bg-1), var(--bg-2));
            color: var(--text-primary);
            transition: background 0.35s ease, color 0.35s ease;
        }

        button, input, select, textarea {
            font: inherit;
        }

        .screen {
            max-width: 1440px;
            margin: 0 auto;
            padding: 32px clamp(16px, 4vw, 64px) 64px;
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .app-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 16px;
        }

        .app-header h1 {
            font-size: clamp(1.85rem, 3vw, 2.8rem);
            margin: 6px 0 8px;
        }

        .eyebrow {
            text-transform: uppercase;
            letter-spacing: 0.2em;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .header-actions {
            display: flex;
            gap: 12px;
        }

        .header-actions button {
            min-height: 48px;
            border-radius: 999px;
            padding: 0 20px;
            border: 1px solid var(--card-border);
            background: var(--surface);
            color: var(--text-primary);
            cursor: pointer;
            transition: transform 0.2s ease, border 0.2s ease;
        }

        .header-actions button:focus-visible {
            outline: 3px solid rgba(109, 139, 255, 0.7);
            outline-offset: 2px;
        }

        .primary-btn {
            background: linear-gradient(120deg, var(--accent-focus), #9f9bff);
            color: #fff;
            border: none;
            box-shadow: 0 20px 40px rgba(109, 139, 255, 0.35);
        }

        .ghost-btn {
            background: transparent;
            border: 1px dashed var(--card-border);
            color: var(--text-primary);
        }

        /* Design spec §3: Three-column grid layout for desktop ≥1280px (Ritual/Preset | Playback | Insights) */
        .main-grid {
            display: grid;
            grid-template-columns: minmax(280px, 360px) minmax(420px, 1fr) minmax(260px, 320px);
            gap: var(--grid-gap);
        }

        .column-card {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .panel {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 24px;
            padding: 24px;
            box-shadow: var(--shadow-soft);
        }

        /* Design spec §3: Mode tabs (Focus/Calm/Energize) with roving tabindex */
        .mode-tabs {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .mode-chip {
            flex: 1 1 140px;
            min-height: 56px;
            border-radius: 18px;
            border: 1px solid var(--card-border);
            padding: 12px 16px;
            background: var(--surface);
            color: var(--text-primary);
            cursor: pointer;
            text-align: left;
            transition: transform 0.2s ease, border 0.2s ease, box-shadow 0.2s ease;
        }

        .mode-chip[data-selected="true"] {
            border-color: var(--chip-accent);
            box-shadow: 0 10px 30px rgba(109, 139, 255, 0.25);
            background: linear-gradient(135deg, var(--chip-accent), rgba(255,255,255,0.1));
            color: #fff;
        }

        .mode-chip span {
            display: block;
            font-size: 1rem;
            font-weight: 600;
        }

        .mode-chip small {
            font-size: 0.78rem;
            opacity: 0.85;
        }

        /* Story 3-2: Advanced Controls Drawer */
        .advanced-controls {
            background: var(--surface-1);
            border: 2px solid var(--border-subtle);
            border-radius: 12px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .advanced-controls summary {
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            list-style: none;
            user-select: none;
        }

        .advanced-controls summary::-webkit-details-marker {
            display: none;
        }

        .advanced-controls summary::after {
            content: '▼';
            transition: transform 0.2s ease;
            font-size: 0.85rem;
            opacity: 0.6;
        }

        .advanced-controls[open] summary::after {
            transform: rotate(180deg);
        }

        .advanced-controls summary:hover {
            background: var(--surface-2);
            border-radius: 8px;
        }

        .advanced-controls kbd {
            font-size: 0.75rem;
            background: var(--surface-2);
            padding: 0.125rem 0.375rem;
            border-radius: 4px;
            border: 1px solid var(--border-subtle);
            font-family: monospace;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
            margin-top: 1rem;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .checkbox-group {
            flex-direction: row;
            align-items: center;
            gap: 0.5rem;
        }

        .checkbox-group input[type="checkbox"] {
            width: 24px;
            height: 24px;
            cursor: pointer;
        }

        .control-label {
            font-weight: 500;
            color: var(--text-1);
            font-size: 0.95rem;
        }

        .control-input {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .control-input input[type="range"] {
            flex: 1;
            height: 8px;
            border-radius: 4px;
            appearance: none;
            background: var(--surface-3);
            outline: none;
        }

        .control-input input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-focus);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.1s ease;
        }

        .control-input input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .control-input input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-focus);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.1s ease;
        }

        .control-input input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.1);
        }

        .control-input input[type="range"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .control-input input[type="range"]:disabled::-webkit-slider-thumb {
            cursor: not-allowed;
        }

        .control-input input[type="range"]:disabled::-moz-range-thumb {
            cursor: not-allowed;
        }

        .control-input select {
            flex: 1;
            padding: 0.5rem;
            border-radius: 6px;
            background: var(--surface-2);
            border: 2px solid var(--border-subtle);
            color: var(--text-1);
            font-size: 0.9rem;
            cursor: pointer;
        }

        .control-input select:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .control-input output {
            font-variant-numeric: tabular-nums;
            min-width: 3.5rem;
            text-align: right;
            font-weight: 600;
            color: var(--text-2);
            font-size: 0.9rem;
        }

        .freq-band {
            font-size: 0.8rem;
            color: var(--text-3);
            font-weight: 400;
            margin-left: 0.25rem;
        }

        .control-hint {
            font-size: 0.85rem;
            color: var(--text-3);
            font-style: italic;
            line-height: 1.3;
        }

        .sensor-lock-notice {
            background: var(--warning-bg, #fff3cd);
            border: 2px solid var(--warning-border, #ffc107);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .lock-icon {
            font-size: 1.5rem;
        }

        .lock-message {
            flex: 1;
            font-weight: 500;
            color: var(--warning-text, #664d03);
        }

        .unlock-btn {
            padding: 0.5rem 1rem;
            border-radius: 6px;
            background: var(--surface-1);
            border: 2px solid var(--border);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-1);
        }

        .unlock-btn:hover {
            background: var(--accent-focus);
            color: white;
            border-color: var(--accent-focus);
            transform: translateY(-1px);
        }

        .unlock-btn:active {
            transform: translateY(0);
        }

        /* Story 5-3: Lock Icon Button Styles (AC2) */
        .lock-icon-btn {
            background: transparent;
            border: none;
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .lock-icon-btn:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        .lock-icon-btn:focus-visible {
            outline: 2px solid var(--accent-primary, #6366f1);
            outline-offset: 2px;
        }

        .lock-icon-btn.unlocked .lock-icon {
            opacity: 0.6;
        }

        .lock-icon-btn.unlocked:hover .lock-icon {
            opacity: 1;
        }

        /* Pulse animation for when automation applies changes */
        @keyframes lock-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .lock-icon-btn.pulse .lock-icon {
            animation: lock-pulse 0.3s ease-in-out 2;
        }

        .hero-card {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .hero-card h2 {
            margin: 0;
            font-size: 1.6rem;
        }

        .hero-message {
            min-height: 48px;
            border-radius: 16px;
            padding: 12px 16px;
            background: var(--surface);
            color: var(--text-primary);
            display: flex;
            align-items: center;
        }

        .hero-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        .hero-actions button {
            flex: 1;
            min-width: 140px;
            min-height: 54px;
        }

        .hero-countdown {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .hero-animation {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            border: 3px solid rgba(109, 139, 255, 0.3);
            position: relative;
        }

        .hero-animation::after {
            content: '';
            position: absolute;
            inset: 8px;
            border-radius: 50%;
            border: 3px solid rgba(109, 139, 255, 0.8);
            animation: breathe424 6s ease-in-out infinite;
        }

        /* 4-2-4 breathing animation: 2s inhale, 1s hold, 2s exhale, 1s hold = 6s cycle */
        @keyframes breathe424 {
            0% {
                transform: scale(0.85);
                opacity: 0.6;
            }
            /* Inhale: 0-33.33% (2s of 6s) */
            33.33% {
                transform: scale(1.15);
                opacity: 1;
            }
            /* Hold inhale: 33.33-50% (1s of 6s) */
            50% {
                transform: scale(1.15);
                opacity: 1;
            }
            /* Exhale: 50-83.33% (2s of 6s) */
            83.33% {
                transform: scale(0.85);
                opacity: 0.6;
            }
            /* Hold exhale: 83.33-100% (1s of 6s) */
            100% {
                transform: scale(0.85);
                opacity: 0.6;
            }
        }

        .hero-countdown__value {
            font-size: 2rem;
            font-weight: 600;
        }

        .preset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
        }

        .preset-card {
            border-radius: 16px;
            border: 1px solid var(--card-border);
            padding: 14px;
            background: var(--surface);
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .hero-support {
            color: var(--text-secondary);
            margin: 0;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 16px;
        }

        .value-display {
            text-align: right;
            font-weight: 600;
            color: var(--accent-focus);
            margin-top: 8px;
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .now-playing-card canvas {
            width: 100%;
            height: 120px;
            border-radius: 16px;
            border: 1px solid var(--card-border);
            background: #050915;
        }

        .now-playing-track-info {
            display: flex;
            gap: 16px;
            align-items: center;
            margin-bottom: 16px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            border: 1px solid var(--card-border);
        }

        .album-art {
            width: 80px;
            height: 80px;
            min-width: 80px;
            border-radius: 10px;
            background: linear-gradient(135deg, rgba(109, 139, 255, 0.15), rgba(159, 155, 255, 0.1));
            border: 1px solid var(--card-border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: var(--text-secondary);
            overflow: hidden;
        }

        .album-art img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .track-details {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .track-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin: 0;
        }

        .track-artist {
            font-size: 0.9rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin: 0;
        }

        .track-source {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 0;
        }

        @media (max-width: 480px) {
            .now-playing-track-info {
                gap: 12px;
                padding: 10px;
            }
            .album-art {
                width: 64px;
                height: 64px;
                min-width: 64px;
                font-size: 1.5rem;
            }
            .track-title {
                font-size: 1rem;
            }
            .track-artist {
                font-size: 0.85rem;
            }
        }

        /* Timer Styles */
        .timer-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--card-border);
        }

        .timer-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .timer-tab {
            flex: 1;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--card-border);
            border-radius: 8px;
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .timer-tab:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .timer-tab.active {
            background: var(--accent);
            color: black;
            border-color: var(--accent);
            font-weight: 600;
        }

        .timer-display {
            text-align: center;
            padding: 16px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            margin-bottom: 12px;
        }

        .timer-time {
            font-size: 2.5rem;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
            color: var(--text-primary);
            letter-spacing: 2px;
        }

        .timer-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 4px;
        }

        .timer-presets {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 12px;
        }

        .timer-preset {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid var(--card-border);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .timer-preset:hover {
            background: rgba(255, 255, 255, 0.15);
            color: var(--text-primary);
        }

        .timer-preset.selected {
            background: var(--accent);
            color: black;
            border-color: var(--accent);
            font-weight: 600;
        }

        .timer-controls {
            display: flex;
            gap: 8px;
        }

        .timer-btn {
            flex: 1;
            padding: 10px 16px;
            border-radius: 8px;
            border: none;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .timer-btn.start {
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: black;
        }

        .timer-btn.stop {
            background: linear-gradient(135deg, #f87171, #ef4444);
            color: white;
        }

        .timer-btn.pause {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            color: black;
        }

        .timer-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pomodoro-phase {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: 8px;
            margin-bottom: 12px;
            font-weight: 600;
        }

        .pomodoro-phase.work {
            background: rgba(109, 139, 255, 0.2);
            color: var(--accent-focus);
        }

        .pomodoro-phase.break {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }

        .pomodoro-settings {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }

        .pomodoro-setting {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .pomodoro-setting label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .pomodoro-setting input {
            padding: 8px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid var(--card-border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.9rem;
            text-align: center;
        }

        .pomodoro-cycles {
            display: flex;
            gap: 6px;
            justify-content: center;
            margin-bottom: 8px;
        }

        .cycle-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transition: all 0.3s;
        }

        .cycle-dot.completed {
            background: var(--accent);
            box-shadow: 0 0 8px var(--accent);
        }

        .cycle-dot.current {
            background: #4ade80;
            box-shadow: 0 0 8px #4ade80;
            animation: pulse 1s infinite;
        }

        .break-action-select {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid var(--card-border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.85rem;
            margin-bottom: 12px;
        }

        @media (max-width: 480px) {
            .timer-time {
                font-size: 2rem;
            }
            .pomodoro-settings {
                grid-template-columns: 1fr;
            }
        }

        /* Playlist Search */
        .playlist-search {
            position: relative;
            margin-bottom: 12px;
        }

        .playlist-search-input {
            width: 100%;
            padding: 10px 12px 10px 36px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid var(--card-border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .playlist-search-input::placeholder {
            color: var(--text-muted);
        }

        .playlist-search-input:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(255, 255, 255, 0.1);
        }

        .playlist-search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted);
            font-size: 0.9rem;
            pointer-events: none;
        }

        .playlist-search-clear {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: var(--text-secondary);
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 0.7rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .playlist-search-clear:hover {
            background: rgba(255, 255, 255, 0.2);
            color: var(--text-primary);
        }

        .playlist-no-results {
            text-align: center;
            padding: 20px;
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        /* Playlist Save/Load */
        .playlist-actions {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .playlist-action-btn {
            flex: 1;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid var(--card-border);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .playlist-action-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            color: var(--text-primary);
        }

        .playlist-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .saved-playlists-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            padding: 20px;
        }

        .saved-playlists-content {
            background: var(--surface);
            border-radius: 16px;
            border: 1px solid var(--card-border);
            max-width: 400px;
            width: 100%;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .saved-playlists-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--card-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .saved-playlists-header h3 {
            margin: 0;
            font-size: 1.1rem;
        }

        .saved-playlists-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 4px;
        }

        .saved-playlists-close:hover {
            color: var(--text-primary);
        }

        .saved-playlists-body {
            padding: 16px 20px;
            overflow-y: auto;
            flex: 1;
        }

        .save-playlist-form {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }

        .save-playlist-input {
            flex: 1;
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid var(--card-border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .save-playlist-input::placeholder {
            color: var(--text-muted);
        }

        .save-playlist-btn {
            padding: 10px 16px;
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: black;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .save-playlist-btn:hover {
            transform: scale(1.02);
        }

        .save-playlist-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .saved-playlist-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            margin-bottom: 8px;
            transition: all 0.2s;
        }

        .saved-playlist-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .saved-playlist-info {
            flex: 1;
            min-width: 0;
        }

        .saved-playlist-name {
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .saved-playlist-meta {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .saved-playlist-actions {
            display: flex;
            gap: 6px;
        }

        .saved-playlist-load {
            padding: 6px 12px;
            background: var(--accent);
            color: black;
            border: none;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
        }

        .saved-playlist-delete {
            padding: 6px 10px;
            background: rgba(239, 68, 68, 0.2);
            color: #f87171;
            border: none;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
        }

        .saved-playlist-delete:hover {
            background: rgba(239, 68, 68, 0.4);
        }

        .no-saved-playlists {
            text-align: center;
            padding: 20px;
            color: var(--text-muted);
        }

        .status-pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 999px;
            font-size: 0.8rem;
            border: 1px solid var(--card-border);
        }

        .transport-controls {
            display: flex;
            gap: 12px;
            justify-content: space-between;
            align-items: center;
        }

        .transport-button {
            min-width: 64px;
            min-height: 64px;
            border-radius: 20px;
            border: none;
            background: var(--surface);
            color: var(--text-primary);
            font-size: 1.4rem;
            cursor: pointer;
        }

        .transport-button.play {
            flex: 1;
            background: linear-gradient(135deg, var(--accent-focus), #9f9bff);
            color: #fff;
            font-size: 1.6rem;
            box-shadow: 0 20px 40px rgba(109, 139, 255, 0.35);
        }

        .timeline {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .timeline input[type="range"] {
            width: 100%;
            accent-color: var(--accent-focus);
        }

        .timeline-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .intake-tabs {
            display: inline-flex;
            border-radius: 999px;
            border: 1px solid var(--card-border);
            overflow: hidden;
        }

        .intake-tab {
            border: none;
            background: transparent;
            padding: 12px 20px;
            min-height: 48px;
            cursor: pointer;
            color: var(--text-primary);
        }

        .intake-tab[aria-selected="true"] {
            background: linear-gradient(135deg, rgba(109, 139, 255, 0.18), rgba(109, 139, 255, 0));
            color: var(--text-primary);
        }

        .drop-zone {
            margin-top: 16px;
            border: 2px dashed rgba(109, 139, 255, 0.45);
            border-radius: 20px;
            padding: 28px 20px;
            text-align: center;
            background: var(--surface);
            min-height: 160px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            justify-content: center;
            cursor: pointer;
            transition: border 0.2s ease, box-shadow 0.2s ease;
        }

        .drop-zone--attention {
            border-color: var(--danger);
            box-shadow: 0 0 0 3px rgba(240, 93, 123, 0.2);
        }

        .drop-zone--hover {
            border-color: var(--accent-focus);
            box-shadow: 0 0 0 3px rgba(109, 139, 255, 0.25);
        }

        .playlist-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .playlist-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .playlist-button {
            width: 100%;
            border-radius: 18px;
            border: 1px solid var(--card-border);
            padding: 14px 18px;
            background: var(--surface);
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            gap: 12px;
            text-align: left;
            cursor: pointer;
            min-height: 64px;
        }

        .playlist-button[aria-current="true"] {
            border-color: var(--accent-focus);
            box-shadow: 0 0 0 2px rgba(109, 139, 255, 0.25);
        }

        .playlist-meta {
            display: flex;
            gap: 8px;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .badge {
            border-radius: 999px;
            padding: 3px 10px;
            font-size: 0.75rem;
            border: 1px solid var(--card-border);
        }

        .remove-btn {
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 1.2rem;
            min-width: 48px;
            min-height: 48px;
            border-radius: 12px;
            display: grid;
            place-items: center;
        }

        .advanced-controls .control-group {
            background: var(--surface);
            border-radius: 16px;
            padding: 18px;
        }

        .advanced-controls label {
            font-weight: 600;
            font-size: 0.95rem;
        }

        .advanced-controls input[type="range"],
        .advanced-controls select {
            width: 100%;
            margin-top: 8px;
        }

        .pill {
            border-radius: 12px;
            padding: 4px 10px;
            font-size: 0.8rem;
        }

        .insights-grid {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .insight-card,
        .sensor-card {
            border-radius: 20px;
            border: 1px solid var(--card-border);
            background: var(--card-bg);
            padding: 20px;
        }

        .insight-value {
            font-size: 2rem;
            font-weight: 600;
        }

        .sensor-card strong {
            display: block;
            margin-bottom: 8px;
        }

        .session-log-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 12px;
        }

        .session-log-actions button {
            border-radius: 999px;
            border: 1px solid var(--card-border);
            background: var(--surface);
            padding: 10px 16px;
            font-weight: 600;
            color: var(--text-primary);
            cursor: pointer;
            transition: opacity 0.2s ease;
        }

        .session-log-actions button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .alert-inline {
            border-radius: 16px;
            padding: 12px 16px;
            background: rgba(240, 93, 123, 0.12);
            color: var(--danger);
            border: 1px solid rgba(240, 93, 123, 0.35);
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        button:focus-visible,
        .mode-chip:focus-visible,
        .intake-tab:focus-visible,
        .playlist-button:focus-visible {
            outline: 3px solid rgba(109, 139, 255, 0.7);
            outline-offset: 2px;
        }

        /* Design spec §3: Responsive grid breakpoints */
        /* Three-column layout ≥1280px (default above) */
        /* Two-column layout 768-1279px */
        @media (min-width: 768px) and (max-width: 1279px) {
            .main-grid {
                grid-template-columns: repeat(2, minmax(280px, 1fr));
            }
            .insights-column {
                grid-column: 1 / -1;
            }
        }

        /* Single-column layout ≤767px (mobile) */
        @media (max-width: 767px) {
            .app-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .main-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .hero-actions button {
                flex: 1 1 100%;
            }

            .mode-tabs {
                position: sticky;
                top: 0;
                padding: 12px 0;
                background: linear-gradient(180deg, var(--bg-1), rgba(255, 255, 255, 0));
                z-index: 5;
            }

            /* Story 3-2: Mobile responsive */
            .controls-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .advanced-controls summary {
                font-size: 1rem;
            }

            .control-input {
                flex-direction: column;
                align-items: stretch;
            }

            .control-input output {
                text-align: left;
            }

            .sensor-lock-notice {
                flex-direction: column;
                text-align: center;
            }

            .unlock-btn {
                width: 100%;
            }
        }

        @keyframes breathe {
            0% { transform: scale(0.8); opacity: 0.6; }
            50% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0.6; }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.9; }
            50% { transform: scale(1.1); opacity: 1; }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideUpButtons {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideDownButtons {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .toast {
            pointer-events: none;
        }

        /* Story 3-3: Dialog Overlay Styles */
        .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.2s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .dialog-content {
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Story 4-2: Check-In Modal Styles */
        .checkin-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
            animation: fadeIn 0.2s ease-out;
        }

        .checkin-overlay.no-motion {
            animation: none;
        }

        .checkin-modal {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 32px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--card-border);
        }

        .checkin-modal h2 {
            margin: 0 0 8px 0;
            font-size: 24px;
            color: var(--text-primary);
        }

        .checkin-subtitle {
            margin: 0 0 24px 0;
            color: var(--text-muted);
            font-size: 14px;
        }

        .emoji-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
            margin-bottom: 24px;
        }

        @media (max-width: 600px) {
            .emoji-grid {
                grid-template-columns: 1fr;
            }
        }

        .emoji-button {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 16px;
            background: var(--bg-secondary, rgba(255,255,255,0.05));
            border: 2px solid transparent;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 80px;
            color: var(--text-primary);
        }

        .checkin-overlay.no-motion .emoji-button {
            transition: none;
        }

        .emoji-button:hover {
            transform: scale(1.05);
            border-color: var(--chip-accent, var(--accent-primary, #6366f1));
        }

        .checkin-overlay.no-motion .emoji-button:hover {
            transform: none;
        }

        .emoji-button:focus {
            outline: 2px solid var(--accent-primary, #6366f1);
            outline-offset: 2px;
        }

        .emoji-button.selected {
            border-color: var(--chip-accent, var(--accent-primary, #6366f1));
            border-width: 3px;
            background: var(--bg-tertiary, rgba(255,255,255,0.1));
        }

        .emoji-icon {
            font-size: 36px;
            line-height: 1;
        }

        .emoji-label {
            font-size: 11px;
            text-align: center;
            color: var(--text-muted);
            line-height: 1.3;
        }

        .checkin-notes-section {
            margin-bottom: 24px;
        }

        .checkin-notes-section label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-primary);
        }

        .checkin-note-hint {
            color: var(--text-muted);
            font-weight: normal;
        }

        .checkin-notes-textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--card-border);
            border-radius: 8px;
            background: var(--bg-secondary, rgba(255,255,255,0.05));
            color: var(--text-primary);
            font-family: inherit;
            font-size: 14px;
            resize: vertical;
            box-sizing: border-box;
        }

        .checkin-notes-textarea:focus {
            outline: 2px solid var(--accent-primary, #6366f1);
            outline-offset: 2px;
        }

        .checkin-char-count {
            margin-top: 4px;
            font-size: 12px;
            color: var(--text-muted);
            text-align: right;
        }

        .checkin-modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .checkin-close-button {
            position: absolute;
            top: 16px;
            right: 16px;
            background: transparent;
            border: none;
            font-size: 24px;
            color: var(--text-muted);
            cursor: pointer;
            padding: 4px 8px;
            line-height: 1;
        }

        .checkin-close-button:hover {
            color: var(--text-primary);
        }

        .checkin-close-button:focus {
            outline: 2px solid var(--accent-primary, #6366f1);
            border-radius: 4px;
        }

        /* Story 5-1: Sensor Consent Modal Styles */
        .sensor-consent-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
            animation: fadeIn 0.2s ease-out;
        }

        .sensor-consent-overlay.no-motion {
            animation: none;
        }

        .sensor-consent-modal {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 32px;
            max-width: 480px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--card-border);
        }

        .sensor-consent-modal h2 {
            margin: 0 0 16px 0;
            font-size: 24px;
            color: var(--text-primary);
        }

        .sensor-consent-content {
            margin-bottom: 24px;
        }

        .sensor-consent-intro {
            margin: 0 0 16px 0;
            color: var(--text-primary);
            font-size: 15px;
            line-height: 1.5;
        }

        .sensor-consent-list {
            margin: 0;
            padding-left: 24px;
            color: var(--text-secondary);
            font-size: 14px;
            line-height: 1.8;
        }

        .sensor-consent-list li {
            margin-bottom: 4px;
        }

        .sensor-consent-checkbox {
            margin-bottom: 24px;
            padding: 12px;
            background: var(--surface);
            border-radius: 8px;
        }

        .sensor-consent-checkbox .checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-size: 14px;
            color: var(--text-primary);
        }

        .sensor-consent-checkbox input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: var(--accent-focus);
        }

        .consent-hint {
            display: block;
            margin-top: 8px;
            margin-left: 30px;
            color: var(--text-secondary);
            font-size: 12px;
        }

        .sensor-consent-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .sensor-consent-actions .primary-btn {
            min-width: 100px;
        }

        .sensor-consent-actions .ghost-btn {
            min-width: 80px;
        }

        /* Story 5-1: Forget Device Confirmation Modal */
        .forget-device-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10002;
            animation: fadeIn 0.2s ease-out;
        }

        .forget-device-modal {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 24px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--card-border);
        }

        .forget-device-modal h3 {
            margin: 0 0 12px 0;
            font-size: 18px;
            color: var(--text-primary);
        }

        .forget-device-modal p {
            margin: 0 0 20px 0;
            color: var(--text-secondary);
            font-size: 14px;
            line-height: 1.5;
        }

        .forget-device-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .forget-device-actions .danger-btn {
            background: var(--danger);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
        }

        .forget-device-actions .danger-btn:hover {
            filter: brightness(1.1);
        }

        /* Story 5-1: Sensor Settings Styles */
        .sensor-settings {
            padding: 16px;
            background: var(--surface);
            border-radius: 12px;
            margin-top: 16px;
        }

        .sensor-settings-title {
            margin: 0 0 16px 0;
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .sensor-browser-notice {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 12px;
            background: rgba(109, 139, 255, 0.1);
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .sensor-browser-notice .notice-icon {
            font-size: 18px;
            flex-shrink: 0;
        }

        .sensor-browser-notice .notice-message {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .sensor-connected-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: rgba(58, 216, 167, 0.15);
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .sensor-connected-status .status-icon {
            color: var(--positive);
            font-weight: bold;
        }

        .sensor-connected-status .status-text {
            flex: 1;
            font-size: 14px;
            color: var(--text-primary);
        }

        .disconnect-btn {
            padding: 6px 12px;
            font-size: 12px;
            background: transparent;
            border: 1px solid var(--card-border);
            border-radius: 6px;
            cursor: pointer;
            color: var(--text-secondary);
        }

        .disconnect-btn:hover {
            border-color: var(--danger);
            color: var(--danger);
        }

        .sensor-connect-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .sensor-connect-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 14px 20px;
            border: 1px solid var(--card-border);
            border-radius: 10px;
            background: var(--card-bg);
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .sensor-connect-btn:hover:not(:disabled) {
            border-color: var(--accent-focus);
            box-shadow: 0 4px 12px rgba(109, 139, 255, 0.2);
        }

        .sensor-connect-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .sensor-connect-btn .btn-icon {
            font-size: 18px;
        }

        .sensor-connect-btn .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--card-border);
            border-top-color: var(--accent-focus);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .sensor-device-list {
            margin-top: 20px;
        }

        .device-list-title {
            margin: 0 0 12px 0;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .device-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .device-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .device-item:last-child {
            margin-bottom: 0;
        }

        .device-info {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            min-width: 0;
        }

        .device-type-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .device-details {
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .device-name {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .device-last-connected {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .device-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        .device-reconnect-btn {
            padding: 6px 14px;
            font-size: 12px;
            font-weight: 500;
            background: var(--accent-focus);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }

        .device-reconnect-btn:hover:not(:disabled) {
            filter: brightness(1.1);
        }

        .device-reconnect-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .device-forget-btn {
            padding: 6px 8px;
            background: transparent;
            border: 1px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            opacity: 0.6;
            transition: all 0.15s ease;
        }

        .device-forget-btn:hover {
            opacity: 1;
            border-color: var(--danger);
            background: rgba(240, 93, 123, 0.1);
        }

        .sensor-empty-state {
            text-align: center;
            padding: 20px;
            color: var(--text-secondary);
        }

        .sensor-empty-state p {
            margin: 0 0 12px 0;
            font-size: 14px;
        }

        .learn-more-link {
            font-size: 13px;
            color: var(--accent-focus);
            text-decoration: none;
        }

        .learn-more-link:hover {
            text-decoration: underline;
        }

        /* Story 5-2: Heart Rate Display & Threshold Settings */
        .sensor-hr-display {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(239, 68, 68, 0.05));
            border: 1px solid rgba(239, 68, 68, 0.2);
            border-radius: 12px;
            margin-bottom: 16px;
        }

        .hr-current {
            display: flex;
            align-items: baseline;
            gap: 8px;
        }

        .hr-icon {
            font-size: 24px;
            animation: heartbeat 1s ease-in-out infinite;
        }

        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .hr-value {
            font-size: 36px;
            font-weight: 700;
            color: #ef4444;
        }

        .hr-unit {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .hr-average {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 2px;
        }

        .hr-avg-label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .hr-avg-value {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .sensor-reconnecting-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.3);
            border-radius: 8px;
            margin-bottom: 12px;
            color: #fbbf24;
            font-size: 14px;
        }

        .sensor-disconnected-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 8px;
            margin-bottom: 12px;
        }

        .sensor-disconnected-status .status-icon {
            font-size: 16px;
        }

        .sensor-disconnected-status .status-text {
            flex: 1;
            font-size: 14px;
            color: var(--text-primary);
        }

        .reconnect-btn {
            padding: 6px 12px;
            background: var(--accent-primary, #6366f1);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
        }

        .reconnect-btn:hover {
            filter: brightness(1.1);
        }

        .simulated-badge {
            color: var(--text-muted);
            font-style: italic;
            font-weight: 400;
        }

        .sensor-threshold-setting {
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid var(--card-border);
        }

        .threshold-label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .threshold-input-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }

        .threshold-input {
            width: 80px;
            padding: 8px 12px;
            background: var(--input-bg, rgba(255,255,255,0.05));
            border: 1px solid var(--card-border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 16px;
            font-weight: 600;
            text-align: center;
        }

        .threshold-input:focus {
            outline: none;
            border-color: var(--accent-primary, #6366f1);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
        }

        .threshold-unit {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .threshold-help-text {
            margin: 0;
            font-size: 12px;
            color: var(--text-muted);
        }

        /* Story 5-3: Auto-Adjust Toggle (AC5) */
        .sensor-auto-adjust-setting {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--card-border);
        }

        .auto-adjust-label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
        }

        .auto-adjust-checkbox {
            width: 18px;
            height: 18px;
            accent-color: var(--accent-primary, #6366f1);
            cursor: pointer;
        }

        .auto-adjust-text {
            flex: 1;
        }

        .auto-adjust-help-text {
            margin: 8px 0 0 28px;
            font-size: 12px;
            color: var(--text-muted);
        }

        .sensor-simulator-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--card-border);
        }

        .sensor-connect-btn.simulator {
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
            border-color: transparent;
        }

        .simulator-note {
            margin: 8px 0 0 0;
            font-size: 12px;
            color: var(--text-muted);
            font-style: italic;
        }

        /* Story 5-2: Sensor Suggestion Toast */
        .sensor-suggestion-toast {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px 20px;
            background: var(--card-bg, #1e293b);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            z-index: 1100;
            animation: slideUp 0.3s ease-out;
            max-width: 90vw;
        }

        .sensor-suggestion-toast.no-motion {
            animation: none;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .suggestion-content {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .suggestion-icon {
            font-size: 28px;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .suggestion-text h4 {
            margin: 0 0 4px 0;
            font-size: 15px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .suggestion-text p {
            margin: 0;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .suggestion-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }

        .suggestion-accept-btn {
            padding: 8px 16px;
            background: var(--accent-primary, #6366f1);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: filter 0.15s ease;
        }

        .suggestion-accept-btn:hover {
            filter: brightness(1.1);
        }

        .suggestion-accept-btn:focus {
            outline: 2px solid white;
            outline-offset: 2px;
        }

        .suggestion-dismiss-btn {
            padding: 8px 16px;
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--card-border);
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .suggestion-dismiss-btn:hover {
            background: var(--bg-tertiary, rgba(255,255,255,0.05));
            color: var(--text-primary);
        }

        /* Story 6-1: Offline Banner */
        .offline-banner {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: #1c1917;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(245, 158, 11, 0.3);
            z-index: 1200;
            animation: slideDown 0.3s ease-out;
            max-width: 90vw;
            font-weight: 500;
        }

        .offline-banner.no-motion {
            animation: none;
        }

        .offline-banner.online {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .offline-banner-icon {
            font-size: 20px;
        }

        .offline-banner-text {
            font-size: 14px;
        }

        .offline-banner-dismiss {
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.2);
            color: inherit;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 8px;
        }

        .offline-banner-dismiss:hover {
            background: rgba(0, 0, 0, 0.3);
        }

        /* Story 6-1: Update Toast */
        .update-toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 18px;
            background: var(--card-bg, #1e293b);
            border: 1px solid var(--accent-focus, #6d8bff);
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            z-index: 1100;
            animation: slideUp 0.3s ease-out;
            max-width: 90vw;
        }

        .update-toast.no-motion {
            animation: none;
        }

        .update-toast-icon {
            font-size: 24px;
        }

        .update-toast-text {
            flex: 1;
        }

        .update-toast-text strong {
            display: block;
            font-size: 14px;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .update-toast-text span {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .update-toast-actions {
            display: flex;
            gap: 8px;
        }

        .update-btn {
            padding: 8px 16px;
            background: var(--accent-focus, #6d8bff);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: filter 0.15s ease;
        }

        .update-btn:hover {
            filter: brightness(1.1);
        }

        .update-dismiss-btn {
            padding: 8px 12px;
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--card-border);
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
        }

        /* Story 6-2: Install Prompt */
        .install-prompt {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 18px;
            background: var(--card-bg);
            border: 1px solid var(--accent-energize, #ffb562);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            margin: 16px 0;
            animation: slideUp 0.3s ease-out;
        }

        .install-prompt.no-motion {
            animation: none;
        }

        .install-prompt:focus {
            outline: 2px solid var(--accent-focus, #6d8bff);
            outline-offset: 2px;
        }

        .install-prompt-icon {
            flex-shrink: 0;
        }

        .install-prompt-icon img {
            display: block;
            border-radius: 10px;
        }

        .install-prompt-content {
            flex: 1;
            min-width: 0;
        }

        .install-prompt-title {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .install-prompt-text {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .install-prompt-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }

        .install-btn {
            padding: 8px 16px;
            background: var(--accent-energize, #ffb562);
            color: #1a1a2e;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: filter 0.15s ease;
        }

        .install-btn:hover:not(:disabled) {
            filter: brightness(1.1);
        }

        .install-btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }

        .install-dismiss-btn {
            padding: 8px 12px;
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--card-border);
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
        }

        .install-dismiss-btn:hover {
            background: var(--surface);
        }

        /* Story 6-2: Safari Install Instructions */
        .safari-instructions {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 14px 18px;
            background: var(--card-bg);
            border: 1px solid var(--accent-calm, #4edbc6);
            border-radius: 12px;
            margin: 16px 0;
            animation: slideUp 0.3s ease-out;
        }

        .safari-instructions.no-motion {
            animation: none;
        }

        .safari-instructions-icon {
            font-size: 28px;
            flex-shrink: 0;
        }

        .safari-instructions-content {
            flex: 1;
            min-width: 0;
        }

        .safari-instructions-title {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .safari-instructions-text {
            font-size: 13px;
            color: var(--text-secondary);
            margin: 0 0 8px 0;
        }

        .safari-share-hint {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            color: var(--accent-calm, #4edbc6);
            font-weight: 500;
        }

        .safari-share-icon {
            font-size: 18px;
            line-height: 1;
        }

        .safari-instructions-dismiss {
            padding: 8px 16px;
            background: var(--accent-calm, #4edbc6);
            color: #1a1a2e;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            flex-shrink: 0;
            align-self: center;
        }

        .safari-instructions-dismiss:hover {
            filter: brightness(1.1);
        }

        /* Story 6-1: Offline Settings */
        .offline-settings {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 16px;
            margin-top: 16px;
            border: 1px solid var(--card-border);
        }

        .offline-settings-title {
            margin: 0 0 12px 0;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .offline-cache-toggle {
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .offline-cache-toggle label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .offline-cache-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .offline-cache-toggle-text {
            font-size: 14px;
            color: var(--text-primary);
        }

        .offline-cache-help {
            margin: 8px 0 0 26px;
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .offline-storage-usage {
            margin-top: 12px;
            padding: 10px;
            background: var(--bg-secondary, rgba(255,255,255,0.03));
            border-radius: 8px;
            font-size: 12px;
        }

        .offline-storage-label {
            color: var(--text-secondary);
            display: block;
            margin-bottom: 4px;
        }

        .offline-storage-value {
            color: var(--text-primary);
            font-weight: 500;
        }

        .offline-storage-bar {
            margin-top: 6px;
            height: 4px;
            background: var(--bg-tertiary, rgba(255,255,255,0.1));
            border-radius: 2px;
            overflow: hidden;
        }

        .offline-storage-bar-fill {
            height: 100%;
            background: var(--accent-focus, #6d8bff);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .offline-clear-btn {
            margin-top: 10px;
            padding: 6px 12px;
            background: transparent;
            color: var(--danger, #f05d7b);
            border: 1px solid var(--danger, #f05d7b);
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .offline-clear-btn:hover {
            background: var(--danger, #f05d7b);
            color: white;
        }

        /* Install App Section in Offline Settings */
        .install-app-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--card-border);
        }

        .install-app-title {
            font-size: 14px;
            font-weight: 600;
            margin: 0 0 12px 0;
            color: var(--text-primary);
        }

        .install-app-text {
            font-size: 13px;
            color: var(--text-secondary);
            margin: 0 0 10px 0;
        }

        .install-app-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 10px 18px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .install-app-btn:hover {
            filter: brightness(1.1);
        }

        .install-app-steps {
            margin: 0;
            padding-left: 20px;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .install-app-steps li {
            margin-bottom: 6px;
            line-height: 1.5;
        }

        .install-app-steps strong {
            color: var(--text-primary);
        }

        /* Story 6-1: Cached Track Indicator (AC8) */
        .cached-indicator {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            margin-left: 4px;
            color: var(--positive, #3ad8a7);
            opacity: 0.9;
        }

        .cached-indicator-icon {
            position: relative;
        }

        .cached-indicator-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--card-bg, #1e293b);
            border: 1px solid var(--card-border);
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.15s ease;
            pointer-events: none;
            z-index: 100;
        }

        .cached-indicator:hover .cached-indicator-tooltip {
            opacity: 1;
            visibility: visible;
        }

        /* Story 4-3: Insights Dashboard Styles */
        .insights-panel {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
        }

        .insights-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            gap: 16px;
            flex-wrap: wrap;
        }

        .insights-header h3 {
            margin: 0;
            font-size: 18px;
            color: var(--text-primary);
        }

        .date-range-selector {
            display: flex;
            gap: 4px;
            background: var(--bg-secondary, rgba(255,255,255,0.05));
            border-radius: 8px;
            padding: 4px;
        }

        .date-range-selector button {
            padding: 6px 12px;
            border: none;
            background: transparent;
            color: var(--text-muted);
            font-size: 13px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .date-range-selector button:hover {
            background: var(--bg-tertiary, rgba(255,255,255,0.08));
        }

        .date-range-selector button.active {
            background: var(--accent-primary, #6366f1);
            color: white;
        }

        .date-range-selector button:focus {
            outline: 2px solid var(--accent-primary, #6366f1);
            outline-offset: 2px;
        }

        .summary-cards {
            display: grid;
            gap: 12px;
            margin-bottom: 24px;
        }

        .summary-card {
            background: var(--bg-secondary, rgba(255,255,255,0.05));
            border-radius: 10px;
            padding: 16px;
            text-align: center;
        }

        .summary-card .card-icon {
            font-size: 24px;
            display: block;
            margin-bottom: 8px;
        }

        .summary-card .card-value {
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            line-height: 1.2;
        }

        .summary-card .card-label {
            font-size: 13px;
            color: var(--text-muted);
            margin-top: 4px;
        }

        .summary-card .card-subtitle {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 4px;
            opacity: 0.8;
        }

        .chart-section {
            margin-bottom: 24px;
            overflow-x: auto;
        }

        .chart-section h4 {
            font-size: 14px;
            color: var(--text-muted);
            margin: 0 0 12px 0;
            font-weight: 500;
        }

        .chart-section canvas {
            max-width: 100%;
            background: var(--bg-secondary, rgba(255,255,255,0.03));
            border-radius: 8px;
            display: block;
        }

        .chart-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            margin-top: 12px;
            justify-content: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--text-muted);
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .legend-count {
            opacity: 0.7;
        }

        .export-section {
            display: flex;
            gap: 12px;
            justify-content: center;
            padding-top: 16px;
            border-top: 1px solid var(--card-border);
        }

        .export-section button {
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .export-section .primary-btn {
            background: var(--accent-primary, #6366f1);
            color: white;
            border: none;
        }

        .export-section .primary-btn:hover:not(:disabled) {
            filter: brightness(1.1);
        }

        .export-section .primary-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .export-section .ghost-btn {
            background: transparent;
            color: var(--text-muted);
            border: 1px solid var(--card-border);
        }

        .export-section .ghost-btn:hover:not(:disabled) {
            background: var(--bg-secondary, rgba(255,255,255,0.05));
            color: var(--text-primary);
        }

        .export-section .ghost-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .insights-empty-state {
            text-align: center;
            padding: 40px 20px;
        }

        .insights-empty-state .empty-icon {
            font-size: 48px;
            display: block;
            margin-bottom: 16px;
        }

        .insights-empty-state p {
            margin: 0 0 8px;
            color: var(--text-primary);
            font-size: 16px;
        }

        .insights-empty-state small {
            color: var(--text-muted);
            font-size: 13px;
        }

        /* Reduced motion support for insights */
        @media (prefers-reduced-motion: reduce) {
            .date-range-selector button {
                transition: none;
            }
            .export-section button {
                transition: none;
            }
        }

        /* Mobile Bottom Navigation */
        .mobile-bottom-nav {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 70px;
            background: var(--card-bg);
            border-top: 1px solid var(--card-border);
            z-index: 9999;
            padding-bottom: env(safe-area-inset-bottom, 0);
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.15);
        }

        .mobile-nav-items {
            display: flex;
            height: 100%;
            justify-content: space-around;
            align-items: center;
            padding: 0 8px;
        }

        .mobile-nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 8px 16px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 12px;
            transition: all 0.2s ease;
            min-width: 70px;
        }

        .mobile-nav-item.active {
            color: var(--accent-focus);
            background: rgba(109, 139, 255, 0.1);
        }

        .mobile-nav-item:active {
            transform: scale(0.95);
        }

        .mobile-nav-icon {
            font-size: 1.5rem;
            line-height: 1;
        }

        .mobile-nav-label {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .mobile-nav-badge {
            position: absolute;
            top: 2px;
            right: 8px;
            background: var(--danger);
            color: white;
            font-size: 0.6rem;
            padding: 2px 5px;
            border-radius: 8px;
            font-weight: 700;
        }

        /* Mobile view containers */
        .mobile-view {
            display: none;
        }

        .mobile-view.active {
            display: block;
        }

        /* Mobile-only visibility classes */
        @media (max-width: 767px) {
            .mobile-bottom-nav {
                display: block;
            }

            .screen {
                padding-bottom: calc(90px + env(safe-area-inset-bottom, 0));
            }

            /* Hide desktop grid on mobile */
            .main-grid {
                display: none;
            }

            /* Show mobile views */
            .mobile-views-container {
                display: block;
            }

            /* Mobile header adjustments */
            .app-header {
                padding: 8px 0;
            }

            .app-header h1 {
                font-size: 1.4rem;
            }

            .header-actions {
                flex-wrap: wrap;
            }

            .header-actions button {
                padding: 0 12px;
                min-height: 40px;
                font-size: 0.85rem;
            }

            /* Mobile view panel styling */
            .mobile-view .panel {
                margin-bottom: 16px;
            }

            /* Compact mode tabs for mobile */
            .mobile-view .mode-tabs {
                position: static;
                background: transparent;
            }

            .mobile-view .mode-chip {
                flex: 1;
                min-height: 48px;
                padding: 8px 12px;
            }

            /* Compact transport for mobile */
            .mobile-view .transport-controls {
                padding: 12px 0;
            }

            .mobile-view .transport-button {
                width: 48px;
                height: 48px;
            }

            .mobile-view .transport-button.play {
                width: 60px;
                height: 60px;
            }

            /* Compact playlist for mobile */
            .mobile-view .playlist-track {
                padding: 10px 12px;
            }

            /* Compact timers for mobile */
            .mobile-view .timer-section {
                padding: 12px;
            }

            .mobile-view .timer-time {
                font-size: 2rem;
            }

            /* Mobile player fixed at top - always visible */
            .mobile-player-fixed {
                margin-bottom: 16px;
            }

            .mobile-player-fixed .transport-controls {
                padding: 12px 0;
            }

            .mobile-player-fixed .transport-button {
                width: 48px;
                height: 48px;
            }

            .mobile-player-fixed .transport-button.play {
                width: 60px;
                height: 60px;
            }
        }

        /* Desktop keeps normal grid */
        @media (min-width: 768px) {
            .mobile-views-container {
                display: none;
            }

            .mobile-bottom-nav {
                display: none !important;
            }

            .mobile-player-fixed {
                display: none;
            }
        }

        /* Fullscreen Visualizer - Mobile Optimized */
        .fullscreen-visualizer-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 99999;
            background: #0a0a0a;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .fullscreen-visualizer-overlay canvas {
            width: 100% !important;
            height: 100% !important;
            object-fit: contain;
        }

        .fullscreen-viz-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100000;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .fullscreen-viz-btn {
            padding: 10px 16px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .fullscreen-viz-btn.active {
            background: var(--accent-focus);
            border-color: var(--accent-focus);
        }

        .fullscreen-viz-close {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100000;
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        /* Fullscreen track info */
        .fullscreen-track-info {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100000;
            text-align: center;
            color: white;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
            padding: 12px 24px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            max-width: 90vw;
        }

        .fullscreen-track-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .fullscreen-track-artist {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        /* Landscape orientation on mobile */
        @media (max-width: 767px) and (orientation: landscape) {
            .fullscreen-viz-controls {
                top: 10px;
                right: 10px;
                flex-direction: row;
            }

            .fullscreen-viz-btn {
                padding: 8px 12px;
                font-size: 0.8rem;
            }

            .fullscreen-viz-close {
                top: 10px;
                left: 10px;
                padding: 8px 14px;
            }

            .fullscreen-track-info {
                bottom: 15px;
                padding: 8px 16px;
            }

            .fullscreen-track-title {
                font-size: 1rem;
            }

            .fullscreen-track-artist {
                font-size: 0.8rem;
            }
        }

        /* Portrait on mobile - stack controls vertically */
        @media (max-width: 767px) and (orientation: portrait) {
            .fullscreen-viz-controls {
                top: auto;
                bottom: 100px;
                right: 10px;
                flex-direction: column;
            }

            .fullscreen-track-info {
                bottom: 20px;
            }
        }

        /* Hide mobile nav when visualizer is fullscreen */
        body.viz-fullscreen .mobile-bottom-nav {
            display: none !important;
        }

        body.viz-fullscreen {
            overflow: hidden;
        }

        /* Mobile Header Styles */
        .mobile-header {
            display: none;
        }

        .mobile-header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--card-bg);
            border-bottom: 1px solid var(--card-border);
        }

        .mobile-header-title {
            font-size: 1rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .mobile-menu-btn {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: 1px solid var(--card-border);
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2rem;
        }

        .mobile-menu-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--card-bg);
            border-bottom: 1px solid var(--card-border);
            padding: 12px;
            display: none;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        .mobile-menu-dropdown.open {
            display: flex;
        }

        .mobile-menu-dropdown button {
            padding: 12px;
            text-align: left;
            border-radius: 8px;
        }

        .calibration-bar {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--card-border);
        }

        .calibration-status {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .calibration-status.calibrated {
            color: #4ade80;
        }

        .calibration-btn {
            padding: 6px 12px;
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
            border: 1px solid #4ade80;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .calibration-btn.not-calibrated {
            background: var(--accent-focus);
            color: white;
            border-color: var(--accent-focus);
        }

        @media (max-width: 767px) {
            .mobile-header {
                display: block;
                position: sticky;
                top: 0;
                z-index: 100;
            }

            .app-header {
                display: none;
            }
        }

        @media (min-width: 768px) {
            .mobile-header {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useMemo, useCallback } = React;

        const MODE_LIBRARY = [
            {
                id: 'focus',
                label: 'Focus',
                short: 'Deep work',
                description: 'Steady orbit + beta beats keep intrusive thoughts at bay.',
                heroCopy: 'Steady pulses to clear the mental slate in two breaths.',
                accent: 'var(--accent-focus)',
                preset: {
                    speed: 0.55,
                    intensity: 0.85,
                    spatialDepth: 0.45,
                    movement: 'circle',
                    binaural: { enabled: true, freq: 14 },
                    noise: { type: 'pink', volume: 0.08 },
                    spatial: { itdAmount: 0.7, headShadow: 0.5, directionalDepth: 0.15, crossBleed: 0.05, panCurve: 2.0, backDepth: 0.55, hardPanThreshold: 0.1 }
                },
                highlights: ['Beta 14 Hz pulses', 'Low drift orbit', 'Pink noise cushion']
            },
            {
                id: 'calm',
                label: 'Calm',
                short: 'Breathing companion',
                description: 'Longer arcs, theta beats, and softer noise for co-regulation.',
                heroCopy: 'Elongated orbit with theta support for family wind-downs.',
                accent: 'var(--accent-calm)',
                preset: {
                    speed: 0.35,
                    intensity: 0.6,
                    spatialDepth: 0.6,
                    movement: 'figure8',
                    binaural: { enabled: true, freq: 8 },
                    noise: { type: 'white', volume: 0.05 },
                    spatial: { itdAmount: 0.5, headShadow: 0.4, directionalDepth: 0.1, crossBleed: 0.1, panCurve: 1.5, backDepth: 0.65, hardPanThreshold: 0.15 }
                },
                highlights: ['Theta 8 Hz support', 'Figure-eight drift', 'Gentle white noise']
            },
            {
                id: 'energize',
                label: 'Energize',
                short: 'Quick reset',
                description: 'Fast arcs + brighter stereo swing for playful bursts.',
                heroCopy: 'Hyper-clear panning for a quick dopamine reset.',
                accent: 'var(--accent-energize)',
                preset: {
                    speed: 0.95,
                    intensity: 0.9,
                    spatialDepth: 0.7,
                    movement: 'random',
                    binaural: { enabled: true, freq: 30 },
                    noise: { type: 'pink', volume: 0.12 },
                    spatial: { itdAmount: 1.0, headShadow: 0.7, directionalDepth: 0.25, crossBleed: 0, panCurve: 3.0, backDepth: 0.4, hardPanThreshold: 0.05 }
                },
                highlights: ['Gamma 30 Hz spark', 'Randomized orbit', 'Louder pink noise']
            },
            {
                id: 'apd-friendly',
                label: 'APD Friendly',
                short: 'Accessible 8D',
                description: 'Optimized for auditory processing differences - relies on volume and tone, not timing.',
                heroCopy: 'Enhanced spatial cues designed for brains that process differently.',
                accent: 'var(--accent-calm)',
                preset: {
                    speed: 0.45,
                    intensity: 0.8,
                    spatialDepth: 0.5,
                    movement: 'quadrant',
                    binaural: { enabled: false, freq: 0 },
                    noise: { type: 'pink', volume: 0.06 },
                    spatial: { itdAmount: 0, headShadow: 1.0, directionalDepth: 0.35, crossBleed: 0, panCurve: 4.0, backDepth: 0.35, hardPanThreshold: 0.05 }
                },
                highlights: ['No timing cues (ITD off)', 'Max muffling contrast', 'Clear L/R separation']
            }
        ];

        const HERO_BREATH_DURATION = 20;

        // Mode-specific track rating icons - reinforces the mindset
        const RATING_ICONS = {
            focus: {
                boost: { icon: '🎯', label: 'Locked In', desc: 'This locks me in' },
                neutral: { icon: '➖', label: 'Meh', desc: 'Play less often' },
                remove: { icon: '💭', label: 'Distracting', desc: 'Mind wanders' }
            },
            calm: {
                boost: { icon: '🌊', label: 'Flowing', desc: 'Brings peace' },
                neutral: { icon: '➖', label: 'Meh', desc: 'Play less often' },
                remove: { icon: '🌀', label: 'Turbulent', desc: 'Unsettling' }
            },
            energize: {
                boost: { icon: '⚡', label: 'Energizing', desc: 'Fires me up' },
                neutral: { icon: '➖', label: 'Meh', desc: 'Play less often' },
                remove: { icon: '💤', label: 'Draining', desc: 'Makes me tired' }
            },
            'apd-friendly': {
                boost: { icon: '🔮', label: 'Crystal Clear', desc: 'Easy to follow' },
                neutral: { icon: '➖', label: 'Meh', desc: 'Play less often' },
                remove: { icon: '🌫️', label: 'Muddy', desc: 'Hard to process' }
            }
        };

        // Story 3-3: Custom Preset Storage Keys
        const CUSTOM_PRESETS_KEY = 'mpe_8d_custom_presets';

        // Supported MIME types for file intake validation
        const SUPPORTED_MIME_TYPES = [
            'audio/mpeg',      // .mp3
            'audio/wav',       // .wav
            'audio/wave',      // .wav (alternate)
            'audio/ogg',       // .ogg
            'audio/x-wav'      // .wav (legacy)
        ];

        // Story 3-2: Parameter range constants
        const PARAM_RANGES = {
            speed: { min: 0, max: 1, step: 0.05 },
            intensity: { min: 0, max: 1, step: 0.05 },
            spatialDepth: { min: 0, max: 1, step: 0.05 },
            binauralFreq: { min: 0, max: 40, step: 1 },
            noiseVolume: { min: 0, max: 0.3, step: 0.01 }
        };

        // Helper: Get binaural frequency band name
        const getBinauralBand = (freq) => {
            if (freq < 4) return 'Delta';
            if (freq < 8) return 'Theta';
            if (freq < 14) return 'Alpha';
            if (freq < 30) return 'Beta';
            return 'Gamma';
        };

        // Helper: Get binaural frequency hint
        const getBinauralHint = (freq) => {
            if (freq < 4) return 'Deep sleep, healing';
            if (freq < 8) return 'Deep relaxation, meditation';
            if (freq < 14) return 'Calm focus, learning';
            if (freq < 30) return 'Active focus, problem-solving';
            return 'Peak alertness, high energy';
        };

        // ============================================================
        // Story 3-3: Custom Preset CRUD Storage Helpers
        // ============================================================
        
        const loadCustomPresets = () => {
            try {
                const saved = localStorage.getItem(CUSTOM_PRESETS_KEY);
                return saved ? JSON.parse(saved) : {};
            } catch (err) {
                console.error('[PresetStorage] Failed to load custom presets:', err);
                return {};
            }
        };

        const saveCustomPreset = (presetData, showToastFn) => {
            try {
                const customPresets = loadCustomPresets();
                const id = `custom-preset-${Date.now()}`;
                
                customPresets[id] = {
                    id,
                    name: presetData.name,
                    description: presetData.description || '',
                    createdAt: Date.now(),
                    lastUsedAt: Date.now(),
                    preset: {
                        speed: presetData.speed,
                        intensity: presetData.intensity,
                        spatialDepth: presetData.spatialDepth,
                        movement: presetData.movement,
                        binaural: { 
                            enabled: presetData.binauralEnabled, 
                            freq: presetData.binauralFreq 
                        },
                        noise: {
                            type: presetData.noiseType,
                            volume: presetData.noiseVolume
                        },
                        spatial: {
                            itdAmount: presetData.itdAmount ?? 0.7,
                            headShadow: presetData.headShadow ?? 0.5,
                            directionalDepth: presetData.directionalDepth ?? 0.15,
                            crossBleed: presetData.crossBleed ?? 0,
                            panCurve: presetData.panCurve ?? 2.0,
                            backDepth: presetData.backDepth ?? 0.55,
                            hardPanThreshold: presetData.hardPanThreshold ?? 0.1
                        }
                    },
                    color: presetData.color || '#6366f1',
                    tags: presetData.tags || []
                };
                
                localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(customPresets));
                
                // Add to preset order
                const order = getPresetOrder();
                order.push(id);
                savePresetOrder(order);
                
                console.log(`[PresetStorage] Saved custom preset: ${id} - ${presetData.name}`);
                return id;
            } catch (err) {
                if (err.name === 'QuotaExceededError') {
                    if (showToastFn) showToastFn('Storage full. Please delete old presets.', 'error');
                } else {
                    console.error('[PresetStorage] Failed to save preset:', err);
                    if (showToastFn) showToastFn('Error saving preset.', 'error');
                }
                return null;
            }
        };

        const updateCustomPreset = (id, updates, showToastFn) => {
            try {
                const customPresets = loadCustomPresets();
                if (customPresets[id]) {
                    customPresets[id] = { 
                        ...customPresets[id], 
                        ...updates,
                        lastUsedAt: Date.now()
                    };
                    localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(customPresets));
                    console.log(`[PresetStorage] Updated custom preset: ${id}`);
                    return true;
                }
                console.warn(`[PresetStorage] Preset not found: ${id}`);
                return false;
            } catch (err) {
                console.error('[PresetStorage] Failed to update preset:', err);
                if (showToastFn) showToastFn('Error updating preset.', 'error');
                return false;
            }
        };

        const deleteCustomPreset = (id, showToastFn) => {
            try {
                const customPresets = loadCustomPresets();
                const presetName = customPresets[id]?.name || id;
                
                delete customPresets[id];
                localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(customPresets));
                
                // Remove from order
                const order = getPresetOrder().filter(pid => pid !== id);
                savePresetOrder(order);
                
                console.log(`[PresetStorage] Deleted custom preset: ${id}`);
                
                // Return the deleted preset ID and name for caller to handle track updates
                return { id, name: presetName };
            } catch (err) {
                console.error('[PresetStorage] Failed to delete preset:', err);
                if (showToastFn) showToastFn('Error deleting preset.', 'error');
                return null;
            }
        };

        const getAllPresets = () => {
            const defaults = MODE_LIBRARY.map(mode => ({
                id: mode.id,
                name: mode.label,
                description: mode.description,
                preset: mode.preset,
                color: mode.accent,
                isDefault: true,
                createdAt: 0,
                lastUsedAt: 0
            }));
            
            const custom = Object.values(loadCustomPresets()).map(p => ({
                ...p,
                isDefault: false
            }));
            
            // Apply user-defined order
            const order = getPresetOrder();
            const allPresets = [...defaults, ...custom];
            const ordered = order
                .map(id => allPresets.find(p => p.id === id))
                .filter(Boolean);
            
            // Add any new presets not in order (defensive)
            const orderedIds = new Set(ordered.map(p => p.id));
            const missing = allPresets.filter(p => !orderedIds.has(p.id));
            
            return [...ordered, ...missing];
        };

        const getPresetOrder = () => {
            try {
                const saved = localStorage.getItem('mpe_8d_preset_order');
                if (saved) return JSON.parse(saved);
            } catch (err) {
                console.error('[PresetStorage] Failed to load preset order:', err);
            }
            
            // Default order: defaults first, then custom by creation date
            const defaults = MODE_LIBRARY.map(m => m.id);
            const custom = Object.keys(loadCustomPresets()).sort();
            return [...defaults, ...custom];
        };

        const savePresetOrder = (order) => {
            try {
                localStorage.setItem('mpe_8d_preset_order', JSON.stringify(order));
            } catch (err) {
                console.error('[PresetStorage] Failed to save preset order:', err);
            }
        };

        // Helper to format "last used" timestamp
        const formatLastUsed = (timestamp) => {
            if (!timestamp || timestamp === 0) return 'Never used';
            
            const now = Date.now();
            const diff = now - timestamp;
            const seconds = Math.floor(diff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            
            if (seconds < 60) return 'Just now';
            if (minutes < 60) return `${minutes} minute${minutes === 1 ? '' : 's'} ago`;
            if (hours < 24) return `${hours} hour${hours === 1 ? '' : 's'} ago`;
            if (days < 7) return `${days} day${days === 1 ? '' : 's'} ago`;
            
            const date = new Date(timestamp);
            return date.toLocaleDateString();
        };

        // Spatial Audio Tuner - Visual debugging tool for dialing in 3D audio effect
        const SpatialAudioTuner = ({
            isOpen,
            onClose,
            onApplyGains, // Function to apply gains to audio engine
            onApplyEQ, // Function to apply EQ: (bass, mid, treble, clarity) => void
            currentVolume = 0.7,
            onVolumeChange,
            // EQ props from parent
            eqBass = 0,
            eqMid = 0,
            eqTreble = 0,
            eqClarity = 0,
            onEqBassChange,
            onEqMidChange,
            onEqTrebleChange,
            onEqClarityChange,
            onCalibrationComplete // Called when calibration is saved
        }) => {
            const [orbPosition, setOrbPosition] = React.useState({ x: 0, y: -80 }); // Start at "front"
            const [isDragging, setIsDragging] = React.useState(false);
            const containerRef = React.useRef(null);
            const [activeTab, setActiveTab] = React.useState('position'); // 'position', 'spatial', 'eq', 'calibrate'
            const [expandedSections, setExpandedSections] = React.useState({ spatial: false, eq: true }); // Collapsible sections

            // Advanced tuning settings
            const [crossBleed, setCrossBleed] = React.useState(0); // 0-0.3: how much bleeds to opposite ear
            const [backDepth, setBackDepth] = React.useState(0.55); // 0.3-1.0: volume when behind
            const [panCurve, setPanCurve] = React.useState(2.0); // 1-4: how aggressively pan separates L/R
            const [hardPanThreshold, setHardPanThreshold] = React.useState(0.1); // 0-0.5: center dead zone
            const [itdAmount, setItdAmount] = React.useState(0.7); // 0-1.5: ITD multiplier (0.7ms max is realistic)
            const [directionalDepth, setDirectionalDepth] = React.useState(0.15); // 0-0.3: extra attenuation for ear facing away
            const [headShadow, setHeadShadow] = React.useState(0.5); // 0-1: how much high-freq is cut when behind/opposite

            // Calibration wizard state
            const [showCalibration, setShowCalibration] = React.useState(false);
            const [calibrationStep, setCalibrationStep] = React.useState(0);
            const [calibrationDelayMs, setCalibrationDelayMs] = React.useState(10); // Start at 10ms for testing
            const [calibrationTimingActive, setCalibrationTimingActive] = React.useState(false); // Prevents useEffect from overwriting ITD delays
            const [calibrationResults, setCalibrationResults] = React.useState({
                canHearLeftRight: null,      // Can perceive L/R panning
                leftRightIntensity: 2.0,     // How much pan curve they need
                canHearFrontBack: null,      // Can perceive front/back via muffling
                frontBackIntensity: 0.5,     // Head shadow amount
                canHearTimingLeft: null,     // Can perceive ITD in left ear
                canHearTimingRight: null,    // Can perceive ITD in right ear
                timingThresholdLeft: null,   // Personal timing threshold (ms) for left ear
                timingThresholdRight: null,  // Personal timing threshold (ms) for right ear
                preferredVolume: 0.5         // Their optimal volume
            });

            // Helper: Reset spatial settings to defaults for clean calibration tests
            const resetToDefaults = React.useCallback(() => {
                setHeadShadow(0.5);
                setDirectionalDepth(0.15);
                setCrossBleed(0);
                setPanCurve(2.0);
                setItdAmount(0.7);
                setHardPanThreshold(0.1);
                setBackDepth(0.55);
                setOrbPosition({ x: 0, y: -80 }); // Front center
            }, []);

            // Load saved calibration settings on mount
            React.useEffect(() => {
                try {
                    const saved = localStorage.getItem('mpe_8d_calibration');
                    if (saved) {
                        const data = JSON.parse(saved);
                        console.log('[Calibration] Loading saved settings:', data);
                        if (data.itdAmount !== undefined) setItdAmount(data.itdAmount);
                        if (data.headShadow !== undefined) setHeadShadow(data.headShadow);
                        if (data.panCurve !== undefined) setPanCurve(data.panCurve);
                        if (data.directionalDepth !== undefined) setDirectionalDepth(data.directionalDepth);
                        if (data.crossBleed !== undefined) setCrossBleed(data.crossBleed);
                        if (data.backDepth !== undefined) setBackDepth(data.backDepth);
                        if (data.hardPanThreshold !== undefined) setHardPanThreshold(data.hardPanThreshold);
                        if (data.results) setCalibrationResults(data.results);
                    }
                } catch (err) {
                    console.error('[Calibration] Failed to load saved settings:', err);
                }
            }, []); // Only run on mount

            // Calculate audio parameters from orb position
            const radius = 80; // Head radius
            const orbRadius = Math.sqrt(orbPosition.x ** 2 + orbPosition.y ** 2);
            const angle = Math.atan2(orbPosition.x, -orbPosition.y) * (180 / Math.PI); // 0=front, 90=right, 180=back, -90=left
            const normalizedAngle = ((angle + 360) % 360); // 0-360

            // Calculate pan position (-1 to 1) based on X position
            const panPosition = Math.max(-1, Math.min(1, orbPosition.x / radius));

            // Calculate if behind (y > 0 means behind the head in our coordinate system)
            const isBehind = orbPosition.y > 0;
            const behindAmount = isBehind ? Math.min(1, orbPosition.y / radius) : 0; // 0-1 how far behind

            // Base depth multiplier for being behind
            const baseDepthMultiplier = isBehind ? backDepth : 1.0;

            // Directional depth: the ear CLOSER to the source gets extra attenuation when sound is behind
            // This simulates the pinna (outer ear) blocking sounds from behind
            // At back-left (pan=-0.76), left ear should be slightly quieter because sound is behind it
            let leftDirectionalAtten = 1.0;
            let rightDirectionalAtten = 1.0;

            if (isBehind) {
                // When behind, attenuate the ear that's on the same side as the sound
                // because that ear is "facing away" from the sound source
                if (panPosition < 0) {
                    // Sound is back-left: left ear faces away, gets extra attenuation
                    leftDirectionalAtten = 1.0 - (directionalDepth * Math.abs(panPosition) * behindAmount);
                } else if (panPosition > 0) {
                    // Sound is back-right: right ear faces away, gets extra attenuation
                    rightDirectionalAtten = 1.0 - (directionalDepth * Math.abs(panPosition) * behindAmount);
                }
            }

            // Calculate gain values (what the audio engine should use)
            const leftGain = Math.max(0, (1 - panPosition) * 0.5 * baseDepthMultiplier * leftDirectionalAtten);
            const rightGain = Math.max(0, (1 + panPosition) * 0.5 * baseDepthMultiplier * rightDirectionalAtten);

            // Hard pan calculation with adjustable curve and threshold
            let hardLeftGain, hardRightGain, actualCrossBleed;
            if (panPosition > hardPanThreshold) {
                // Sound is on the right
                const rightAmount = Math.min(1, (panPosition - hardPanThreshold) / (1 - hardPanThreshold));
                const curved = Math.pow(rightAmount, 1 / panCurve); // Apply pan curve
                hardLeftGain = Math.max(0, 1 - curved);
                hardRightGain = 1;
                actualCrossBleed = crossBleed * (1 - curved);
            } else if (panPosition < -hardPanThreshold) {
                // Sound is on the left
                const leftAmount = Math.min(1, (-panPosition - hardPanThreshold) / (1 - hardPanThreshold));
                const curved = Math.pow(leftAmount, 1 / panCurve);
                hardLeftGain = 1;
                hardRightGain = Math.max(0, 1 - curved);
                actualCrossBleed = crossBleed * (1 - curved);
            } else {
                // Center zone
                hardLeftGain = 0.5;
                hardRightGain = 0.5;
                actualCrossBleed = crossBleed;
            }
            // Apply depth and directional attenuation
            hardLeftGain *= baseDepthMultiplier * leftDirectionalAtten;
            hardRightGain *= baseDepthMultiplier * rightDirectionalAtten;

            // Calculate ITD (Inter-aural Time Difference)
            // Sound reaches closer ear first. Max ITD ~0.7ms when sound is directly to one side
            // Negative pan = sound on left = delay right ear
            // Positive pan = sound on right = delay left ear
            const maxItdMs = 0.7 * itdAmount; // ms
            const itdLeftDelay = panPosition > 0 ? Math.abs(panPosition) * maxItdMs / 1000 : 0; // seconds
            const itdRightDelay = panPosition < 0 ? Math.abs(panPosition) * maxItdMs / 1000 : 0; // seconds

            // Calculate low-pass filter frequencies for "head shadow" effect
            // When sound is behind or on opposite side, high frequencies are blocked
            // Full open = 20000Hz, max muffled = 2000Hz
            const minFreq = 2000; // Muffled sound
            const maxFreq = 20000; // Clear sound

            // Left ear filter: darker when sound is on the RIGHT or BEHIND-LEFT
            // Right ear filter: darker when sound is on the LEFT or BEHIND-RIGHT
            let leftFilterFreq = maxFreq;
            let rightFilterFreq = maxFreq;

            if (headShadow > 0) {
                // Head shadow from opposite side (sound on right = left ear darker)
                const leftShadowFromPan = panPosition > 0 ? panPosition : 0; // 0-1 when sound on right
                const rightShadowFromPan = panPosition < 0 ? -panPosition : 0; // 0-1 when sound on left

                // Additional shadow when behind
                const behindShadow = isBehind ? behindAmount * 0.5 : 0;

                const leftShadowAmount = Math.min(1, (leftShadowFromPan + behindShadow) * headShadow);
                const rightShadowAmount = Math.min(1, (rightShadowFromPan + behindShadow) * headShadow);

                // Exponential mapping for more natural rolloff
                leftFilterFreq = maxFreq * Math.pow(minFreq / maxFreq, leftShadowAmount);
                rightFilterFreq = maxFreq * Math.pow(minFreq / maxFreq, rightShadowAmount);
            }

            // Apply gains to audio whenever orb position or settings change
            React.useEffect(() => {
                // SKIP when calibration timing test is active - those tests set ITD directly
                if (calibrationTimingActive) {
                    console.log('[SpatialTuner useEffect] Skipping - calibration timing test active');
                    return;
                }
                if (isOpen && onApplyGains) {
                    // During calibration wizard, use HARD PANNING (no cross-bleed) for accurate L/R testing
                    const calibrationCrossBleed = showCalibration ? 0.0001 : Math.max(0.001, actualCrossBleed);
                    // Use hard pan values with cross bleed, ITD, and filter frequencies
                    // 8th param: forceHardPan (mutes parallel cross-delay paths during calibration)
                    onApplyGains(hardLeftGain, hardRightGain, calibrationCrossBleed, itdLeftDelay, itdRightDelay, leftFilterFreq, rightFilterFreq, showCalibration);
                }
            }, [orbPosition, isOpen, onApplyGains, hardLeftGain, hardRightGain, actualCrossBleed, itdLeftDelay, itdRightDelay, leftFilterFreq, rightFilterFreq, crossBleed, backDepth, panCurve, hardPanThreshold, itdAmount, directionalDepth, headShadow, calibrationTimingActive, showCalibration]);

            // Apply EQ whenever values change
            React.useEffect(() => {
                if (isOpen && onApplyEQ) {
                    onApplyEQ(eqBass, eqMid, eqTreble, eqClarity);
                }
            }, [isOpen, onApplyEQ, eqBass, eqMid, eqTreble, eqClarity]);

            const handleMouseDown = (e) => {
                setIsDragging(true);
                updateOrbPosition(e);
            };

            const handleMouseMove = (e) => {
                if (!isDragging) return;
                updateOrbPosition(e);
            };

            const handleMouseUp = () => {
                setIsDragging(false);
            };

            const updateOrbPosition = (e) => {
                if (!containerRef.current) return;
                const rect = containerRef.current.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;

                let x = e.clientX - rect.left - centerX;
                let y = e.clientY - rect.top - centerY;

                // Constrain to circle
                const dist = Math.sqrt(x * x + y * y);
                if (dist > radius) {
                    x = (x / dist) * radius;
                    y = (y / dist) * radius;
                }

                setOrbPosition({ x, y });
            };

            const getPositionLabel = () => {
                if (normalizedAngle >= 315 || normalizedAngle < 45) return 'FRONT';
                if (normalizedAngle >= 45 && normalizedAngle < 135) return 'RIGHT';
                if (normalizedAngle >= 135 && normalizedAngle < 225) return 'BACK';
                return 'LEFT';
            };

            if (!isOpen) return null;

            return (
                <div style={{
                    position: 'fixed',
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    background: 'rgba(0,0,0,0.85)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    zIndex: 10000
                }} onClick={onClose}>
                    <div style={{
                        background: 'var(--bg-2)',
                        borderRadius: '16px',
                        maxWidth: '500px',
                        width: '95%',
                        maxHeight: '85vh',
                        display: 'flex',
                        flexDirection: 'column',
                        overflow: 'hidden'
                    }} onClick={e => e.stopPropagation()}>
                        {/* Fixed Header */}
                        <div style={{
                            padding: '12px 16px',
                            borderBottom: '1px solid var(--border)',
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center',
                            flexShrink: 0
                        }}>
                            <h3 style={{ margin: 0, color: 'var(--accent)', fontSize: '1rem' }}>Audio Settings</h3>
                            <button
                                onClick={onClose}
                                style={{
                                    background: 'transparent',
                                    border: 'none',
                                    color: 'var(--text-secondary)',
                                    fontSize: '1.5rem',
                                    cursor: 'pointer',
                                    padding: '0 4px',
                                    lineHeight: 1
                                }}
                            >×</button>
                        </div>

                        {/* Scrollable Content */}
                        <div style={{
                            flex: 1,
                            overflowY: 'auto',
                            padding: '12px',
                            minHeight: 0
                        }}>

                        {/* Volume Recommendation Panel */}
                        {(() => {
                            const volumePercent = Math.round(currentVolume * 100);
                            const isOptimal = volumePercent >= 40 && volumePercent <= 60;
                            const isTooLoud = volumePercent > 75;
                            const isTooQuiet = volumePercent < 25;
                            const statusColor = isOptimal ? '#4ade80' : (isTooLoud ? '#f87171' : (isTooQuiet ? '#fbbf24' : '#fbbf24'));
                            const statusText = isOptimal ? '✓ Optimal for spatial perception' :
                                              (isTooLoud ? '⚠ Too loud - spatial cues may be drowned out' :
                                              (isTooQuiet ? '⚠ Too quiet - may miss subtle effects' : '~ Adjust for best spatial effect'));

                            return (
                                <div style={{
                                    background: 'rgba(0,0,0,0.4)',
                                    borderRadius: '8px',
                                    padding: '12px',
                                    marginBottom: '16px',
                                    border: `1px solid ${statusColor}40`
                                }}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '8px' }}>
                                        <span style={{ fontSize: '1.2rem' }}>🔊</span>
                                        <span style={{ fontWeight: 'bold', color: 'var(--text-primary)', fontSize: '0.875rem' }}>
                                            Volume: {volumePercent}%
                                        </span>
                                        <span style={{
                                            fontSize: '0.75rem',
                                            color: statusColor,
                                            marginLeft: 'auto'
                                        }}>
                                            {statusText}
                                        </span>
                                    </div>

                                    {onVolumeChange && (
                                        <div>
                                            <input
                                                type="range"
                                                min="0"
                                                max="1"
                                                step="0.01"
                                                value={currentVolume}
                                                onChange={(e) => onVolumeChange(parseFloat(e.target.value))}
                                                style={{
                                                    width: '100%',
                                                    accentColor: statusColor,
                                                    height: '8px'
                                                }}
                                            />
                                            <div style={{
                                                display: 'flex',
                                                justifyContent: 'space-between',
                                                fontSize: '0.65rem',
                                                color: 'var(--text-secondary)',
                                                marginTop: '4px'
                                            }}>
                                                <span>Too Quiet</span>
                                                <span style={{ color: '#4ade80' }}>▲ Sweet Spot (40-60%)</span>
                                                <span>Too Loud</span>
                                            </div>
                                        </div>
                                    )}

                                    <div style={{
                                        fontSize: '0.7rem',
                                        color: 'var(--text-secondary)',
                                        marginTop: '8px',
                                        padding: '6px',
                                        background: 'rgba(255,255,255,0.05)',
                                        borderRadius: '4px'
                                    }}>
                                        💡 <strong>Tip:</strong> Research shows 73-85 dB SPL is optimal for spatial perception.
                                        At high volumes, spatial cues get "drowned out". Try 40-60% for best results.
                                    </div>
                                </div>
                            );
                        })()}

                        {/* Quick Calibration Button */}
                        {!showCalibration && (
                            <button
                                onClick={() => {
                                    resetToDefaults(); // Start fresh
                                    setCalibrationDelayMs(10);
                                    setCalibrationResults({
                                        canHearLeftRight: null,
                                        leftRightIntensity: 2.0,
                                        canHearFrontBack: null,
                                        frontBackIntensity: 0.5,
                                        canHearTimingLeft: null,
                                        canHearTimingRight: null,
                                        timingThresholdLeft: null,
                                        timingThresholdRight: null,
                                        preferredVolume: 0.5
                                    });
                                    setShowCalibration(true);
                                    setCalibrationStep(0);
                                }}
                                style={{
                                    width: '100%',
                                    padding: '12px',
                                    marginBottom: '16px',
                                    background: 'linear-gradient(135deg, #8b5cf6, #6366f1)',
                                    color: 'white',
                                    border: 'none',
                                    borderRadius: '8px',
                                    cursor: 'pointer',
                                    fontWeight: '600',
                                    fontSize: '0.9rem',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    gap: '8px'
                                }}
                            >
                                🧠 Quick Brain Calibration (APD-Friendly)
                            </button>
                        )}

                        {/* Calibration Wizard */}
                        {showCalibration && (
                            <div style={{
                                background: 'rgba(139, 92, 246, 0.1)',
                                border: '2px solid #8b5cf6',
                                borderRadius: '12px',
                                padding: '16px',
                                marginBottom: '16px'
                            }}>
                                {calibrationStep === 0 && (
                                    <div>
                                        <h4 style={{ margin: '0 0 12px', color: '#a78bfa' }}>🧠 Brain Calibration Wizard</h4>
                                        <p style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', marginBottom: '12px' }}>
                                            This wizard will help find the spatial audio settings that work best for YOUR brain.
                                            We'll test different types of spatial cues and adjust based on what you can perceive.
                                        </p>
                                        <div style={{ background: 'rgba(0,0,0,0.3)', padding: '12px', borderRadius: '8px', marginBottom: '12px' }}>
                                            <p style={{ fontSize: '0.8rem', color: '#fbbf24', margin: '0 0 8px' }}>
                                                <strong>For Auditory Processing Differences:</strong>
                                            </p>
                                            <ul style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', margin: 0, paddingLeft: '20px' }}>
                                                <li>Timing cues (ITD) may be harder to perceive - we'll test this</li>
                                                <li>Frequency changes (muffling) are often easier to notice</li>
                                                <li>We can boost effects that work best for you</li>
                                            </ul>
                                        </div>
                                        <p style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginBottom: '16px' }}>
                                            <strong>Requirements:</strong> Music playing + headphones on
                                        </p>
                                        <div style={{ display: 'flex', gap: '8px' }}>
                                            <button
                                                onClick={() => setCalibrationStep(1)}
                                                style={{
                                                    flex: 1,
                                                    padding: '10px',
                                                    background: '#8b5cf6',
                                                    color: 'white',
                                                    border: 'none',
                                                    borderRadius: '6px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600'
                                                }}
                                            >
                                                Start Calibration →
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setCalibrationTimingActive(false);
                                                    setShowCalibration(false);
                                                }}
                                                style={{
                                                    padding: '10px 16px',
                                                    background: 'transparent',
                                                    color: 'var(--text-secondary)',
                                                    border: '1px solid var(--text-secondary)',
                                                    borderRadius: '6px',
                                                    cursor: 'pointer'
                                                }}
                                            >
                                                Cancel
                                            </button>
                                        </div>
                                    </div>
                                )}

                                {calibrationStep === 1 && (
                                    <div>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                                            <h4 style={{ margin: 0, color: '#a78bfa' }}>Step 1: Left/Right Test</h4>
                                            <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)' }}>1 of 5</span>
                                        </div>
                                        <p style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', marginBottom: '12px' }}>
                                            I'll move the sound to the <strong>LEFT</strong> then <strong>RIGHT</strong>.
                                            Listen carefully - can you tell the difference?
                                        </p>

                                        {/* Test buttons to move sound */}
                                        <div style={{ display: 'flex', gap: '8px', marginBottom: '16px' }}>
                                            <button
                                                onClick={() => {
                                                    setOrbPosition({ x: -80, y: 0 });
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '16px',
                                                    background: 'rgba(59, 130, 246, 0.2)',
                                                    color: '#60a5fa',
                                                    border: '2px solid #60a5fa',
                                                    borderRadius: '8px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600',
                                                    fontSize: '1.1rem'
                                                }}
                                            >
                                                👈 LEFT
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setOrbPosition({ x: 80, y: 0 });
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '16px',
                                                    background: 'rgba(34, 197, 94, 0.2)',
                                                    color: '#4ade80',
                                                    border: '2px solid #4ade80',
                                                    borderRadius: '8px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600',
                                                    fontSize: '1.1rem'
                                                }}
                                            >
                                                RIGHT 👉
                                            </button>
                                        </div>

                                        <p style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginBottom: '8px' }}>
                                            <strong>Can you clearly hear the difference between LEFT and RIGHT?</strong>
                                        </p>
                                        <div style={{ display: 'flex', gap: '8px', marginBottom: '8px' }}>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearLeftRight: 'clear', leftRightIntensity: 2.0 }));
                                                    resetToDefaults(); // Reset for next test
                                                    setCalibrationStep(2);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#4ade80', color: 'black', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                Yes, clearly! ✓
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearLeftRight: 'subtle', leftRightIntensity: 3.0 }));
                                                    resetToDefaults(); // Reset for next test
                                                    setCalibrationStep(2);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#fbbf24', color: 'black', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                Barely / Subtle
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearLeftRight: 'no', leftRightIntensity: 4.0 }));
                                                    resetToDefaults(); // Reset for next test
                                                    setCalibrationStep(2);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#f87171', color: 'white', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                No / Can't tell ✗
                                            </button>
                                        </div>
                                    </div>
                                )}

                                {calibrationStep === 2 && (
                                    <div>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                                            <h4 style={{ margin: 0, color: '#a78bfa' }}>Step 2: Front/Back Test (Muffling)</h4>
                                            <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)' }}>2 of 5</span>
                                        </div>
                                        <p style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', marginBottom: '12px' }}>
                                            I'll move the sound to the <strong>FRONT</strong> (bright/clear) then <strong>BACK</strong> (muffled/darker).
                                            This tests if you can hear the tone change.
                                        </p>

                                        <div style={{ display: 'flex', gap: '8px', marginBottom: '16px' }}>
                                            <button
                                                onClick={() => {
                                                    setOrbPosition({ x: 0, y: -80 });
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '16px',
                                                    background: 'rgba(251, 191, 36, 0.2)',
                                                    color: '#fbbf24',
                                                    border: '2px solid #fbbf24',
                                                    borderRadius: '8px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600',
                                                    fontSize: '1rem'
                                                }}
                                            >
                                                🔆 FRONT (Clear)
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setOrbPosition({ x: 0, y: 80 });
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '16px',
                                                    background: 'rgba(107, 114, 128, 0.3)',
                                                    color: '#9ca3af',
                                                    border: '2px solid #6b7280',
                                                    borderRadius: '8px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600',
                                                    fontSize: '1rem'
                                                }}
                                            >
                                                🔅 BACK (Muffled)
                                            </button>
                                        </div>

                                        <p style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginBottom: '8px' }}>
                                            <strong>Can you hear the muffling/darkening when sound moves to BACK?</strong>
                                        </p>
                                        <div style={{ display: 'flex', gap: '8px' }}>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearFrontBack: 'clear', frontBackIntensity: 0.5 }));
                                                    resetToDefaults(); // Reset for timing test
                                                    setCalibrationDelayMs(10); // Start timing test at 10ms
                                                    setCalibrationTimingActive(true); // Prevent useEffect from overwriting ITD
                                                    setCalibrationStep(3);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#4ade80', color: 'black', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                Yes, clearly! ✓
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearFrontBack: 'subtle', frontBackIntensity: 0.8 }));
                                                    resetToDefaults(); // Reset for timing test
                                                    setCalibrationDelayMs(10);
                                                    setCalibrationTimingActive(true); // Prevent useEffect from overwriting ITD
                                                    setCalibrationStep(3);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#fbbf24', color: 'black', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                Barely / Subtle
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearFrontBack: 'no', frontBackIntensity: 1.0 }));
                                                    resetToDefaults(); // Reset for timing test
                                                    setCalibrationDelayMs(10);
                                                    setCalibrationTimingActive(true); // Prevent useEffect from overwriting ITD
                                                    setCalibrationStep(3);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#f87171', color: 'white', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                No / Can't tell ✗
                                            </button>
                                        </div>
                                    </div>
                                )}

                                {calibrationStep === 3 && (
                                    <div>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                                            <h4 style={{ margin: 0, color: '#a78bfa' }}>Step 3a: Left Ear Timing</h4>
                                            <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)' }}>3 of 5</span>
                                        </div>
                                        <p style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', marginBottom: '8px' }}>
                                            Sound arrives at your <strong style={{ color: '#60a5fa' }}>LEFT ear</strong> before your right.
                                            <strong style={{ color: '#fbbf24' }}> Adjust the delay until you can hear it!</strong>
                                        </p>
                                        <p style={{ fontSize: '0.75rem', color: '#6b7280', marginBottom: '12px', fontStyle: 'italic' }}>
                                            Tip: Keep volume at 40-60%. Normal ITD is ~0.7ms, but some people need more.
                                        </p>

                                        {/* Delay slider */}
                                        <div style={{ background: 'rgba(0,0,0,0.3)', padding: '12px', borderRadius: '8px', marginBottom: '12px' }}>
                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                                                <span style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>Delay Amount:</span>
                                                <span style={{ fontSize: '1rem', fontWeight: '700', color: '#60a5fa' }}>{calibrationDelayMs} ms</span>
                                            </div>
                                            <input
                                                type="range"
                                                min="0"
                                                max="200"
                                                step="5"
                                                value={calibrationDelayMs}
                                                onChange={(e) => setCalibrationDelayMs(Number(e.target.value))}
                                                style={{ width: '100%', accentColor: '#60a5fa' }}
                                            />
                                            <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.7rem', color: 'var(--text-secondary)' }}>
                                                <span>0ms</span>
                                                <span>Normal: ~0.7ms</span>
                                                <span>200ms</span>
                                            </div>
                                            {/* Quick adjust buttons */}
                                            <div style={{ display: 'flex', gap: '4px', marginTop: '8px', flexWrap: 'wrap' }}>
                                                <button onClick={() => setCalibrationDelayMs(10)} style={{ padding: '6px 10px', background: 'rgba(139,92,246,0.2)', color: '#a78bfa', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem' }}>10ms</button>
                                                <button onClick={() => setCalibrationDelayMs(25)} style={{ padding: '6px 10px', background: 'rgba(139,92,246,0.2)', color: '#a78bfa', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem' }}>25ms</button>
                                                <button onClick={() => setCalibrationDelayMs(50)} style={{ padding: '6px 10px', background: 'rgba(139,92,246,0.2)', color: '#a78bfa', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem' }}>50ms</button>
                                                <button onClick={() => setCalibrationDelayMs(100)} style={{ padding: '6px 10px', background: 'rgba(139,92,246,0.3)', color: '#a78bfa', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem' }}>100ms</button>
                                                <button onClick={() => setCalibrationDelayMs(150)} style={{ padding: '6px 10px', background: 'rgba(139,92,246,0.3)', color: '#a78bfa', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem' }}>150ms</button>
                                                <button onClick={() => setCalibrationDelayMs(200)} style={{ padding: '6px 10px', background: 'rgba(139,92,246,0.4)', color: '#a78bfa', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem' }}>200ms</button>
                                            </div>
                                        </div>

                                        <div style={{ display: 'flex', gap: '8px', marginBottom: '16px' }}>
                                            <button
                                                onClick={() => {
                                                    // Apply delay: left ear gets sound first (delay right ear)
                                                    // EQUAL VOLUME: same gain for both + high crossbleed for mono mix
                                                    const delaySeconds = calibrationDelayMs / 1000;
                                                    console.log(`[Calibration] LEFT FIRST: Delaying RIGHT ear by ${calibrationDelayMs}ms (${delaySeconds}s)`);
                                                    setHeadShadow(0);
                                                    setDirectionalDepth(0);
                                                    setCrossBleed(0.5); // High crossbleed = mono mix (equal in both ears)
                                                    setPanCurve(1.0); // Minimal pan separation
                                                    setOrbPosition({ x: 0, y: 0 }); // Center position
                                                    // Equal gains (0.5 each) + 0.5 crossbleed = mono mix to both ears
                                                    // Only difference: right ear delayed (itdRightDelay = delaySeconds)
                                                    onApplyGains(0.5, 0.5, 0.5, 0, delaySeconds, 20000, 20000);
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '12px',
                                                    background: 'rgba(96, 165, 250, 0.3)',
                                                    color: '#60a5fa',
                                                    border: '2px solid #3b82f6',
                                                    borderRadius: '8px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600'
                                                }}
                                            >
                                                ◀ Left First ({calibrationDelayMs}ms)
                                            </button>
                                            <button
                                                onClick={() => {
                                                    // No delay - SAME volume in both ears (mono mix)
                                                    console.log('[Calibration] NO DELAY: Both ears get sound at same time');
                                                    setHeadShadow(0);
                                                    setDirectionalDepth(0);
                                                    setCrossBleed(0.5); // High cross-bleed = mono mix
                                                    setPanCurve(1.0);
                                                    setOrbPosition({ x: 0, y: 0 });
                                                    onApplyGains(0.5, 0.5, 0.5, 0, 0, 20000, 20000);
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '12px',
                                                    background: 'rgba(107, 114, 128, 0.3)',
                                                    color: '#9ca3af',
                                                    border: '2px solid #6b7280',
                                                    borderRadius: '8px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600'
                                                }}
                                            >
                                                No Delay (Compare)
                                            </button>
                                        </div>

                                        <p style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginBottom: '8px' }}>
                                            <strong>Can you hear a difference when toggling?</strong> If not, increase the delay.
                                        </p>
                                        <div style={{ display: 'flex', gap: '8px' }}>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearTimingLeft: 'yes', timingThresholdLeft: calibrationDelayMs }));
                                                    resetToDefaults(); // Reset for right ear test
                                                    setCalibrationDelayMs(10); // Reset delay slider for right ear test
                                                    setCalibrationStep(4);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#4ade80', color: 'black', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                Yes! I hear it at {calibrationDelayMs}ms ✓
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearTimingLeft: 'no', timingThresholdLeft: null }));
                                                    resetToDefaults(); // Reset for right ear test
                                                    setCalibrationDelayMs(10);
                                                    setCalibrationStep(4);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#f87171', color: 'white', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                Can't hear it ✗
                                            </button>
                                        </div>
                                    </div>
                                )}

                                {calibrationStep === 4 && (
                                    <div>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                                            <h4 style={{ margin: 0, color: '#a78bfa' }}>Step 3b: Right Ear Timing</h4>
                                            <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)' }}>4 of 5</span>
                                        </div>
                                        <p style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', marginBottom: '8px' }}>
                                            Now sound arrives at your <strong style={{ color: '#f472b6' }}>RIGHT ear</strong> before your left.
                                            <strong style={{ color: '#fbbf24' }}> Same thing - find your threshold!</strong>
                                        </p>
                                        <p style={{ fontSize: '0.75rem', color: '#6b7280', marginBottom: '12px', fontStyle: 'italic' }}>
                                            {calibrationResults.timingThresholdLeft ? `Left ear threshold was ${calibrationResults.timingThresholdLeft}ms - might be similar!` : 'Some people perceive timing better in one ear than the other.'}
                                        </p>

                                        {/* Delay slider */}
                                        <div style={{ background: 'rgba(0,0,0,0.3)', padding: '12px', borderRadius: '8px', marginBottom: '12px' }}>
                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                                                <span style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>Delay Amount:</span>
                                                <span style={{ fontSize: '1rem', fontWeight: '700', color: '#f472b6' }}>{calibrationDelayMs} ms</span>
                                            </div>
                                            <input
                                                type="range"
                                                min="0"
                                                max="200"
                                                step="5"
                                                value={calibrationDelayMs}
                                                onChange={(e) => setCalibrationDelayMs(Number(e.target.value))}
                                                style={{ width: '100%', accentColor: '#f472b6' }}
                                            />
                                            <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.7rem', color: 'var(--text-secondary)' }}>
                                                <span>0ms</span>
                                                <span>Normal: ~0.7ms</span>
                                                <span>200ms</span>
                                            </div>
                                            {/* Quick adjust buttons */}
                                            <div style={{ display: 'flex', gap: '4px', marginTop: '8px', flexWrap: 'wrap' }}>
                                                <button onClick={() => setCalibrationDelayMs(10)} style={{ padding: '6px 10px', background: 'rgba(244,114,182,0.2)', color: '#f472b6', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem' }}>10ms</button>
                                                <button onClick={() => setCalibrationDelayMs(25)} style={{ padding: '6px 10px', background: 'rgba(244,114,182,0.2)', color: '#f472b6', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem' }}>25ms</button>
                                                <button onClick={() => setCalibrationDelayMs(50)} style={{ padding: '6px 10px', background: 'rgba(244,114,182,0.2)', color: '#f472b6', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem' }}>50ms</button>
                                                <button onClick={() => setCalibrationDelayMs(100)} style={{ padding: '6px 10px', background: 'rgba(244,114,182,0.3)', color: '#f472b6', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem' }}>100ms</button>
                                                <button onClick={() => setCalibrationDelayMs(150)} style={{ padding: '6px 10px', background: 'rgba(244,114,182,0.3)', color: '#f472b6', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem' }}>150ms</button>
                                                <button onClick={() => setCalibrationDelayMs(200)} style={{ padding: '6px 10px', background: 'rgba(244,114,182,0.4)', color: '#f472b6', border: 'none', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem' }}>200ms</button>
                                            </div>
                                        </div>

                                        <div style={{ display: 'flex', gap: '8px', marginBottom: '16px' }}>
                                            <button
                                                onClick={() => {
                                                    // Apply delay: right ear gets sound first (delay left ear)
                                                    // EQUAL VOLUME: same gain for both + high cross-bleed for mono mix
                                                    setHeadShadow(0);
                                                    setDirectionalDepth(0);
                                                    setCrossBleed(0.5); // High cross-bleed = mono mix (equal in both ears)
                                                    setPanCurve(1.0); // Minimal pan separation
                                                    setOrbPosition({ x: 0, y: 0 }); // Center position
                                                    // Equal gains + 0.5 cross-bleed = mono mix to both ears
                                                    // Only difference: left ear delayed
                                                    const delaySeconds = calibrationDelayMs / 1000;
                                                    onApplyGains(0.5, 0.5, 0.5, delaySeconds, 0, 20000, 20000);
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '12px',
                                                    background: 'rgba(244, 114, 182, 0.3)',
                                                    color: '#f472b6',
                                                    border: '2px solid #ec4899',
                                                    borderRadius: '8px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600'
                                                }}
                                            >
                                                Right First ({calibrationDelayMs}ms) ▶
                                            </button>
                                            <button
                                                onClick={() => {
                                                    // No delay - SAME volume in both ears (mono mix)
                                                    setHeadShadow(0);
                                                    setDirectionalDepth(0);
                                                    setCrossBleed(0.5); // High cross-bleed = mono mix
                                                    setPanCurve(1.0);
                                                    setOrbPosition({ x: 0, y: 0 });
                                                    onApplyGains(0.5, 0.5, 0.5, 0, 0, 20000, 20000);
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '12px',
                                                    background: 'rgba(107, 114, 128, 0.3)',
                                                    color: '#9ca3af',
                                                    border: '2px solid #6b7280',
                                                    borderRadius: '8px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600'
                                                }}
                                            >
                                                No Delay (Compare)
                                            </button>
                                        </div>

                                        <p style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginBottom: '8px' }}>
                                            <strong>Can you hear a difference when toggling?</strong> If not, increase the delay.
                                        </p>
                                        <div style={{ display: 'flex', gap: '8px' }}>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearTimingRight: 'yes', timingThresholdRight: calibrationDelayMs }));
                                                    setCalibrationTimingActive(false); // Re-enable normal spatial processing
                                                    resetToDefaults(); // Reset for results display
                                                    setCalibrationStep(5);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#4ade80', color: 'black', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                Yes! I hear it at {calibrationDelayMs}ms ✓
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearTimingRight: 'no', timingThresholdRight: null }));
                                                    setCalibrationTimingActive(false); // Re-enable normal spatial processing
                                                    resetToDefaults(); // Reset for results display
                                                    setCalibrationStep(5);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#f87171', color: 'white', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                Can't hear it ✗
                                            </button>
                                        </div>
                                    </div>
                                )}

                                {calibrationStep === 5 && (
                                    <div>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                                            <h4 style={{ margin: 0, color: '#4ade80' }}>✓ Calibration Complete!</h4>
                                            <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)' }}>5 of 5</span>
                                        </div>

                                        <div style={{ background: 'rgba(0,0,0,0.3)', padding: '12px', borderRadius: '8px', marginBottom: '16px' }}>
                                            <p style={{ fontSize: '0.85rem', color: 'var(--text-primary)', margin: '0 0 12px', fontWeight: '600' }}>
                                                Your Personalized Profile:
                                            </p>
                                            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px', fontSize: '0.8rem' }}>
                                                <div>
                                                    <span style={{ color: 'var(--text-secondary)' }}>Left/Right:</span>
                                                    <span style={{ marginLeft: '8px', color: calibrationResults.canHearLeftRight === 'clear' ? '#4ade80' : (calibrationResults.canHearLeftRight === 'subtle' ? '#fbbf24' : '#f87171') }}>
                                                        {calibrationResults.canHearLeftRight === 'clear' ? 'Clear ✓' : (calibrationResults.canHearLeftRight === 'subtle' ? 'Boosted' : 'Max Boost')}
                                                    </span>
                                                </div>
                                                <div>
                                                    <span style={{ color: 'var(--text-secondary)' }}>Front/Back:</span>
                                                    <span style={{ marginLeft: '8px', color: calibrationResults.canHearFrontBack === 'clear' ? '#4ade80' : (calibrationResults.canHearFrontBack === 'subtle' ? '#fbbf24' : '#f87171') }}>
                                                        {calibrationResults.canHearFrontBack === 'clear' ? 'Clear ✓' : (calibrationResults.canHearFrontBack === 'subtle' ? 'Boosted' : 'Max Boost')}
                                                    </span>
                                                </div>
                                                <div>
                                                    <span style={{ color: 'var(--text-secondary)' }}>Timing Left:</span>
                                                    <span style={{ marginLeft: '8px', color: calibrationResults.canHearTimingLeft === 'yes' ? '#4ade80' : '#6b7280' }}>
                                                        {calibrationResults.canHearTimingLeft === 'yes'
                                                            ? `✓ ${calibrationResults.timingThresholdLeft}ms`
                                                            : '✗ Not detected'}
                                                    </span>
                                                </div>
                                                <div>
                                                    <span style={{ color: 'var(--text-secondary)' }}>Timing Right:</span>
                                                    <span style={{ marginLeft: '8px', color: calibrationResults.canHearTimingRight === 'yes' ? '#4ade80' : '#6b7280' }}>
                                                        {calibrationResults.canHearTimingRight === 'yes'
                                                            ? `✓ ${calibrationResults.timingThresholdRight}ms`
                                                            : '✗ Not detected'}
                                                    </span>
                                                </div>
                                                <div style={{ gridColumn: '1 / -1' }}>
                                                    <span style={{ color: 'var(--text-secondary)' }}>Strategy:</span>
                                                    <span style={{ marginLeft: '8px', color: '#a78bfa' }}>
                                                        {calibrationResults.canHearTimingLeft === 'no' && calibrationResults.canHearTimingRight === 'no'
                                                            ? 'Volume + Tone (No ITD)'
                                                            : calibrationResults.canHearTimingLeft !== calibrationResults.canHearTimingRight
                                                                ? 'Partial ITD (one ear stronger)'
                                                                : 'Full Spatial'}
                                                    </span>
                                                </div>
                                            </div>
                                        </div>

                                        {calibrationResults.canHearTimingLeft === 'no' && calibrationResults.canHearTimingRight === 'no' && (
                                            <div style={{ background: 'rgba(251, 191, 36, 0.1)', padding: '10px', borderRadius: '6px', marginBottom: '12px', fontSize: '0.8rem', color: '#fbbf24' }}>
                                                💡 <strong>APD-Optimized:</strong> Since timing cues are harder for you, we're using
                                                <strong> volume differences</strong> and <strong>tone changes</strong> (muffling) as your primary spatial cues.
                                                These are processed differently by the brain and often work better!
                                            </div>
                                        )}

                                        {calibrationResults.canHearTimingLeft !== calibrationResults.canHearTimingRight && (
                                            <div style={{ background: 'rgba(139, 92, 246, 0.1)', padding: '10px', borderRadius: '6px', marginBottom: '12px', fontSize: '0.8rem', color: '#a78bfa' }}>
                                                💡 <strong>Asymmetric Timing:</strong> You perceive timing better in your
                                                <strong> {calibrationResults.canHearTimingLeft === 'yes' ? 'left' : 'right'} ear</strong>.
                                                This is common! ITD is enabled with this preference in mind.
                                            </div>
                                        )}

                                        {/* Show thresholds found */}
                                        {(calibrationResults.timingThresholdLeft || calibrationResults.timingThresholdRight) && (
                                            <div style={{ background: 'rgba(74, 222, 128, 0.1)', padding: '10px', borderRadius: '6px', marginBottom: '12px', fontSize: '0.8rem', color: '#4ade80' }}>
                                                🎯 <strong>Your Timing Thresholds:</strong>
                                                {calibrationResults.timingThresholdLeft && <span> Left: {calibrationResults.timingThresholdLeft}ms</span>}
                                                {calibrationResults.timingThresholdLeft && calibrationResults.timingThresholdRight && <span> |</span>}
                                                {calibrationResults.timingThresholdRight && <span> Right: {calibrationResults.timingThresholdRight}ms</span>}
                                                <br />
                                                <span style={{ fontSize: '0.7rem', color: 'var(--text-secondary)' }}>
                                                    (Normal hearing is ~0.7ms. Higher = needs more delay to perceive)
                                                </span>
                                            </div>
                                        )}

                                        <div style={{ display: 'flex', gap: '8px' }}>
                                            <button
                                                onClick={() => {
                                                    // Apply final settings based on results
                                                    let finalItdAmount = 0.7; // Default
                                                    const canHearAnyTiming = calibrationResults.canHearTimingLeft === 'yes' || calibrationResults.canHearTimingRight === 'yes';
                                                    if (!canHearAnyTiming) {
                                                        finalItdAmount = 0;
                                                        setItdAmount(0);
                                                    } else {
                                                        // Use their personal threshold to calculate ITD multiplier
                                                        // Normal ITD is 0.7ms, so multiplier = threshold / 0.7
                                                        const leftThreshold = calibrationResults.timingThresholdLeft || 50;
                                                        const rightThreshold = calibrationResults.timingThresholdRight || 50;
                                                        const avgThreshold = (leftThreshold + rightThreshold) / 2;
                                                        // Calculate multiplier: their threshold / normal (0.7ms)
                                                        // Cap at 70 (which gives ~50ms max delay)
                                                        const multiplier = Math.min(70, avgThreshold / 0.7);
                                                        finalItdAmount = multiplier;
                                                        setItdAmount(multiplier);
                                                        console.log(`[Calibration] Set ITD multiplier to ${multiplier.toFixed(1)} (threshold: ${avgThreshold}ms)`);
                                                    }
                                                    // Restore other settings
                                                    const finalHeadShadow = calibrationResults.frontBackIntensity || 0.5;
                                                    const finalPanCurve = calibrationResults.leftRightIntensity || 2.0;
                                                    setHeadShadow(finalHeadShadow);
                                                    setPanCurve(finalPanCurve);
                                                    setDirectionalDepth(0.15);
                                                    setCrossBleed(0);

                                                    // SAVE calibration to localStorage for persistence
                                                    const calibrationData = {
                                                        itdAmount: finalItdAmount,
                                                        headShadow: finalHeadShadow,
                                                        panCurve: finalPanCurve,
                                                        directionalDepth: 0.15,
                                                        crossBleed: 0,
                                                        backDepth: 0.55,
                                                        hardPanThreshold: 0.1,
                                                        // EQ settings
                                                        eq: {
                                                            bass: eqBass,
                                                            mid: eqMid,
                                                            treble: eqTreble,
                                                            clarity: eqClarity
                                                        },
                                                        results: calibrationResults,
                                                        savedAt: Date.now()
                                                    };
                                                    try {
                                                        localStorage.setItem('mpe_8d_calibration', JSON.stringify(calibrationData));
                                                        console.log('[Calibration] Saved to localStorage:', calibrationData);
                                                        // Notify parent that calibration is complete
                                                        if (onCalibrationComplete) {
                                                            onCalibrationComplete();
                                                        }
                                                    } catch (err) {
                                                        console.error('[Calibration] Failed to save:', err);
                                                    }

                                                    setCalibrationTimingActive(false); // Ensure timing mode is off
                                                    setShowCalibration(false);
                                                    setOrbPosition({ x: 0, y: -80 }); // Reset to front
                                                    // Reset calibration delay for next time
                                                    setCalibrationDelayMs(10);
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '12px',
                                                    background: '#4ade80',
                                                    color: 'black',
                                                    border: 'none',
                                                    borderRadius: '6px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600'
                                                }}
                                            >
                                                Apply Settings ✓
                                            </button>
                                            <button
                                                onClick={() => {
                                                    resetToDefaults(); // Start fresh
                                                    setCalibrationDelayMs(10);
                                                    setCalibrationResults({
                                                        canHearLeftRight: null,
                                                        leftRightIntensity: 2.0,
                                                        canHearFrontBack: null,
                                                        frontBackIntensity: 0.5,
                                                        canHearTimingLeft: null,
                                                        canHearTimingRight: null,
                                                        timingThresholdLeft: null,
                                                        timingThresholdRight: null,
                                                        preferredVolume: 0.5
                                                    });
                                                    setCalibrationStep(0);
                                                }}
                                                style={{
                                                    padding: '12px 16px',
                                                    background: 'transparent',
                                                    color: 'var(--text-secondary)',
                                                    border: '1px solid var(--text-secondary)',
                                                    borderRadius: '6px',
                                                    cursor: 'pointer'
                                                }}
                                            >
                                                Redo
                                            </button>
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}

                        {/* Head visualization - only show when not in calibration */}
                        {!showCalibration && (
                        <div
                            ref={containerRef}
                            style={{
                                width: '200px',
                                height: '200px',
                                margin: '0 auto 16px',
                                position: 'relative',
                                cursor: 'crosshair'
                            }}
                            onMouseDown={handleMouseDown}
                            onMouseMove={handleMouseMove}
                            onMouseUp={handleMouseUp}
                            onMouseLeave={handleMouseUp}
                        >
                            {/* Head circle */}
                            <div style={{
                                position: 'absolute',
                                top: '50%',
                                left: '50%',
                                transform: 'translate(-50%, -50%)',
                                width: '160px',
                                height: '160px',
                                borderRadius: '50%',
                                border: '3px solid var(--text-secondary)',
                                background: 'rgba(255,255,255,0.05)'
                            }}>
                                {/* Nose indicator */}
                                <div style={{
                                    position: 'absolute',
                                    top: '-15px',
                                    left: '50%',
                                    transform: 'translateX(-50%)',
                                    width: '0',
                                    height: '0',
                                    borderLeft: '8px solid transparent',
                                    borderRight: '8px solid transparent',
                                    borderBottom: '12px solid var(--text-secondary)'
                                }} />
                                {/* Left ear */}
                                <div style={{
                                    position: 'absolute',
                                    top: '50%',
                                    left: '-12px',
                                    transform: 'translateY(-50%)',
                                    width: '10px',
                                    height: '24px',
                                    borderRadius: '5px',
                                    background: 'var(--text-secondary)'
                                }} />
                                {/* Right ear */}
                                <div style={{
                                    position: 'absolute',
                                    top: '50%',
                                    right: '-12px',
                                    transform: 'translateY(-50%)',
                                    width: '10px',
                                    height: '24px',
                                    borderRadius: '5px',
                                    background: 'var(--text-secondary)'
                                }} />
                                {/* Labels */}
                                <span style={{ position: 'absolute', top: '-30px', left: '50%', transform: 'translateX(-50%)', fontSize: '0.7rem', color: 'var(--text-secondary)' }}>FRONT</span>
                                <span style={{ position: 'absolute', bottom: '-25px', left: '50%', transform: 'translateX(-50%)', fontSize: '0.7rem', color: 'var(--text-secondary)' }}>BACK</span>
                                <span style={{ position: 'absolute', top: '50%', left: '-35px', transform: 'translateY(-50%)', fontSize: '0.7rem', color: 'var(--text-secondary)' }}>L</span>
                                <span style={{ position: 'absolute', top: '50%', right: '-35px', transform: 'translateY(-50%)', fontSize: '0.7rem', color: 'var(--text-secondary)' }}>R</span>
                            </div>

                            {/* Sound orb - highly visible */}
                            <div style={{
                                position: 'absolute',
                                top: '50%',
                                left: '50%',
                                transform: `translate(calc(-50% + ${orbPosition.x}px), calc(-50% + ${orbPosition.y}px))`,
                                width: '32px',
                                height: '32px',
                                borderRadius: '50%',
                                background: '#ff6b35',
                                border: '3px solid #fff',
                                boxShadow: '0 0 20px #ff6b35, 0 0 40px rgba(255, 107, 53, 0.5), inset 0 0 10px rgba(255,255,255,0.3)',
                                cursor: isDragging ? 'grabbing' : 'grab',
                                transition: isDragging ? 'none' : 'transform 0.1s ease',
                                zIndex: 10
                            }}>
                                {/* Inner glow dot */}
                                <div style={{
                                    position: 'absolute',
                                    top: '50%',
                                    left: '50%',
                                    transform: 'translate(-50%, -50%)',
                                    width: '10px',
                                    height: '10px',
                                    borderRadius: '50%',
                                    background: '#fff'
                                }} />
                            </div>
                        </div>
                        )}

                        {/* Current values display */}
                        <div style={{
                            background: 'rgba(0,0,0,0.3)',
                            borderRadius: '8px',
                            padding: '12px',
                            fontFamily: 'monospace',
                            fontSize: '0.75rem',
                            marginBottom: '16px'
                        }}>
                            <div style={{ marginBottom: '8px', fontWeight: 'bold', color: 'var(--accent)' }}>
                                Position: {getPositionLabel()} ({Math.round(normalizedAngle)}°)
                            </div>
                            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' }}>
                                <div>
                                    <div style={{ color: 'var(--text-secondary)' }}>Pan Position:</div>
                                    <div style={{ color: '#4ade80' }}>{panPosition.toFixed(2)}</div>
                                </div>
                                <div>
                                    <div style={{ color: 'var(--text-secondary)' }}>Depth Mult:</div>
                                    <div style={{ color: '#4ade80' }}>{baseDepthMultiplier.toFixed(2)}</div>
                                </div>
                                <div>
                                    <div style={{ color: 'var(--text-secondary)' }}>Hard L/R Gain:</div>
                                    <div style={{ color: '#f472b6' }}>{hardLeftGain.toFixed(2)} / {hardRightGain.toFixed(2)}</div>
                                </div>
                                <div>
                                    <div style={{ color: 'var(--text-secondary)' }}>ITD L/R Delay:</div>
                                    <div style={{ color: '#f472b6' }}>{(itdLeftDelay * 1000).toFixed(2)}ms / {(itdRightDelay * 1000).toFixed(2)}ms</div>
                                </div>
                                <div>
                                    <div style={{ color: 'var(--text-secondary)' }}>Filter L/R (Hz):</div>
                                    <div style={{ color: '#a78bfa' }}>{Math.round(leftFilterFreq)} / {Math.round(rightFilterFreq)}</div>
                                </div>
                            </div>

                            {/* Ear indicators */}
                            <div style={{ marginTop: '12px', display: 'flex', gap: '16px', justifyContent: 'center' }}>
                                <div style={{ textAlign: 'center' }}>
                                    <div style={{ fontSize: '1.5rem' }}>👂</div>
                                    <div style={{
                                        height: '8px',
                                        width: '60px',
                                        background: 'rgba(255,255,255,0.2)',
                                        borderRadius: '4px',
                                        overflow: 'hidden'
                                    }}>
                                        <div style={{
                                            height: '100%',
                                            width: `${hardLeftGain * 100}%`,
                                            background: '#4ade80',
                                            transition: 'width 0.1s'
                                        }} />
                                    </div>
                                    <div style={{ fontSize: '0.7rem', color: 'var(--text-secondary)' }}>LEFT</div>
                                </div>
                                <div style={{ textAlign: 'center' }}>
                                    <div style={{ fontSize: '1.5rem', transform: 'scaleX(-1)' }}>👂</div>
                                    <div style={{
                                        height: '8px',
                                        width: '60px',
                                        background: 'rgba(255,255,255,0.2)',
                                        borderRadius: '4px',
                                        overflow: 'hidden'
                                    }}>
                                        <div style={{
                                            height: '100%',
                                            width: `${hardRightGain * 100}%`,
                                            background: '#4ade80',
                                            transition: 'width 0.1s'
                                        }} />
                                    </div>
                                    <div style={{ fontSize: '0.7rem', color: 'var(--text-secondary)' }}>RIGHT</div>
                                </div>
                            </div>
                        </div>

                        {/* Spatial Settings - Collapsible */}
                        <div style={{
                            background: 'rgba(0,0,0,0.3)',
                            borderRadius: '8px',
                            marginBottom: '12px',
                            overflow: 'hidden'
                        }}>
                            <button
                                onClick={() => setExpandedSections(prev => ({ ...prev, spatial: !prev.spatial }))}
                                style={{
                                    width: '100%',
                                    padding: '10px 12px',
                                    background: 'transparent',
                                    border: 'none',
                                    color: 'var(--accent)',
                                    cursor: 'pointer',
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center',
                                    fontWeight: '600',
                                    fontSize: '0.85rem'
                                }}
                            >
                                <span>🔊 Spatial Settings</span>
                                <span>{expandedSections.spatial ? '▼' : '▶'}</span>
                            </button>
                            {expandedSections.spatial && (
                        <div style={{
                            padding: '0 12px 12px'
                        }}>
                        <div style={{
                            background: 'rgba(0,0,0,0.3)',
                            borderRadius: '8px',
                            padding: '12px',
                            marginBottom: '16px'
                        }}>
                            {/* Cross Bleed */}
                            <div style={{ marginBottom: '12px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                    <span style={{ color: 'var(--text-secondary)' }}>Cross Bleed (opposite ear)</span>
                                    <span style={{ color: '#4ade80' }}>{(crossBleed * 100).toFixed(0)}%</span>
                                </div>
                                <input
                                    type="range"
                                    min="0"
                                    max="0.3"
                                    step="0.01"
                                    value={crossBleed}
                                    onChange={(e) => setCrossBleed(parseFloat(e.target.value))}
                                    style={{ width: '100%', accentColor: 'var(--accent)' }}
                                />
                                <div style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                    0% = complete isolation, 30% = some bleed to other ear
                                </div>
                            </div>

                            {/* Back Depth */}
                            <div style={{ marginBottom: '12px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                    <span style={{ color: 'var(--text-secondary)' }}>Back Volume</span>
                                    <span style={{ color: '#4ade80' }}>{(backDepth * 100).toFixed(0)}%</span>
                                </div>
                                <input
                                    type="range"
                                    min="0.3"
                                    max="1.0"
                                    step="0.05"
                                    value={backDepth}
                                    onChange={(e) => setBackDepth(parseFloat(e.target.value))}
                                    style={{ width: '100%', accentColor: 'var(--accent)' }}
                                />
                                <div style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                    Volume when sound is behind you (simulates distance)
                                </div>
                            </div>

                            {/* Pan Curve */}
                            <div style={{ marginBottom: '12px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                    <span style={{ color: 'var(--text-secondary)' }}>Pan Aggressiveness</span>
                                    <span style={{ color: '#4ade80' }}>{panCurve.toFixed(1)}x</span>
                                </div>
                                <input
                                    type="range"
                                    min="1"
                                    max="4"
                                    step="0.1"
                                    value={panCurve}
                                    onChange={(e) => setPanCurve(parseFloat(e.target.value))}
                                    style={{ width: '100%', accentColor: 'var(--accent)' }}
                                />
                                <div style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                    Higher = faster L/R separation as orb moves from center
                                </div>
                            </div>

                            {/* Hard Pan Threshold */}
                            <div style={{ marginBottom: '12px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                    <span style={{ color: 'var(--text-secondary)' }}>Center Dead Zone</span>
                                    <span style={{ color: '#4ade80' }}>{(hardPanThreshold * 100).toFixed(0)}%</span>
                                </div>
                                <input
                                    type="range"
                                    min="0"
                                    max="0.5"
                                    step="0.05"
                                    value={hardPanThreshold}
                                    onChange={(e) => setHardPanThreshold(parseFloat(e.target.value))}
                                    style={{ width: '100%', accentColor: 'var(--accent)' }}
                                />
                                <div style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                    Size of center zone where both ears hear equally
                                </div>
                            </div>

                            {/* ITD Amount */}
                            <div style={{ marginBottom: '12px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                    <span style={{ color: 'var(--text-secondary)' }}>Time Delay (ITD)</span>
                                    <span style={{ color: '#f472b6' }}>{(itdAmount * 0.7).toFixed(2)}ms</span>
                                </div>
                                <input
                                    type="range"
                                    min="0"
                                    max="1.5"
                                    step="0.1"
                                    value={itdAmount}
                                    onChange={(e) => setItdAmount(parseFloat(e.target.value))}
                                    style={{ width: '100%', accentColor: '#f472b6' }}
                                />
                                <div style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                    Sound reaches closer ear first (0.7ms is realistic max)
                                </div>
                            </div>

                            {/* Directional Depth */}
                            <div style={{ marginBottom: '12px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                    <span style={{ color: 'var(--text-secondary)' }}>Rear Ear Damping</span>
                                    <span style={{ color: '#f472b6' }}>{(directionalDepth * 100).toFixed(0)}%</span>
                                </div>
                                <input
                                    type="range"
                                    min="0"
                                    max="0.4"
                                    step="0.05"
                                    value={directionalDepth}
                                    onChange={(e) => setDirectionalDepth(parseFloat(e.target.value))}
                                    style={{ width: '100%', accentColor: '#f472b6' }}
                                />
                                <div style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                    Extra quieting when sound is behind that ear (pinna effect)
                                </div>
                            </div>

                            {/* Head Shadow (Low-pass filter) */}
                            <div style={{ marginBottom: '8px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                    <span style={{ color: 'var(--text-secondary)' }}>Head Shadow (Muffling)</span>
                                    <span style={{ color: '#a78bfa' }}>{(headShadow * 100).toFixed(0)}%</span>
                                </div>
                                <input
                                    type="range"
                                    min="0"
                                    max="1"
                                    step="0.1"
                                    value={headShadow}
                                    onChange={(e) => setHeadShadow(parseFloat(e.target.value))}
                                    style={{ width: '100%', accentColor: '#a78bfa' }}
                                />
                                <div style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                    Cuts high frequencies when behind/opposite (darker, muffled sound)
                                </div>
                            </div>

                            {/* Reset Spatial button */}
                            <button
                                onClick={() => {
                                    setCrossBleed(0);
                                    setBackDepth(0.55);
                                    setPanCurve(2.0);
                                    setHardPanThreshold(0.1);
                                    setItdAmount(0.7);
                                    setDirectionalDepth(0.15);
                                    setHeadShadow(0.5);
                                }}
                                style={{
                                    width: '100%',
                                    padding: '8px',
                                    background: 'rgba(255,255,255,0.1)',
                                    border: '1px solid var(--text-secondary)',
                                    borderRadius: '4px',
                                    color: 'var(--text-secondary)',
                                    cursor: 'pointer',
                                    fontSize: '0.75rem'
                                }}
                            >
                                Reset Spatial to Defaults
                            </button>
                        </div>
                            </div>
                        )}
                        </div>

                        {/* EQ Settings - Collapsible */}
                        <div style={{
                            background: 'rgba(0,0,0,0.3)',
                            borderRadius: '8px',
                            marginBottom: '12px',
                            overflow: 'hidden'
                        }}>
                            <button
                                onClick={() => setExpandedSections(prev => ({ ...prev, eq: !prev.eq }))}
                                style={{
                                    width: '100%',
                                    padding: '10px 12px',
                                    background: 'transparent',
                                    border: 'none',
                                    color: '#4ade80',
                                    cursor: 'pointer',
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center',
                                    fontWeight: '600',
                                    fontSize: '0.85rem'
                                }}
                            >
                                <span>🎚️ EQ Settings</span>
                                <span>{expandedSections.eq ? '▼' : '▶'}</span>
                            </button>
                            {expandedSections.eq && (
                            <div style={{ padding: '0 12px 12px' }}>
                                <p style={{ margin: '0 0 12px', fontSize: '0.8rem', color: 'var(--text-secondary)' }}>
                                    Adjust frequency balance to enhance audio clarity.
                                </p>

                            {/* EQ Controls */}
                            <div style={{
                                background: 'rgba(74, 222, 128, 0.1)',
                                padding: '12px',
                                borderRadius: '8px',
                                marginBottom: '8px',
                                border: '1px solid rgba(74, 222, 128, 0.3)'
                            }}>

                                {/* Bass */}
                                <div style={{ marginBottom: '10px' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                        <span style={{ color: 'var(--text-secondary)' }}>Bass (Low)</span>
                                        <span style={{ color: '#4ade80' }}>{eqBass > 0 ? '+' : ''}{eqBass} dB</span>
                                    </div>
                                    <input
                                        type="range"
                                        min="-12"
                                        max="12"
                                        step="1"
                                        value={eqBass}
                                        onChange={(e) => onEqBassChange && onEqBassChange(parseFloat(e.target.value))}
                                        style={{ width: '100%', accentColor: '#4ade80' }}
                                    />
                                </div>

                                {/* Mid */}
                                <div style={{ marginBottom: '10px' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                        <span style={{ color: 'var(--text-secondary)' }}>Mid</span>
                                        <span style={{ color: '#fbbf24' }}>{eqMid > 0 ? '+' : ''}{eqMid} dB</span>
                                    </div>
                                    <input
                                        type="range"
                                        min="-12"
                                        max="12"
                                        step="1"
                                        value={eqMid}
                                        onChange={(e) => onEqMidChange && onEqMidChange(parseFloat(e.target.value))}
                                        style={{ width: '100%', accentColor: '#fbbf24' }}
                                    />
                                </div>

                                {/* Treble */}
                                <div style={{ marginBottom: '10px' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                        <span style={{ color: 'var(--text-secondary)' }}>Treble (High)</span>
                                        <span style={{ color: '#60a5fa' }}>{eqTreble > 0 ? '+' : ''}{eqTreble} dB</span>
                                    </div>
                                    <input
                                        type="range"
                                        min="-12"
                                        max="12"
                                        step="1"
                                        value={eqTreble}
                                        onChange={(e) => onEqTrebleChange && onEqTrebleChange(parseFloat(e.target.value))}
                                        style={{ width: '100%', accentColor: '#60a5fa' }}
                                    />
                                </div>

                                {/* Clarity/Presence */}
                                <div style={{ marginBottom: '8px' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                        <span style={{ color: 'var(--text-secondary)' }}>Clarity (Presence)</span>
                                        <span style={{ color: '#f472b6' }}>{eqClarity > 0 ? '+' : ''}{eqClarity} dB</span>
                                    </div>
                                    <input
                                        type="range"
                                        min="-12"
                                        max="12"
                                        step="1"
                                        value={eqClarity}
                                        onChange={(e) => onEqClarityChange && onEqClarityChange(parseFloat(e.target.value))}
                                        style={{ width: '100%', accentColor: '#f472b6' }}
                                    />
                                    <div style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                        Boosts speech intelligibility range (~2.5kHz)
                                    </div>
                                </div>

                                {/* EQ Reset button */}
                                <button
                                    onClick={() => {
                                        onEqBassChange && onEqBassChange(0);
                                        onEqMidChange && onEqMidChange(0);
                                        onEqTrebleChange && onEqTrebleChange(0);
                                        onEqClarityChange && onEqClarityChange(0);
                                    }}
                                    style={{
                                        width: '100%',
                                        padding: '6px',
                                        background: 'rgba(74, 222, 128, 0.2)',
                                        border: '1px solid rgba(74, 222, 128, 0.5)',
                                        borderRadius: '4px',
                                        color: '#4ade80',
                                        cursor: 'pointer',
                                        fontSize: '0.7rem'
                                    }}
                                >
                                    Reset EQ to Flat
                                </button>
                            </div>
                            </div>
                            )}
                        </div>

                        {/* Copy settings button - Always visible at bottom */}
                        <div style={{ display: 'flex', gap: '8px' }}>
                            <button
                                onClick={() => {
                                    const settings = {
                                        // Current position
                                        panPosition: panPosition.toFixed(3),
                                        depthMultiplier: baseDepthMultiplier.toFixed(2),
                                        hardLeftGain: hardLeftGain.toFixed(3),
                                        hardRightGain: hardRightGain.toFixed(3),
                                        angle: Math.round(normalizedAngle),
                                        position: getPositionLabel(),
                                        // Tuning parameters
                                        tuning: {
                                            crossBleed: crossBleed.toFixed(2),
                                            backDepth: backDepth.toFixed(2),
                                            panCurve: panCurve.toFixed(1),
                                            hardPanThreshold: hardPanThreshold.toFixed(2),
                                            itdAmount: itdAmount.toFixed(2),
                                            directionalDepth: directionalDepth.toFixed(2),
                                            headShadow: headShadow.toFixed(2)
                                        },
                                        // Current ITD delays
                                        itd: {
                                            leftDelayMs: (itdLeftDelay * 1000).toFixed(3),
                                            rightDelayMs: (itdRightDelay * 1000).toFixed(3)
                                        },
                                        // Current filter frequencies
                                        filters: {
                                            leftHz: Math.round(leftFilterFreq),
                                            rightHz: Math.round(rightFilterFreq)
                                        }
                                    };
                                    const text = JSON.stringify(settings, null, 2);
                                    navigator.clipboard.writeText(text);
                                    alert('Settings copied! Paste them to share with the developer.');
                                }}
                                style={{
                                    flex: 1,
                                    padding: '12px',
                                    background: 'var(--accent)',
                                    color: 'white',
                                    border: 'none',
                                    borderRadius: '8px',
                                    cursor: 'pointer',
                                    fontWeight: '600'
                                }}
                            >
                                📋 Copy Settings
                            </button>
                            <button
                                onClick={onClose}
                                style={{
                                    padding: '12px 24px',
                                    background: 'transparent',
                                    color: 'var(--text-primary)',
                                    border: '1px solid var(--text-secondary)',
                                    borderRadius: '8px',
                                    cursor: 'pointer'
                                }}
                            >
                                Close
                            </button>
                        </div>

                        {/* End of Scrollable Content Area */}
                        </div>
                    </div>
                </div>
            );
        };

        // Advanced Controls Component (Story 3-2)
        const AdvancedControls = ({
            // Parameter states (from existing Epic 1 hooks)
            speed, setSpeed,
            intensity, setIntensity,
            spatialDepth, setSpatialDepth,
            movementPattern, setMovementPattern,
            binauralEnabled, setBinauralEnabled,
            binauralFreq, setBinauralFreq,
            noiseType, setNoiseType,
            noiseVolume, setNoiseVolume,
            // UI state
            isExpanded, setIsExpanded,
            sensorLocked, setSensorLocked,
            setA11yAnnouncement,
            // Story 3-3: Save preset handler
            onSavePreset,
            // Spatial tuner
            onOpenTuner,
            // Story 5-3: Sensor automation props (AC2, AC3)
            sensorStatus,
            autoAdjustEnabled,
            onAutoAdjustChange,
            showToast,
            logSensorEvent
        }) => {
            const isSensorConnected = sensorStatus === 'connected';

            // Story 5-3: Handler to detect manual slider interaction and pause automation (AC4)
            const handleSliderChange = (sliderName, setter, parser = parseFloat) => (e) => {
                const newValue = parser(e.target.value);

                // If automation is active, pause it (user override)
                if (sensorLocked) {
                    setSensorLocked(false);
                    if (logSensorEvent) {
                        logSensorEvent('AUTOMATION_PAUSED', {
                            trigger: 'manual_slider',
                            slider: sliderName,
                            newValue
                        });
                    }
                    if (showToast) {
                        showToast('Manual adjustment detected. Sensor automation paused.', 'info');
                    }
                    setA11yAnnouncement(`Manual ${sliderName} adjustment. Sensor automation paused.`);
                }

                // Apply the new value
                setter(newValue);
            };

            return (
                <details 
                    open={isExpanded} 
                    onToggle={(e) => setIsExpanded(e.target.open)}
                    className="advanced-controls"
                >
                    <summary>
                        ⚙️ Advanced Controls
                        <kbd>Ctrl+E</kbd>
                    </summary>
                    
                    <div className="controls-grid">
                        {/* Rotation Speed Slider */}
                        <label className="control-group">
                            <span className="control-label">Rotation Speed</span>
                            <div className="control-input">
                                <input
                                    type="range"
                                    min={PARAM_RANGES.speed.min}
                                    max={PARAM_RANGES.speed.max}
                                    step={PARAM_RANGES.speed.step}
                                    value={speed}
                                    onChange={handleSliderChange('rotation speed', setSpeed)}
                                    aria-label="Rotation speed"
                                />
                                <output>{speed.toFixed(2)}</output>
                            </div>
                            <span className="control-hint">How fast sound orbits your head</span>
                        </label>

                        {/* Intensity Slider */}
                        <label className="control-group">
                            <span className="control-label">Intensity</span>
                            <div className="control-input">
                                <input
                                    type="range"
                                    min={PARAM_RANGES.intensity.min}
                                    max={PARAM_RANGES.intensity.max}
                                    step={PARAM_RANGES.intensity.step}
                                    value={intensity}
                                    onChange={handleSliderChange('intensity', setIntensity)}
                                    aria-label="Intensity"
                                />
                                <output>{intensity.toFixed(2)}</output>
                            </div>
                            <span className="control-hint">Strength of 8D effect</span>
                        </label>

                        {/* Spatial Depth Slider */}
                        <label className="control-group">
                            <span className="control-label">Spatial Depth</span>
                            <div className="control-input">
                                <input
                                    type="range"
                                    min={PARAM_RANGES.spatialDepth.min}
                                    max={PARAM_RANGES.spatialDepth.max}
                                    step={PARAM_RANGES.spatialDepth.step}
                                    value={spatialDepth}
                                    onChange={handleSliderChange('spatial depth', setSpatialDepth)}
                                    aria-label="Spatial depth"
                                />
                                <output>{spatialDepth.toFixed(2)}</output>
                            </div>
                            <span className="control-hint">Front/back positioning</span>
                        </label>
                        
                        {/* Movement Pattern Dropdown */}
                        <label className="control-group">
                            <span className="control-label">Movement Pattern</span>
                            <div className="control-input">
                                <select
                                    value={movementPattern}
                                    onChange={handleSliderChange('movement pattern', setMovementPattern, (v) => v)}
                                    aria-label="Movement pattern"
                                >
                                    <option value="circle">Circle - Steady orbit</option>
                                    <option value="figure8">Figure-8 - Gentle sway</option>
                                    <option value="leftright">Left-Right - Side-to-side</option>
                                    <option value="frontback">Front-Back - Forward-backward</option>
                                    <option value="random">Random - Unpredictable</option>
                                </select>
                            </div>
                            <span className="control-hint">Path sound travels around you</span>
                        </label>

                        {/* Binaural Beats Checkbox */}
                        <label className="control-group checkbox-group">
                            <input
                                type="checkbox"
                                checked={binauralEnabled}
                                onChange={(e) => {
                                    if (sensorLocked) {
                                        setSensorLocked(false);
                                        if (logSensorEvent) {
                                            logSensorEvent('AUTOMATION_PAUSED', { trigger: 'manual_slider', slider: 'binaural enabled' });
                                        }
                                        if (showToast) {
                                            showToast('Manual adjustment detected. Sensor automation paused.', 'info');
                                        }
                                        setA11yAnnouncement('Manual binaural adjustment. Sensor automation paused.');
                                    }
                                    setBinauralEnabled(e.target.checked);
                                }}
                                aria-label="Enable binaural beats"
                            />
                            <span className="control-label">Binaural Beats</span>
                        </label>

                        {/* Binaural Frequency Slider (conditional) */}
                        {binauralEnabled && (
                            <label className="control-group">
                                <span className="control-label">Binaural Frequency</span>
                                <div className="control-input">
                                    <input
                                        type="range"
                                        min={PARAM_RANGES.binauralFreq.min}
                                        max={PARAM_RANGES.binauralFreq.max}
                                        step={PARAM_RANGES.binauralFreq.step}
                                        value={binauralFreq}
                                        onChange={handleSliderChange('binaural frequency', setBinauralFreq, parseInt)}
                                        aria-label="Binaural frequency"
                                    />
                                    <output>
                                        {binauralFreq} Hz
                                        <span className="freq-band">({getBinauralBand(binauralFreq)})</span>
                                    </output>
                                </div>
                                <span className="control-hint">{getBinauralHint(binauralFreq)}</span>
                            </label>
                        )}

                        {/* Noise Type Dropdown */}
                        <label className="control-group">
                            <span className="control-label">Noise Type</span>
                            <div className="control-input">
                                <select
                                    value={noiseType}
                                    onChange={handleSliderChange('noise type', setNoiseType, (v) => v)}
                                    aria-label="Noise type"
                                >
                                    <option value="pink">Pink - Balanced warmth</option>
                                    <option value="white">White - Crisp static</option>
                                    <option value="brown">Brown - Deep rumble</option>
                                </select>
                            </div>
                            <span className="control-hint">Background noise texture</span>
                        </label>
                        
                        {/* Noise Volume Slider */}
                        <label className="control-group">
                            <span className="control-label">Noise Volume</span>
                            <div className="control-input">
                                <input
                                    type="range"
                                    min={PARAM_RANGES.noiseVolume.min}
                                    max={PARAM_RANGES.noiseVolume.max}
                                    step={PARAM_RANGES.noiseVolume.step}
                                    value={noiseVolume}
                                    onChange={handleSliderChange('noise volume', setNoiseVolume)}
                                    aria-label="Noise volume"
                                />
                                <output>{noiseVolume.toFixed(2)}</output>
                            </div>
                            <span className="control-hint">Loudness of background noise</span>
                        </label>
                    </div>

                    {/* Story 3-3: Save Preset Button */}
                    {onSavePreset && (
                        <button
                            type="button"
                            onClick={onSavePreset}
                            className="primary-btn"
                            style={{ marginTop: '16px', width: '100%' }}
                            aria-label="Save current parameters as custom preset"
                        >
                            💾 Save as Custom Preset
                        </button>
                    )}

                    {/* Spatial Audio Tuner Button */}
                    {onOpenTuner && (
                        <button
                            type="button"
                            onClick={onOpenTuner}
                            style={{
                                marginTop: '8px',
                                width: '100%',
                                padding: '12px',
                                background: 'rgba(255,255,255,0.1)',
                                border: '1px dashed var(--text-secondary)',
                                borderRadius: '8px',
                                color: 'var(--text-primary)',
                                cursor: 'pointer',
                                fontSize: '0.875rem'
                            }}
                            aria-label="Open spatial audio tuner"
                        >
                            🎯 Open Spatial Tuner (Debug)
                        </button>
                    )}

                    {/* Story 5-3: Sensor Automation Lock Status (AC2, AC3) */}
                    {isSensorConnected && (
                        <div className="sensor-lock-notice" role="status" aria-live="polite">
                            {sensorLocked ? (
                                <>
                                    <button
                                        type="button"
                                        className="lock-icon-btn"
                                        onClick={() => {
                                            setSensorLocked(false);
                                            if (logSensorEvent) {
                                                logSensorEvent('AUTOMATION_PAUSED', { trigger: 'lock_icon' });
                                            }
                                            if (showToast) {
                                                showToast('Sensor automation paused. Toggle Auto-adjust to resume.', 'info');
                                            }
                                            setA11yAnnouncement('Sensor automation paused. Controls unlocked.');
                                        }}
                                        title="Sensor automation active. Click to pause."
                                        aria-label="Sensor automation active, click to take manual control"
                                    >
                                        <span className="lock-icon" aria-hidden="true">🔒</span>
                                    </button>
                                    <span className="lock-message">Parameters locked by adaptive mode</span>
                                    <button
                                        onClick={() => {
                                            setSensorLocked(false);
                                            if (logSensorEvent) {
                                                logSensorEvent('AUTOMATION_PAUSED', { trigger: 'lock_icon' });
                                            }
                                            if (showToast) {
                                                showToast('Sensor automation paused. Toggle Auto-adjust to resume.', 'info');
                                            }
                                            setA11yAnnouncement('Adaptive mode disabled. Controls unlocked.');
                                        }}
                                        className="unlock-btn"
                                    >
                                        Unlock Manual Control
                                    </button>
                                </>
                            ) : (
                                <>
                                    <button
                                        type="button"
                                        className="lock-icon-btn unlocked"
                                        onClick={() => {
                                            if (autoAdjustEnabled) {
                                                setSensorLocked(true);
                                                if (logSensorEvent) {
                                                    logSensorEvent('AUTO_ADJUST_ENABLED', { trigger: 'lock_icon' });
                                                }
                                                if (showToast) {
                                                    showToast('Sensor automation resumed.', 'info');
                                                }
                                                setA11yAnnouncement('Sensor automation resumed. Controls locked.');
                                            } else {
                                                if (showToast) {
                                                    showToast('Enable Auto-adjust in Settings to use sensor automation.', 'info');
                                                }
                                            }
                                        }}
                                        title={autoAdjustEnabled ? "Automation paused. Click to resume." : "Enable Auto-adjust in Settings to use sensor automation."}
                                        aria-label={autoAdjustEnabled ? "Automation paused, click to resume" : "Automation disabled, enable in settings"}
                                    >
                                        <span className="lock-icon" aria-hidden="true">🔓</span>
                                    </button>
                                    <span className="lock-message">
                                        {autoAdjustEnabled ? 'Automation paused - Click lock to resume' : 'Manual control active'}
                                    </span>
                                </>
                            )}
                        </div>
                    )}
                </details>
            );
        };

        // ============================================================
        // Story 5-1: Sensor Consent Modal Component (AC4)
        // Privacy-focused onboarding modal for sensor connections
        // ============================================================

        const SensorConsentModal = ({
            isOpen,
            sensorType,  // 'bluetooth' | 'serial'
            onConfirm,
            onCancel,
            skipConsent,
            setSkipConsent,
            reducedMotion,
            setA11yAnnouncement
        }) => {
            const modalRef = useRef(null);
            const firstButtonRef = useRef(null);

            // Focus management - focus first button when modal opens
            useEffect(() => {
                if (isOpen && firstButtonRef.current) {
                    setTimeout(() => {
                        firstButtonRef.current.focus();
                    }, 50);

                    if (setA11yAnnouncement) {
                        setA11yAnnouncement('Connect Your Sensor. Your heart rate data stays on this device. We never upload biometric data to any server.');
                    }
                }
            }, [isOpen, setA11yAnnouncement]);

            // Disable body scroll when modal open
            useEffect(() => {
                if (isOpen) {
                    document.body.style.overflow = 'hidden';
                } else {
                    document.body.style.overflow = '';
                }
                return () => {
                    document.body.style.overflow = '';
                };
            }, [isOpen]);

            // Focus trap and Escape key handler
            const handleKeyDown = (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    onCancel();
                    return;
                }

                if (e.key === 'Tab' && modalRef.current) {
                    const focusableElements = modalRef.current.querySelectorAll(
                        'button, input[type="checkbox"], [tabindex="0"]'
                    );
                    const focusableArray = Array.from(focusableElements);
                    const firstElement = focusableArray[0];
                    const lastElement = focusableArray[focusableArray.length - 1];

                    if (e.shiftKey && document.activeElement === firstElement) {
                        e.preventDefault();
                        lastElement.focus();
                    } else if (!e.shiftKey && document.activeElement === lastElement) {
                        e.preventDefault();
                        firstElement.focus();
                    }
                }
            };

            const handleSkipChange = (e) => {
                const checked = e.target.checked;
                setSkipConsent(checked);
                try {
                    if (checked) {
                        localStorage.setItem('mpe_8d_skip_sensor_consent', 'true');
                    } else {
                        localStorage.removeItem('mpe_8d_skip_sensor_consent');
                    }
                } catch (err) {
                    console.warn('[SensorBridge] Failed to persist consent preference:', err);
                }
            };

            const handleConfirm = () => {
                if (setA11yAnnouncement) {
                    setA11yAnnouncement('Connecting to sensor...');
                }
                onConfirm();
            };

            if (!isOpen) return null;

            const sensorLabel = sensorType === 'bluetooth' ? 'Bluetooth Sensor' : 'Serial Device';

            return (
                <div
                    className={`sensor-consent-overlay ${reducedMotion ? 'no-motion' : ''}`}
                    onClick={(e) => e.target === e.currentTarget && onCancel()}
                >
                    <div
                        ref={modalRef}
                        className="sensor-consent-modal"
                        role="dialog"
                        aria-modal="true"
                        aria-labelledby="sensor-consent-heading"
                        aria-describedby="sensor-consent-description"
                        onKeyDown={handleKeyDown}
                    >
                        <h2 id="sensor-consent-heading">Connect Your Sensor</h2>

                        <div id="sensor-consent-description" className="sensor-consent-content">
                            <p className="sensor-consent-intro">
                                Your heart rate data stays on this device. We never upload biometric data to any server.
                                You can disconnect or forget your device at any time.
                            </p>

                            <ul className="sensor-consent-list">
                                <li>Data stored locally in your browser</li>
                                <li>No internet connection required</li>
                                <li>"Forget Device" erases all stored data</li>
                            </ul>
                        </div>

                        <div className="sensor-consent-checkbox">
                            <label className="checkbox-label">
                                <input
                                    type="checkbox"
                                    checked={skipConsent}
                                    onChange={handleSkipChange}
                                    aria-describedby="skip-consent-hint"
                                />
                                <span>Don't show this again</span>
                            </label>
                            <small id="skip-consent-hint" className="consent-hint">
                                You can always disconnect or forget devices in settings
                            </small>
                        </div>

                        <div className="sensor-consent-actions">
                            <button
                                ref={firstButtonRef}
                                type="button"
                                className="primary-btn"
                                onClick={handleConfirm}
                                aria-label={`Connect ${sensorLabel}`}
                            >
                                Connect
                            </button>
                            <button
                                type="button"
                                className="ghost-btn"
                                onClick={onCancel}
                            >
                                Cancel
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // ============================================================
        // Story 4-2: Check-In Modal Component
        // ============================================================

        const CheckInModal = ({
            isOpen,
            onSubmit,
            onSkip,
            sessionId,
            reducedMotion,
            setA11yAnnouncement
        }) => {
            const [selectedEmoji, setSelectedEmoji] = useState(null);
            const [notes, setNotes] = useState('');
            const [isSubmitting, setIsSubmitting] = useState(false);
            const modalRef = useRef(null);
            const firstEmojiRef = useRef(null);
            const autoDismissRef = useRef(null);

            const emojis = [
                { code: '😰', label: 'Anxious or stressed', value: 'anxious' },
                { code: '😐', label: 'Neutral or unchanged', value: 'neutral' },
                { code: '😊', label: 'Calm and relaxed', value: 'calm' },
                { code: '😌', label: 'Focused and clear', value: 'focused' },
                { code: '🎉', label: 'Energized and joyful', value: 'energized' }
            ];

            // Focus management - focus first emoji when modal opens
            useEffect(() => {
                if (isOpen && firstEmojiRef.current) {
                    // Small delay to ensure modal is rendered
                    setTimeout(() => {
                        firstEmojiRef.current.focus();
                    }, 50);

                    // Announce modal opened
                    if (setA11yAnnouncement) {
                        setA11yAnnouncement('Check-in modal opened. How do you feel now?');
                    }
                }
            }, [isOpen, setA11yAnnouncement]);

            // Auto-dismiss after 60 seconds
            useEffect(() => {
                if (!isOpen) return;

                autoDismissRef.current = setTimeout(() => {
                    console.log('[SessionLogger] Check-in auto-dismissed after 60 seconds');
                    onSkip();
                }, 60000);

                return () => {
                    if (autoDismissRef.current) {
                        clearTimeout(autoDismissRef.current);
                    }
                };
            }, [isOpen, onSkip]);

            // Reset state when modal closes
            useEffect(() => {
                if (!isOpen) {
                    setSelectedEmoji(null);
                    setNotes('');
                    setIsSubmitting(false);
                }
            }, [isOpen]);

            // Disable body scroll when modal open
            useEffect(() => {
                if (isOpen) {
                    document.body.style.overflow = 'hidden';
                } else {
                    document.body.style.overflow = '';
                }
                return () => {
                    document.body.style.overflow = '';
                };
            }, [isOpen]);

            // Focus trap - cycle through modal elements
            const handleKeyDown = (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    onSkip();
                    return;
                }

                if (e.key === 'Tab' && modalRef.current) {
                    const focusableElements = modalRef.current.querySelectorAll(
                        'button, textarea, [tabindex="0"]'
                    );
                    const focusableArray = Array.from(focusableElements);
                    const firstElement = focusableArray[0];
                    const lastElement = focusableArray[focusableArray.length - 1];

                    if (e.shiftKey && document.activeElement === firstElement) {
                        e.preventDefault();
                        lastElement.focus();
                    } else if (!e.shiftKey && document.activeElement === lastElement) {
                        e.preventDefault();
                        firstElement.focus();
                    }
                }
            };

            const handleEmojiSelect = (emoji) => {
                setSelectedEmoji(emoji);
                if (setA11yAnnouncement) {
                    setA11yAnnouncement(`Mood rated as ${emoji.label}`);
                }
            };

            const handleSubmit = async () => {
                if (isSubmitting) return;
                setIsSubmitting(true);

                try {
                    await onSubmit({
                        moodAfter: selectedEmoji?.code || null,
                        notes: notes.trim()
                    });

                    const moodDesc = selectedEmoji?.value || 'no mood';
                    console.log(`[SessionLogger] Check-in completed: ${moodDesc} + ${notes.length} chars`);

                    if (setA11yAnnouncement) {
                        setA11yAnnouncement('Session saved with mood rating');
                    }
                } catch (err) {
                    console.error('[SessionLogger] Check-in submit error:', err);
                } finally {
                    setIsSubmitting(false);
                }
            };

            const handleSkip = () => {
                console.log('[SessionLogger] Check-in skipped');
                onSkip();
            };

            if (!isOpen) return null;

            return (
                <div
                    className={`checkin-overlay ${reducedMotion ? 'no-motion' : ''}`}
                    onClick={(e) => e.target === e.currentTarget && handleSkip()}
                >
                    <div
                        ref={modalRef}
                        className="checkin-modal"
                        role="dialog"
                        aria-modal="true"
                        aria-labelledby="checkin-heading"
                        aria-describedby="checkin-description"
                        onKeyDown={handleKeyDown}
                    >
                        <h2 id="checkin-heading">How do you feel now?</h2>
                        <p id="checkin-description" className="checkin-subtitle">
                            Rate your mood after this session (optional)
                        </p>

                        <div className="emoji-grid" role="radiogroup" aria-label="Mood rating">
                            {emojis.map((emoji, index) => (
                                <button
                                    key={emoji.value}
                                    ref={index === 0 ? firstEmojiRef : null}
                                    type="button"
                                    className={`emoji-button ${selectedEmoji?.value === emoji.value ? 'selected' : ''}`}
                                    onClick={() => handleEmojiSelect(emoji)}
                                    aria-label={`Rate mood as ${emoji.label}`}
                                    aria-pressed={selectedEmoji?.value === emoji.value}
                                    title={emoji.label}
                                >
                                    <span className="emoji-icon" aria-hidden="true">{emoji.code}</span>
                                    <span className="emoji-label">{emoji.label}</span>
                                </button>
                            ))}
                        </div>

                        <div className="checkin-notes-section">
                            <label htmlFor="session-notes">
                                Optional notes
                                <span className="checkin-note-hint"> (e.g., what helped?)</span>
                            </label>
                            <textarea
                                id="session-notes"
                                className="checkin-notes-textarea"
                                placeholder="What made this session effective or challenging?"
                                value={notes}
                                onChange={(e) => setNotes(e.target.value.slice(0, 500))}
                                maxLength={500}
                                rows={3}
                                aria-describedby="char-count"
                            />
                            <div id="char-count" className="checkin-char-count" aria-live="polite">
                                {notes.length} / 500 characters
                            </div>
                        </div>

                        <div className="checkin-modal-actions">
                            <button
                                type="button"
                                className="primary-btn"
                                onClick={handleSubmit}
                                disabled={isSubmitting}
                            >
                                {isSubmitting ? 'Saving...' : 'Submit'}
                            </button>
                            <button
                                type="button"
                                className="ghost-btn"
                                onClick={handleSkip}
                                disabled={isSubmitting}
                            >
                                Skip
                            </button>
                        </div>

                        <button
                            type="button"
                            className="checkin-close-button"
                            onClick={handleSkip}
                            aria-label="Close check-in modal"
                        >
                            ✕
                        </button>
                    </div>
                </div>
            );
        };

        // ============================================================
        // Story 5-1: Sensor Settings Component (AC1, AC2, AC3, AC8)
        // ============================================================

        // Relative time formatting helper for "Last connected" display
        const formatRelativeTime = (timestamp) => {
            if (!timestamp) return 'Never';
            const diff = Date.now() - timestamp;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (minutes < 1) return 'Just now';
            if (minutes < 60) return `${minutes} minute${minutes === 1 ? '' : 's'} ago`;
            if (hours < 24) return `${hours} hour${hours === 1 ? '' : 's'} ago`;
            if (days < 7) return `${days} day${days === 1 ? '' : 's'} ago`;
            return new Date(timestamp).toLocaleDateString();
        };

        const SensorSettings = ({
            bluetoothSupported,
            serialSupported,
            sensorStatus,
            connectedDevice,
            consentedDevices,
            onConnectBluetooth,
            onConnectSerial,
            onReconnect,
            onForget,
            onDisconnect,
            reducedMotion,
            // Story 5-2: HR monitoring props
            currentHR,
            hrHistory,
            hrThreshold,
            onThresholdChange,
            isSimulating,
            simulatorEnabled,
            onStartSimulation,
            onStopSimulation,
            // Story 5-3: Auto-adjust props (AC5, AC6)
            autoAdjustEnabled,
            onAutoAdjustChange,
            logSensorEvent
        }) => {
            // AC3: Browser compatibility messaging
            const showBrowserMessage = !bluetoothSupported || !serialSupported;
            const isFirefox = !bluetoothSupported && serialSupported;
            const isSafariOrUnsupported = !bluetoothSupported && !serialSupported;

            const getBrowserMessage = () => {
                if (isSafariOrUnsupported) {
                    return {
                        message: 'Sensor features require Chrome or Edge browser.',
                        icon: 'ℹ️'
                    };
                }
                if (isFirefox) {
                    return {
                        message: 'Bluetooth sensors not supported in Firefox. For heart rate tracking, try Chrome or Edge.',
                        icon: 'ℹ️'
                    };
                }
                return null;
            };

            const browserInfo = getBrowserMessage();
            const isScanning = sensorStatus === 'scanning';
            const isConnecting = sensorStatus === 'connecting';
            const isReconnecting = sensorStatus === 'reconnecting';
            const isConnected = sensorStatus === 'connected';
            const isDisconnected = sensorStatus === 'disconnected';
            const isLoading = isScanning || isConnecting || isReconnecting;

            // Story 5-2: Calculate rolling HR average (AC2)
            const hrAverage = hrHistory && hrHistory.length >= 10
                ? Math.round(hrHistory.reduce((sum, e) => sum + e.hr, 0) / hrHistory.length)
                : null;

            return (
                <div className="sensor-settings">
                    <h4 className="sensor-settings-title">Sensor Connection</h4>

                    {/* Browser Compatibility Message (AC3) */}
                    {browserInfo && (
                        <div className="sensor-browser-notice" role="status">
                            <span className="notice-icon" aria-hidden="true">{browserInfo.icon}</span>
                            <span className="notice-message">{browserInfo.message}</span>
                        </div>
                    )}

                    {/* Story 5-2: Real-Time HR Display (AC2) */}
                    {isConnected && currentHR !== null && (
                        <div className="sensor-hr-display" role="status" aria-live="polite">
                            <div className="hr-current">
                                <span className="hr-icon" aria-hidden="true">❤️</span>
                                <span className="hr-value">{currentHR}</span>
                                <span className="hr-unit">bpm</span>
                            </div>
                            {hrAverage !== null && (
                                <div className="hr-average">
                                    <span className="hr-avg-label">Avg:</span>
                                    <span className="hr-avg-value">{hrAverage} bpm</span>
                                </div>
                            )}
                        </div>
                    )}

                    {/* Reconnecting Status (AC3) */}
                    {isReconnecting && (
                        <div className="sensor-reconnecting-status" role="status" aria-live="assertive">
                            <span className="spinner" aria-hidden="true"></span>
                            <span>Reconnecting...</span>
                        </div>
                    )}

                    {/* Disconnected Status with Manual Reconnect (AC3) */}
                    {isDisconnected && connectedDevice && (
                        <div className="sensor-disconnected-status" role="status">
                            <span className="status-icon" aria-hidden="true">⚠️</span>
                            <span className="status-text">Disconnected from {connectedDevice.name}</span>
                            <button
                                type="button"
                                className="reconnect-btn"
                                onClick={() => onReconnect(connectedDevice)}
                            >
                                Reconnect
                            </button>
                        </div>
                    )}

                    {/* Connection Status */}
                    {isConnected && connectedDevice && (
                        <div className="sensor-connected-status">
                            <span className="status-icon" aria-hidden="true">✓</span>
                            <span className="status-text">
                                Connected to <strong>{connectedDevice.name}</strong>
                                {isSimulating && <span className="simulated-badge"> (Simulated)</span>}
                            </span>
                            <button
                                type="button"
                                className="disconnect-btn"
                                onClick={isSimulating ? onStopSimulation : onDisconnect}
                                aria-label={`Disconnect from ${connectedDevice.name}`}
                            >
                                {isSimulating ? 'Stop Simulation' : 'Disconnect'}
                            </button>
                        </div>
                    )}

                    {/* Connection Buttons (AC1, AC2) */}
                    {!isConnected && (
                        <div className="sensor-connect-actions">
                            {bluetoothSupported && (
                                <button
                                    type="button"
                                    className="sensor-connect-btn bluetooth"
                                    onClick={onConnectBluetooth}
                                    disabled={isLoading}
                                    aria-busy={isLoading}
                                >
                                    {isLoading ? (
                                        <>
                                            <span className="spinner" aria-hidden="true"></span>
                                            {isScanning ? 'Scanning...' : 'Connecting...'}
                                        </>
                                    ) : (
                                        <>
                                            <span className="btn-icon" aria-hidden="true">📶</span>
                                            Connect Bluetooth Sensor
                                        </>
                                    )}
                                </button>
                            )}
                            {serialSupported && (
                                <button
                                    type="button"
                                    className="sensor-connect-btn serial"
                                    onClick={onConnectSerial}
                                    disabled={isLoading}
                                    aria-busy={isLoading}
                                >
                                    {isLoading ? (
                                        <>
                                            <span className="spinner" aria-hidden="true"></span>
                                            {isScanning ? 'Scanning...' : 'Connecting...'}
                                        </>
                                    ) : (
                                        <>
                                            <span className="btn-icon" aria-hidden="true">🔌</span>
                                            Connect Serial Device
                                        </>
                                    )}
                                </button>
                            )}
                        </div>
                    )}

                    {/* Quick-Connect Device List (AC8) */}
                    {consentedDevices.length > 0 && !isConnected && (
                        <div className="sensor-device-list">
                            <h5 className="device-list-title">Previously Connected</h5>
                            <ul className="device-list" role="list">
                                {consentedDevices.map((device) => (
                                    <li key={device.deviceId} className="device-item">
                                        <div className="device-info">
                                            <span className="device-type-icon" aria-hidden="true">
                                                {device.type === 'bluetooth' ? '📶' : '🔌'}
                                            </span>
                                            <div className="device-details">
                                                <span className="device-name">{device.deviceName}</span>
                                                <span className="device-last-connected">
                                                    Last connected: {formatRelativeTime(device.lastConnectedAt)}
                                                </span>
                                            </div>
                                        </div>
                                        <div className="device-actions">
                                            <button
                                                type="button"
                                                className="device-reconnect-btn"
                                                onClick={() => onReconnect(device)}
                                                disabled={isLoading}
                                                aria-label={`Reconnect to ${device.deviceName}`}
                                            >
                                                Connect
                                            </button>
                                            <button
                                                type="button"
                                                className="device-forget-btn"
                                                onClick={() => onForget(device)}
                                                aria-label={`Forget ${device.deviceName}`}
                                                title="Forget device"
                                            >
                                                <span aria-hidden="true">🗑️</span>
                                            </button>
                                        </div>
                                    </li>
                                ))}
                            </ul>
                        </div>
                    )}

                    {/* Empty state when no sensors available */}
                    {!bluetoothSupported && !serialSupported && !simulatorEnabled && (
                        <div className="sensor-empty-state">
                            <p>Sensor features are not available in your browser.</p>
                            <a
                                href="https://caniuse.com/web-bluetooth"
                                target="_blank"
                                rel="noopener noreferrer"
                                className="learn-more-link"
                            >
                                Learn more about browser support
                            </a>
                        </div>
                    )}

                    {/* Story 5-2: HR Threshold Setting (AC7) */}
                    {(isConnected || simulatorEnabled) && (
                        <div className="sensor-threshold-setting">
                            <label htmlFor="hr-threshold" className="threshold-label">
                                Heart Rate Threshold
                            </label>
                            <div className="threshold-input-group">
                                <input
                                    id="hr-threshold"
                                    type="number"
                                    min="60"
                                    max="120"
                                    step="5"
                                    value={hrThreshold}
                                    onChange={(e) => onThresholdChange(parseInt(e.target.value, 10) || 85)}
                                    className="threshold-input"
                                    aria-describedby="threshold-help"
                                />
                                <span className="threshold-unit">BPM</span>
                            </div>
                            <p id="threshold-help" className="threshold-help-text">
                                Alert when heart rate exceeds this for 30+ seconds
                            </p>
                        </div>
                    )}

                    {/* Story 5-3: Auto-Adjust Toggle (AC5, AC6) */}
                    {isConnected && (
                        <div className="sensor-auto-adjust-setting">
                            <label className="auto-adjust-label">
                                <input
                                    type="checkbox"
                                    checked={autoAdjustEnabled}
                                    onChange={(e) => {
                                        const newValue = e.target.checked;
                                        onAutoAdjustChange(newValue);
                                        if (logSensorEvent) {
                                            logSensorEvent(
                                                newValue ? 'AUTO_ADJUST_ENABLED' : 'AUTO_ADJUST_DISABLED',
                                                { trigger: 'toggle', enabled: newValue }
                                            );
                                        }
                                    }}
                                    className="auto-adjust-checkbox"
                                    aria-describedby="auto-adjust-help"
                                />
                                <span className="auto-adjust-text">Auto-adjust audio</span>
                            </label>
                            <p id="auto-adjust-help" className="auto-adjust-help-text">
                                When enabled, app automatically adjusts audio based on heart rate
                            </p>
                        </div>
                    )}

                    {/* Story 5-2: Simulator Button (AC8) */}
                    {simulatorEnabled && !isConnected && !isSimulating && (
                        <div className="sensor-simulator-section">
                            <button
                                type="button"
                                className="sensor-connect-btn simulator"
                                onClick={() => onStartSimulation()}
                            >
                                <span className="btn-icon" aria-hidden="true">🧪</span>
                                Start Simulation
                            </button>
                            <p className="simulator-note">Developer mode: Test without physical sensor</p>
                        </div>
                    )}
                </div>
            );
        };

        // ============================================================
        // Story 5-1: Forget Device Confirmation Modal (AC7)
        // ============================================================

        const ForgetDeviceModal = ({
            isOpen,
            device,
            onConfirm,
            onCancel,
            reducedMotion,
            setA11yAnnouncement
        }) => {
            const modalRef = useRef(null);
            const cancelButtonRef = useRef(null);

            useEffect(() => {
                if (isOpen && cancelButtonRef.current) {
                    setTimeout(() => {
                        cancelButtonRef.current.focus();
                    }, 50);
                    if (setA11yAnnouncement) {
                        setA11yAnnouncement(`Forget ${device?.deviceName}? This will disconnect and remove all stored data.`);
                    }
                }
            }, [isOpen, device, setA11yAnnouncement]);

            useEffect(() => {
                if (isOpen) {
                    document.body.style.overflow = 'hidden';
                } else {
                    document.body.style.overflow = '';
                }
                return () => {
                    document.body.style.overflow = '';
                };
            }, [isOpen]);

            const handleKeyDown = (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    onCancel();
                }
            };

            if (!isOpen || !device) return null;

            return (
                <div
                    className={`forget-device-overlay ${reducedMotion ? 'no-motion' : ''}`}
                    onClick={(e) => e.target === e.currentTarget && onCancel()}
                >
                    <div
                        ref={modalRef}
                        className="forget-device-modal"
                        role="alertdialog"
                        aria-modal="true"
                        aria-labelledby="forget-device-heading"
                        aria-describedby="forget-device-description"
                        onKeyDown={handleKeyDown}
                    >
                        <h3 id="forget-device-heading">Forget {device.deviceName}?</h3>
                        <p id="forget-device-description">
                            This will disconnect and remove all stored data for this device.
                            You can reconnect later, but you'll need to go through the pairing process again.
                        </p>
                        <div className="forget-device-actions">
                            <button
                                ref={cancelButtonRef}
                                type="button"
                                className="ghost-btn"
                                onClick={onCancel}
                            >
                                Cancel
                            </button>
                            <button
                                type="button"
                                className="danger-btn"
                                onClick={() => onConfirm(device)}
                            >
                                Forget Device
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // ============================================================
        // Story 5-2: Sensor Suggestion Toast (AC5)
        // ============================================================

        const SensorSuggestionToast = ({
            isVisible,
            data,
            onAccept,
            onDismiss,
            onTimeout,
            reducedMotion
        }) => {
            const toastRef = useRef(null);
            const timeoutRef = useRef(null);
            const acceptButtonRef = useRef(null);

            // Auto-dismiss after 15 seconds
            useEffect(() => {
                if (isVisible) {
                    timeoutRef.current = setTimeout(() => {
                        onTimeout();
                    }, 15000);

                    // Focus the accept button when toast appears
                    if (acceptButtonRef.current) {
                        setTimeout(() => acceptButtonRef.current?.focus(), 100);
                    }
                }

                return () => {
                    if (timeoutRef.current) {
                        clearTimeout(timeoutRef.current);
                    }
                };
            }, [isVisible, onTimeout]);

            // Handle keyboard events
            const handleKeyDown = (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    onDismiss();
                }
            };

            if (!isVisible || !data) return null;

            return (
                <div
                    ref={toastRef}
                    className={`sensor-suggestion-toast ${reducedMotion ? 'no-motion' : ''}`}
                    role="alertdialog"
                    aria-modal="false"
                    aria-labelledby="suggestion-heading"
                    aria-describedby="suggestion-description"
                    onKeyDown={handleKeyDown}
                >
                    <div className="suggestion-content">
                        <span className="suggestion-icon" aria-hidden="true">💓</span>
                        <div className="suggestion-text">
                            <h4 id="suggestion-heading">Heart rate elevated</h4>
                            <p id="suggestion-description">
                                Your heart rate ({data.hr} bpm) has been elevated. Switch to Calm preset?
                            </p>
                        </div>
                    </div>
                    <div className="suggestion-actions">
                        <button
                            ref={acceptButtonRef}
                            type="button"
                            className="suggestion-accept-btn"
                            onClick={onAccept}
                        >
                            Switch
                        </button>
                        <button
                            type="button"
                            className="suggestion-dismiss-btn"
                            onClick={onDismiss}
                        >
                            Dismiss
                        </button>
                    </div>
                </div>
            );
        };

        // ============================================================
        // Story 4-3: Insights Dashboard Helpers
        // ============================================================

        // Emoji value scale for mood comparison
        const getEmojiValue = (emoji) => {
            const values = {
                '😰': 1,  // anxious
                '😐': 2,  // neutral
                '😊': 3,  // calm
                '😌': 4,  // focused
                '🎉': 5   // energized
            };
            return values[emoji] || null;
        };

        // Format duration as "Xh Ym"
        const formatInsightsDuration = (minutes) => {
            const hours = Math.floor(minutes / 60);
            const mins = Math.round(minutes % 60);
            if (hours > 0) {
                return `${hours}h ${mins}m`;
            }
            return `${mins}m`;
        };

        // Calculate summary statistics from sessions
        const calculateInsightsSummary = (sessions, previousSessions = []) => {
            if (!sessions || sessions.length === 0) {
                return {
                    totalSessions: 0,
                    totalMinutes: 0,
                    avgMinutes: 0,
                    feltBetterRate: 0,
                    ratedSessions: 0,
                    ritualsCompleted: 0,
                    ritualCompletionRate: 0,
                    changeFromPrevious: null
                };
            }

            const totalSessions = sessions.length;
            const totalMinutes = sessions.reduce((sum, s) => sum + ((s.duration || 0) / 60), 0);
            const avgMinutes = totalMinutes / totalSessions;

            const ratedSessions = sessions.filter(s => s.moodAfter !== null).length;
            const feltBetter = sessions.filter(s => {
                if (!s.moodAfter) return false;
                const before = getEmojiValue(s.moodBefore) || 2; // Default neutral if no before
                const after = getEmojiValue(s.moodAfter);
                return after > before;
            }).length;
            const feltBetterRate = ratedSessions > 0 ? feltBetter / ratedSessions : 0;

            const ritualsCompleted = sessions.filter(s => s.ritualUsed).length;
            const ritualCompletionRate = ritualsCompleted / totalSessions;

            const changeFromPrevious = previousSessions.length > 0
                ? totalSessions - previousSessions.length
                : null;

            return {
                totalSessions,
                totalMinutes,
                avgMinutes,
                feltBetterRate,
                ratedSessions,
                ritualsCompleted,
                ritualCompletionRate,
                changeFromPrevious
            };
        };

        // Group sessions by day for bar chart
        const groupSessionsByDay = (sessions, dateRange) => {
            const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            const grouped = {};

            sessions.forEach(session => {
                const date = new Date(session.timestamp);
                const dayKey = date.toISOString().split('T')[0];
                if (!grouped[dayKey]) {
                    grouped[dayKey] = { date: dayKey, minutes: 0, count: 0 };
                }
                grouped[dayKey].minutes += (session.duration || 0) / 60;
                grouped[dayKey].count += 1;
            });

            return Object.values(grouped)
                .sort((a, b) => new Date(a.date) - new Date(b.date))
                .map(day => ({
                    ...day,
                    label: dayNames[new Date(day.date).getDay()]
                }));
        };

        // Calculate preset statistics for line chart
        const calculatePresetStats = (sessions, presetColors = {}) => {
            const grouped = {};

            sessions.forEach(session => {
                const id = session.presetId || 'unknown';
                if (!grouped[id]) {
                    grouped[id] = {
                        id,
                        label: session.presetLabel || id,
                        count: 0,
                        completed: 0,
                        color: presetColors[id] || '#6366f1'
                    };
                }
                grouped[id].count += 1;
                if (!session.endedManually) {
                    grouped[id].completed += 1;
                }
            });

            return Object.values(grouped).map(preset => ({
                ...preset,
                completionRate: preset.count > 0 ? preset.completed / preset.count : 0
            }));
        };

        // Calculate mood improvement for donut chart
        const calculateMoodImprovement = (sessions) => {
            let feltBetter = 0, same = 0, worse = 0, total = 0;

            sessions.forEach(session => {
                if (!session.moodAfter) return;

                const before = getEmojiValue(session.moodBefore) || 2;
                const after = getEmojiValue(session.moodAfter);

                if (after > before) feltBetter++;
                else if (after === before) same++;
                else worse++;
                total++;
            });

            return { feltBetter, same, worse, total };
        };

        // Draw bar chart on canvas
        const drawBarChart = (canvas, data, options = {}) => {
            if (!canvas || !data || data.length === 0) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = { top: 20, right: 20, bottom: 40, left: 50 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            const maxMinutes = Math.max(...data.map(d => d.minutes), 30);
            const yMax = Math.ceil(maxMinutes / 30) * 30;
            const barWidth = Math.min(60, Math.max(20, (chartWidth / data.length) - 10));
            const barGap = (chartWidth - (barWidth * data.length)) / (data.length + 1);

            // Draw grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            const gridLines = 4;
            for (let i = 0; i <= gridLines; i++) {
                const y = padding.top + (chartHeight * i / gridLines);
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(width - padding.right, y);
                ctx.stroke();

                // Y-axis labels
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.font = '11px system-ui';
                ctx.textAlign = 'right';
                ctx.fillText(`${Math.round(yMax * (gridLines - i) / gridLines)}m`, padding.left - 8, y + 4);
            }

            // Draw bars
            const accentColor = options.accent || '#6366f1';
            data.forEach((day, i) => {
                const x = padding.left + barGap + (i * (barWidth + barGap));
                const barHeight = (day.minutes / yMax) * chartHeight;
                const y = padding.top + chartHeight - barHeight;

                // Bar
                ctx.fillStyle = accentColor;
                ctx.fillRect(x, y, barWidth, barHeight);

                // X-axis label
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.font = '11px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(day.label, x + barWidth / 2, height - padding.bottom + 20);
            });
        };

        // Draw line chart on canvas
        const drawLineChart = (canvas, data, options = {}) => {
            if (!canvas || !data || data.length < 2) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = { top: 20, right: 20, bottom: 40, left: 50 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Draw grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            const gridLines = 4;
            for (let i = 0; i <= gridLines; i++) {
                const y = padding.top + (chartHeight * i / gridLines);
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(width - padding.right, y);
                ctx.stroke();

                // Y-axis labels (percentage)
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.font = '11px system-ui';
                ctx.textAlign = 'right';
                ctx.fillText(`${Math.round(100 * (gridLines - i) / gridLines)}%`, padding.left - 8, y + 4);
            }

            const xStep = chartWidth / (data.length - 1);

            // Draw lines and dots
            data.forEach((preset, i) => {
                const x = padding.left + (i * xStep);
                const y = padding.top + chartHeight - (preset.completionRate * chartHeight);

                // Dot
                ctx.fillStyle = preset.color;
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, Math.PI * 2);
                ctx.fill();

                // X-axis label
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.font = '11px system-ui';
                ctx.textAlign = 'center';
                const label = preset.label.length > 10 ? preset.label.slice(0, 10) + '…' : preset.label;
                ctx.fillText(label, x, height - padding.bottom + 20);
            });

            // Connect dots with line
            if (data.length > 1) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                data.forEach((preset, i) => {
                    const x = padding.left + (i * xStep);
                    const y = padding.top + chartHeight - (preset.completionRate * chartHeight);
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
            }
        };

        // Draw donut chart on canvas
        const drawDonutChart = (canvas, data, options = {}) => {
            if (!canvas || !data || data.total === 0) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const outerRadius = Math.min(width, height) / 2 - 20;
            const innerRadius = outerRadius * 0.6;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            const total = data.total;
            const segments = [
                { value: data.feltBetter, color: '#4ade80', label: 'better' },
                { value: data.same, color: '#6b7280', label: 'same' },
                { value: data.worse, color: '#fb923c', label: 'worse' }
            ];

            let startAngle = -Math.PI / 2; // Start at top

            segments.forEach(segment => {
                if (segment.value === 0) return;

                const sliceAngle = (segment.value / total) * Math.PI * 2;

                ctx.fillStyle = segment.color;
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerRadius, startAngle, startAngle + sliceAngle);
                ctx.arc(centerX, centerY, innerRadius, startAngle + sliceAngle, startAngle, true);
                ctx.closePath();
                ctx.fill();

                startAngle += sliceAngle;
            });

            // Center text
            const feltBetterPercent = Math.round((data.feltBetter / total) * 100);
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 24px system-ui';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${feltBetterPercent}%`, centerX, centerY - 8);
            ctx.font = '12px system-ui';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.fillText('felt better', centerX, centerY + 14);
        };

        // Export sessions as JSON
        const exportSessionsAsJSON = (sessions, dateRange, summary) => {
            const sortedSessions = [...sessions].sort((a, b) => a.timestamp - b.timestamp);
            const data = {
                exportDate: new Date().toISOString(),
                profileId: 'default',
                version: '1.0',
                dateRange: {
                    range: dateRange,
                    start: sortedSessions[0]?.timestamp ? new Date(sortedSessions[0].timestamp).toISOString().split('T')[0] : null,
                    end: sortedSessions[sortedSessions.length - 1]?.timestamp ? new Date(sortedSessions[sortedSessions.length - 1].timestamp).toISOString().split('T')[0] : null,
                    days: parseInt(dateRange.replace('d', ''), 10)
                },
                summary: {
                    totalSessions: summary.totalSessions,
                    totalMinutes: Math.round(summary.totalMinutes),
                    feltBetterRate: Math.round(summary.feltBetterRate * 100) / 100,
                    ritualCompletionRate: Math.round(summary.ritualCompletionRate * 100) / 100
                },
                sessions: sortedSessions.map(s => ({
                    timestamp: new Date(s.timestamp).toISOString(),
                    trackName: s.trackName || 'Unknown Track',
                    presetLabel: s.presetLabel || 'Unknown',
                    duration: s.duration || 0,
                    ritualUsed: Boolean(s.ritualUsed),
                    moodBefore: s.moodBefore || null,
                    moodAfter: s.moodAfter || null,
                    notes: s.notes || '',
                    endedManually: Boolean(s.endedManually)
                }))
            };

            return JSON.stringify(data, null, 2);
        };

        // Export sessions as CSV
        const exportSessionsAsCSV = (sessions) => {
            const headers = [
                'timestamp',
                'track',
                'preset',
                'duration_seconds',
                'ritual_used',
                'mood_before',
                'mood_after',
                'notes',
                'ended_manually'
            ];

            const escapeCSV = (value) => {
                if (value === null || value === undefined) return '';
                const str = String(value);
                if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                    return `"${str.replace(/"/g, '""')}"`;
                }
                return str;
            };

            const sortedSessions = [...sessions].sort((a, b) => a.timestamp - b.timestamp);
            const rows = sortedSessions.map(s => [
                new Date(s.timestamp).toISOString().replace('T', ' ').split('.')[0],
                escapeCSV(s.trackName || 'Unknown Track'),
                escapeCSV(s.presetLabel || 'Unknown'),
                s.duration || 0,
                s.ritualUsed ? 'true' : 'false',
                s.moodBefore || '',
                s.moodAfter || '',
                escapeCSV(s.notes || ''),
                s.endedManually ? 'true' : 'false'
            ]);

            return [
                headers.join(','),
                ...rows.map(row => row.join(','))
            ].join('\n');
        };

        // ============================================================
        // Story 4-3: Insights Panel Component
        // ============================================================

        const InsightsPanel = ({
            sessions,
            dateRange,
            setDateRange,
            selectedMode,
            reducedMotion,
            showToast,
            allPresets
        }) => {
            const [isExporting, setIsExporting] = useState(false);
            const barChartRef = useRef(null);
            const lineChartRef = useRef(null);
            const donutChartRef = useRef(null);

            // Build preset color map
            const presetColors = useMemo(() => {
                const colors = {};
                if (allPresets) {
                    allPresets.forEach(p => {
                        colors[p.id] = p.accent || p.color || '#6366f1';
                    });
                }
                return colors;
            }, [allPresets]);

            // Calculate summary statistics
            const summary = useMemo(() => {
                return calculateInsightsSummary(sessions);
            }, [sessions]);

            // Calculate chart data
            const barChartData = useMemo(() => {
                return groupSessionsByDay(sessions, dateRange);
            }, [sessions, dateRange]);

            const lineChartData = useMemo(() => {
                return calculatePresetStats(sessions, presetColors);
            }, [sessions, presetColors]);

            const donutChartData = useMemo(() => {
                return calculateMoodImprovement(sessions);
            }, [sessions]);

            // Render bar chart when data changes
            useEffect(() => {
                if (barChartRef.current && barChartData.length > 0) {
                    drawBarChart(barChartRef.current, barChartData, {
                        accent: selectedMode?.accent || '#6366f1',
                        reducedMotion
                    });
                }
            }, [barChartData, selectedMode?.accent, reducedMotion]);

            // Render line chart when data changes
            useEffect(() => {
                if (lineChartRef.current && lineChartData.length > 1) {
                    drawLineChart(lineChartRef.current, lineChartData, {
                        reducedMotion
                    });
                }
            }, [lineChartData, reducedMotion]);

            // Render donut chart when data changes
            useEffect(() => {
                if (donutChartRef.current && donutChartData.total > 0) {
                    drawDonutChart(donutChartRef.current, donutChartData, {
                        reducedMotion
                    });
                }
            }, [donutChartData, reducedMotion]);

            const handleExport = async (format) => {
                setIsExporting(true);
                if (performance?.mark) {
                    performance.mark('export-start');
                }

                try {
                    let content, mimeType, filename;
                    const dateStr = new Date().toISOString().split('T')[0];

                    if (format === 'json') {
                        content = exportSessionsAsJSON(sessions, dateRange, summary);
                        mimeType = 'application/json';
                        filename = `mp3-8d-sessions-${dateRange}-${dateStr}.json`;
                    } else {
                        content = exportSessionsAsCSV(sessions);
                        mimeType = 'text/csv';
                        filename = `mp3-8d-sessions-${dateRange}-${dateStr}.csv`;
                    }

                    const blob = new Blob([content], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);

                    // Cleanup blob URL
                    setTimeout(() => URL.revokeObjectURL(url), 100);

                    if (performance?.mark) {
                        performance.mark('export-end');
                        const measure = performance.measure('export', 'export-start', 'export-end');
                        performance.clearMarks('export-start');
                        performance.clearMarks('export-end');
                        performance.clearMeasures('export');
                        console.log(`[SessionLogger] Export completed in ${measure.duration.toFixed(2)}ms`);
                    }

                    showToast(`Exported ${sessions.length} sessions to ${filename}`, 'success');
                } catch (err) {
                    console.error('[SessionLogger] Export failed:', err);
                    showToast('Export failed. See console for details.', 'error');
                } finally {
                    setIsExporting(false);
                }
            };

            // Empty state: 0 sessions
            if (!sessions || sessions.length === 0) {
                return (
                    <article className="panel insights-panel">
                        <div className="insights-empty-state">
                            <span className="empty-icon">📊</span>
                            <p>No sessions yet</p>
                            <small>Complete a ritual to start tracking progress.</small>
                        </div>
                    </article>
                );
            }

            // Empty state: <3 sessions
            if (sessions.length < 3) {
                return (
                    <article className="panel insights-panel">
                        <div className="insights-empty-state">
                            <span className="empty-icon">📈</span>
                            <p>Keep going!</p>
                            <small>Complete {3 - sessions.length} more session{sessions.length === 2 ? '' : 's'} to unlock insights.</small>
                        </div>
                    </article>
                );
            }

            const daysLabel = dateRange === '7d' ? '7' : dateRange === '14d' ? '14' : '30';

            return (
                <article className="panel insights-panel">
                    <div className="insights-header">
                        <div>
                            <p className="eyebrow">Insights</p>
                            <h3>Session Trends</h3>
                        </div>
                        <div className="date-range-selector" role="group" aria-label="Date range selection">
                            <button
                                type="button"
                                className={dateRange === '7d' ? 'active' : ''}
                                onClick={() => setDateRange('7d')}
                                aria-pressed={dateRange === '7d'}
                            >
                                7 days
                            </button>
                            <button
                                type="button"
                                className={dateRange === '14d' ? 'active' : ''}
                                onClick={() => setDateRange('14d')}
                                aria-pressed={dateRange === '14d'}
                            >
                                14 days
                            </button>
                            <button
                                type="button"
                                className={dateRange === '30d' ? 'active' : ''}
                                onClick={() => setDateRange('30d')}
                                aria-pressed={dateRange === '30d'}
                            >
                                30 days
                            </button>
                        </div>
                    </div>

                    <div className="summary-cards">
                        <div className="summary-card">
                            <span className="card-icon">📊</span>
                            <div className="card-value">{summary.totalSessions}</div>
                            <div className="card-label">Total Sessions</div>
                            {summary.changeFromPrevious !== null && (
                                <div className="card-subtitle">
                                    {summary.changeFromPrevious >= 0 ? '+' : ''}{summary.changeFromPrevious} from previous
                                </div>
                            )}
                        </div>

                        <div className="summary-card">
                            <span className="card-icon">⏱️</span>
                            <div className="card-value">{formatInsightsDuration(summary.totalMinutes)}</div>
                            <div className="card-label">Total Time</div>
                            <div className="card-subtitle">Avg: {Math.round(summary.avgMinutes)}m per session</div>
                        </div>

                        <div className="summary-card">
                            <span className="card-icon">
                                {summary.feltBetterRate >= 0.6 ? '😌' : summary.feltBetterRate >= 0.4 ? '😐' : '😰'}
                            </span>
                            <div className="card-value">{Math.round(summary.feltBetterRate * 100)}%</div>
                            <div className="card-label">Felt Better</div>
                            <div className="card-subtitle">{summary.ratedSessions} of {summary.totalSessions} rated</div>
                        </div>

                        <div className="summary-card">
                            <span className="card-icon">🧘</span>
                            <div className="card-value">{Math.round(summary.ritualCompletionRate * 100)}%</div>
                            <div className="card-label">Ritual Completion</div>
                            <div className="card-subtitle">{summary.ritualsCompleted} of {summary.totalSessions}</div>
                        </div>
                    </div>

                    <div className="chart-section">
                        <h4>Session Duration (Past {daysLabel} Days)</h4>
                        <canvas
                            ref={barChartRef}
                            width={600}
                            height={250}
                            aria-label={`Session duration chart showing ${Math.round(summary.totalMinutes)} total minutes over ${summary.totalSessions} sessions`}
                        />
                    </div>

                    {lineChartData.length > 1 && (
                        <div className="chart-section">
                            <h4>Preset Effectiveness</h4>
                            <canvas
                                ref={lineChartRef}
                                width={600}
                                height={250}
                                aria-label="Preset effectiveness chart showing completion rates"
                            />
                            <div className="chart-legend">
                                {lineChartData.map(preset => (
                                    <div key={preset.id} className="legend-item">
                                        <span className="legend-color" style={{ background: preset.color }} />
                                        <span>{preset.label}</span>
                                        <span className="legend-count">({preset.count} sessions)</span>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {donutChartData.total > 0 && (
                        <div className="chart-section">
                            <h4>Mood Improvement</h4>
                            <canvas
                                ref={donutChartRef}
                                width={300}
                                height={300}
                                style={{ maxWidth: '300px', margin: '0 auto', display: 'block' }}
                                aria-label={`Mood improvement: ${Math.round(donutChartData.feltBetter / donutChartData.total * 100)}% felt better, ${Math.round(donutChartData.same / donutChartData.total * 100)}% same, ${Math.round(donutChartData.worse / donutChartData.total * 100)}% worse`}
                            />
                            <div className="chart-legend">
                                <div className="legend-item">
                                    <span className="legend-color" style={{ background: '#4ade80' }} />
                                    <span>Felt better ({donutChartData.feltBetter})</span>
                                </div>
                                <div className="legend-item">
                                    <span className="legend-color" style={{ background: '#6b7280' }} />
                                    <span>Same ({donutChartData.same})</span>
                                </div>
                                <div className="legend-item">
                                    <span className="legend-color" style={{ background: '#fb923c' }} />
                                    <span>Felt worse ({donutChartData.worse})</span>
                                </div>
                            </div>
                        </div>
                    )}

                    <div className="export-section">
                        <button
                            type="button"
                            className="primary-btn"
                            onClick={() => handleExport('json')}
                            disabled={isExporting}
                        >
                            {isExporting ? 'Exporting...' : 'Export as JSON'}
                        </button>
                        <button
                            type="button"
                            className="ghost-btn"
                            onClick={() => handleExport('csv')}
                            disabled={isExporting}
                        >
                            Export as CSV
                        </button>
                    </div>
                </article>
            );
        };

        // ============================================================
        // Story 3-3: Save Preset Dialog Component
        // ============================================================

        const SavePresetDialog = ({ 
            currentParameters, 
            onSave, 
            onCancel,
            showToast,
            setA11yAnnouncement,
            existingPreset = null // for edit mode
        }) => {
            const [name, setName] = useState(existingPreset?.name || '');
            const [description, setDescription] = useState(existingPreset?.description || '');
            const [color, setColor] = useState(existingPreset?.color || '#6366f1');
            const [errors, setErrors] = useState({});
            
            const validate = () => {
                const newErrors = {};
                
                if (!name.trim()) {
                    newErrors.name = 'Preset name is required';
                } else if (name.length > 50) {
                    newErrors.name = 'Name too long (max 50 characters)';
                }
                
                if (description.length > 200) {
                    newErrors.description = 'Description too long (max 200 characters)';
                }
                
                // Validate color hex format
                const hexPattern = /^#[0-9A-Fa-f]{6}$/;
                if (!hexPattern.test(color)) {
                    newErrors.color = 'Invalid color format (use #RRGGBB)';
                }
                
                setErrors(newErrors);
                return Object.keys(newErrors).length === 0;
            };
            
            const handleSave = () => {
                if (!validate()) return;
                
                const presetData = {
                    name: name.trim(),
                    description: description.trim(),
                    color,
                    ...currentParameters
                };
                
                let presetId;
                if (existingPreset) {
                    // Edit mode
                    const success = updateCustomPreset(existingPreset.id, presetData, showToast);
                    if (success) {
                        presetId = existingPreset.id;
                        showToast(`Preset "${name}" updated`, 'success');
                        setA11yAnnouncement(`Preset ${name} updated`);
                    }
                } else {
                    // Create mode
                    presetId = saveCustomPreset(presetData, showToast);
                    if (presetId) {
                        showToast(`Preset "${name}" saved`, 'success');
                        setA11yAnnouncement(`Preset ${name} saved`);
                    }
                }
                
                if (presetId) {
                    onSave(presetId);
                }
            };
            
            // Handle Escape key to close dialog
            useEffect(() => {
                const handleEscape = (e) => {
                    if (e.key === 'Escape') onCancel();
                };
                document.addEventListener('keydown', handleEscape);
                return () => document.removeEventListener('keydown', handleEscape);
            }, [onCancel]);
            
            return (
                <div 
                    className="dialog-overlay" 
                    onClick={onCancel}
                    role="dialog"
                    aria-modal="true"
                    aria-labelledby="dialog-title"
                >
                    <div 
                        className="dialog-content" 
                        onClick={(e) => e.stopPropagation()}
                        style={{
                            backgroundColor: 'var(--bg-primary)',
                            padding: '24px',
                            borderRadius: '12px',
                            maxWidth: '500px',
                            width: '90%',
                            maxHeight: '80vh',
                            overflow: 'auto'
                        }}
                    >
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
                            {/* React JSX automatically escapes user input, preventing XSS attacks */}
                            <h2 id="dialog-title" style={{ margin: 0 }}>
                                {existingPreset ? 'Edit Preset' : 'Save Custom Preset'}
                            </h2>
                            <button 
                                onClick={onCancel} 
                                aria-label="Close dialog" 
                                style={{
                                    background: 'none',
                                    border: 'none',
                                    fontSize: '24px',
                                    cursor: 'pointer',
                                    color: 'var(--text-secondary)'
                                }}
                            >
                                ×
                            </button>
                        </div>
                        
                        <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
                            {/* Preset Name */}
                            <label style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                <span style={{ fontWeight: '500', color: errors.name ? '#f87171' : 'inherit' }}>
                                    Preset Name *
                                </span>
                                <input 
                                    type="text" 
                                    value={name} 
                                    onChange={(e) => setName(e.target.value)} 
                                    placeholder="e.g., Deep Flow"
                                    maxLength={50}
                                    required
                                    autoFocus
                                    aria-invalid={!!errors.name}
                                    aria-describedby={errors.name ? 'name-error' : undefined}
                                    style={{
                                        padding: '8px 12px',
                                        borderRadius: '6px',
                                        border: `1px solid ${errors.name ? '#f87171' : 'var(--border)'}`,
                                        backgroundColor: 'var(--bg-secondary)',
                                        color: 'var(--text-primary)'
                                    }}
                                />
                                {errors.name && (
                                    <span id="name-error" style={{ color: '#f87171', fontSize: '0.875rem' }}>
                                        {errors.name}
                                    </span>
                                )}
                                <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', textAlign: 'right' }}>
                                    {name.length}/50
                                </span>
                            </label>
                            
                            {/* Description */}
                            <label style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                <span style={{ fontWeight: '500', color: errors.description ? '#f87171' : 'inherit' }}>
                                    Description (optional)
                                </span>
                                <textarea 
                                    value={description} 
                                    onChange={(e) => setDescription(e.target.value)} 
                                    placeholder="My perfect focus state"
                                    maxLength={200}
                                    rows={3}
                                    aria-invalid={!!errors.description}
                                    aria-describedby={errors.description ? 'desc-error' : undefined}
                                    style={{
                                        padding: '8px 12px',
                                        borderRadius: '6px',
                                        border: `1px solid ${errors.description ? '#f87171' : 'var(--border)'}`,
                                        backgroundColor: 'var(--bg-secondary)',
                                        color: 'var(--text-primary)',
                                        fontFamily: 'inherit',
                                        resize: 'vertical'
                                    }}
                                />
                                {errors.description && (
                                    <span id="desc-error" style={{ color: '#f87171', fontSize: '0.875rem' }}>
                                        {errors.description}
                                    </span>
                                )}
                                <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', textAlign: 'right' }}>
                                    {description.length}/200
                                </span>
                            </label>
                            
                            {/* Color Picker */}
                            <label style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                <span style={{ fontWeight: '500', color: errors.color ? '#f87171' : 'inherit' }}>
                                    Accent Color
                                </span>
                                <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
                                    <input 
                                        type="color" 
                                        value={color} 
                                        onChange={(e) => setColor(e.target.value)}
                                        style={{ width: '48px', height: '48px', cursor: 'pointer' }}
                                    />
                                    <input 
                                        type="text" 
                                        value={color} 
                                        onChange={(e) => setColor(e.target.value)} 
                                        placeholder="#6366f1"
                                        pattern="^#[0-9A-Fa-f]{6}$"
                                        aria-invalid={!!errors.color}
                                        aria-describedby={errors.color ? 'color-error' : undefined}
                                        style={{
                                            padding: '8px 12px',
                                            borderRadius: '6px',
                                            border: `1px solid ${errors.color ? '#f87171' : 'var(--border)'}`,
                                            backgroundColor: 'var(--bg-secondary)',
                                            color: 'var(--text-primary)',
                                            flex: 1
                                        }}
                                    />
                                </div>
                                {errors.color && (
                                    <span id="color-error" style={{ color: '#f87171', fontSize: '0.875rem' }}>
                                        {errors.color}
                                    </span>
                                )}
                            </label>
                            
                            {/* Parameter Preview */}
                            <div style={{ 
                                padding: '12px', 
                                borderRadius: '8px', 
                                backgroundColor: 'var(--bg-secondary)',
                                border: '1px solid var(--border)'
                            }}>
                                <h3 style={{ margin: '0 0 12px 0', fontSize: '0.875rem', fontWeight: '600' }}>
                                    Current Parameters
                                </h3>
                                <div style={{ 
                                    display: 'grid', 
                                    gridTemplateColumns: 'auto 1fr', 
                                    gap: '4px 12px',
                                    fontSize: '0.875rem'
                                }}>
                                    <dt style={{ fontWeight: '500', color: 'var(--text-secondary)' }}>Speed:</dt>
                                    <dd style={{ margin: 0 }}>{currentParameters.speed.toFixed(2)}</dd>
                                    
                                    <dt style={{ fontWeight: '500', color: 'var(--text-secondary)' }}>Intensity:</dt>
                                    <dd style={{ margin: 0 }}>{currentParameters.intensity.toFixed(2)}</dd>
                                    
                                    <dt style={{ fontWeight: '500', color: 'var(--text-secondary)' }}>Spatial Depth:</dt>
                                    <dd style={{ margin: 0 }}>{currentParameters.spatialDepth.toFixed(2)}</dd>
                                    
                                    <dt style={{ fontWeight: '500', color: 'var(--text-secondary)' }}>Movement:</dt>
                                    <dd style={{ margin: 0 }}>{currentParameters.movement}</dd>
                                    
                                    <dt style={{ fontWeight: '500', color: 'var(--text-secondary)' }}>Binaural:</dt>
                                    <dd style={{ margin: 0 }}>
                                        {currentParameters.binauralEnabled 
                                            ? `${currentParameters.binauralFreq} Hz (${getBinauralBand(currentParameters.binauralFreq)})` 
                                            : 'Off'}
                                    </dd>
                                    
                                    <dt style={{ fontWeight: '500', color: 'var(--text-secondary)' }}>Noise:</dt>
                                    <dd style={{ margin: 0 }}>
                                        {currentParameters.noiseType} @ {(currentParameters.noiseVolume * 100).toFixed(0)}%
                                    </dd>
                                </div>
                            </div>
                        </div>
                        
                        {/* Dialog Actions */}
                        <div style={{ display: 'flex', gap: '8px', marginTop: '20px', justifyContent: 'flex-end' }}>
                            <button 
                                onClick={onCancel} 
                                className="ghost-btn"
                            >
                                Cancel
                            </button>
                            <button 
                                onClick={handleSave} 
                                disabled={!name.trim()} 
                                className="primary-btn"
                            >
                                {existingPreset ? 'Update' : 'Save'} Preset
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // ============================================================
        // Story 3-3: PresetList Component
        // ============================================================

        const PresetList = ({
            presets,
            activePresetId,
            onSelect,
            onEdit,
            onDelete,
            onReorder
        }) => {
            const [draggedIndex, setDraggedIndex] = useState(null);

            const handleDragStart = (e, index) => {
                setDraggedIndex(index);
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleDragOver = (e, index) => {
                e.preventDefault();
                if (draggedIndex === null || draggedIndex === index) return;

                const newPresets = [...presets];
                const [removed] = newPresets.splice(draggedIndex, 1);
                newPresets.splice(index, 0, removed);

                onReorder(newPresets.map(p => p.id));
                setDraggedIndex(index);
            };

            const handleDragEnd = () => {
                setDraggedIndex(null);
            };

            const handlePresetKeyDown = (e, preset) => {
                // Handle Ctrl+ArrowUp/Down for reordering (AC5)
                if (e.ctrlKey && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
                    e.preventDefault();

                    const currentIndex = presets.findIndex(p => p.id === preset.id);
                    if (currentIndex === -1) return;

                    let newIndex;
                    if (e.key === 'ArrowUp') {
                        // Can't move above first custom preset (defaults are immutable)
                        const firstCustomIndex = presets.findIndex(p => !p.isDefault);
                        if (currentIndex <= firstCustomIndex) return;
                        newIndex = currentIndex - 1;
                    } else { // ArrowDown
                        if (currentIndex >= presets.length - 1) return;
                        newIndex = currentIndex + 1;
                    }

                    const newPresets = [...presets];
                    [newPresets[currentIndex], newPresets[newIndex]] = [newPresets[newIndex], newPresets[currentIndex]];
                    onReorder(newPresets.map(p => p.id));
                    return;
                }

                // Handle ArrowUp/Down for navigation (AC2)
                if (!e.ctrlKey && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
                    e.preventDefault();

                    // Find all focusable preset cards
                    const presetCards = Array.from(document.querySelectorAll('.preset-card[tabindex="0"]'));
                    const currentCard = e.currentTarget;
                    const currentCardIndex = presetCards.indexOf(currentCard);

                    if (currentCardIndex === -1) return;

                    let nextCard;
                    if (e.key === 'ArrowUp' && currentCardIndex > 0) {
                        nextCard = presetCards[currentCardIndex - 1];
                    } else if (e.key === 'ArrowDown' && currentCardIndex < presetCards.length - 1) {
                        nextCard = presetCards[currentCardIndex + 1];
                    }

                    if (nextCard) {
                        nextCard.focus();
                    }
                    return;
                }

                // Handle Enter to apply preset (AC2)
                if (e.key === 'Enter') {
                    e.preventDefault();
                    onSelect(preset.id);
                }
            };

            const formatLastUsed = (timestamp) => {
                if (!timestamp) return 'Never used';
                const hours = Math.floor((Date.now() - timestamp) / 1000 / 60 / 60);
                if (hours < 1) return 'Just now';
                if (hours < 24) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
                const days = Math.floor(hours / 24);
                return `${days} day${days > 1 ? 's' : ''} ago`;
            };

            return (
                <div className="preset-list-section" style={{ marginTop: '16px', paddingTop: '16px', borderTop: '1px solid var(--border)' }}>
                    <h3 style={{ fontSize: '0.875rem', fontWeight: '600', marginBottom: '12px', color: 'var(--text-secondary)' }}>
                        Your Custom Presets
                    </h3>

                    <div className="preset-list" role="list">
                        {presets.filter(p => !p.isDefault).length === 0 ? (
                            <div style={{
                                padding: '20px',
                                textAlign: 'center',
                                color: 'var(--text-secondary)',
                                backgroundColor: 'var(--bg-secondary)',
                                borderRadius: '8px',
                                fontSize: '0.875rem'
                            }}>
                                <p style={{ margin: '0 0 8px 0' }}>No custom presets yet.</p>
                                <p style={{ margin: 0 }}>Tweak parameters and click "Save Preset" to create your first!</p>
                            </div>
                        ) : (
                            presets.filter(p => !p.isDefault).map((preset, index) => (
                                <div
                                    key={preset.id}
                                    className={`preset-card ${preset.id === activePresetId ? 'active' : ''}`}
                                    role="listitem"
                                    tabIndex={0}
                                    draggable={true}
                                    onDragStart={(e) => handleDragStart(e, index)}
                                    onDragOver={(e) => handleDragOver(e, index)}
                                    onDragEnd={handleDragEnd}
                                    onKeyDown={(e) => handlePresetKeyDown(e, preset)}
                                    style={{
                                        '--accent-color': preset.color,
                                        marginBottom: '8px',
                                        padding: '12px',
                                        backgroundColor: preset.id === activePresetId ? 'var(--bg-secondary)' : 'var(--bg-primary)',
                                        border: `1px solid ${preset.id === activePresetId ? 'var(--accent)' : 'var(--border)'}`,
                                        borderRadius: '8px',
                                        cursor: 'grab',
                                        position: 'relative'
                                    }}
                                >
                                    <div style={{ display: 'flex', gap: '12px', alignItems: 'flex-start' }}>
                                        <div className="drag-handle" aria-label="Drag to reorder" style={{
                                            cursor: 'grab',
                                            color: 'var(--text-tertiary)',
                                            fontSize: '1rem',
                                            lineHeight: '1'
                                        }}>
                                            ⋮⋮
                                        </div>

                                        <div style={{ flex: 1 }}>
                                            <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '4px' }}>
                                                <h4 style={{ margin: 0, fontSize: '0.875rem', fontWeight: '600' }}>{preset.name}</h4>
                                                {preset.id === activePresetId && (
                                                    <span style={{
                                                        fontSize: '0.75rem',
                                                        padding: '2px 6px',
                                                        backgroundColor: 'var(--accent)',
                                                        color: 'white',
                                                        borderRadius: '4px',
                                                        fontWeight: '500'
                                                    }}>
                                                        Active
                                                    </span>
                                                )}
                                                {preset.isDefault && (
                                                    <span style={{
                                                        fontSize: '0.75rem',
                                                        padding: '2px 6px',
                                                        backgroundColor: 'var(--border)',
                                                        color: 'var(--text-secondary)',
                                                        borderRadius: '4px',
                                                        fontWeight: '500'
                                                    }}>
                                                        Default
                                                    </span>
                                                )}
                                            </div>

                                            {preset.description && (
                                                <p style={{
                                                    margin: '4px 0',
                                                    fontSize: '0.8125rem',
                                                    color: 'var(--text-secondary)',
                                                    lineHeight: '1.4'
                                                }}>
                                                    {preset.description}
                                                </p>
                                            )}

                                            <div style={{
                                                display: 'flex',
                                                alignItems: 'center',
                                                justifyContent: 'space-between',
                                                marginTop: '8px'
                                            }}>
                                                <span style={{ fontSize: '0.75rem', color: 'var(--text-tertiary)' }}>
                                                    Last used: {formatLastUsed(preset.lastUsedAt)}
                                                </span>
                                                <div style={{ display: 'flex', gap: '6px' }}>
                                                    <button
                                                        className="ghost-btn"
                                                        style={{ fontSize: '0.75rem', padding: '4px 8px' }}
                                                        onClick={() => onSelect(preset.id)}
                                                        disabled={preset.id === activePresetId}
                                                    >
                                                        {preset.id === activePresetId ? '✓ Active' : 'Apply'}
                                                    </button>
                                                    <button
                                                        onClick={() => onEdit(preset)}
                                                        aria-label={`Edit ${preset.name}`}
                                                        className="ghost-btn"
                                                        style={{ fontSize: '0.75rem', padding: '4px 8px' }}
                                                    >
                                                        ✏️
                                                    </button>
                                                    <button
                                                        onClick={() => onDelete(preset.id)}
                                                        aria-label={`Delete ${preset.name}`}
                                                        className="ghost-btn"
                                                        style={{ fontSize: '0.75rem', padding: '4px 8px', color: '#ef4444' }}
                                                    >
                                                        🗑️
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            ))
                        )}
                    </div>
                </div>
            );
        };

        // ============================================
        // useServiceWorker Hook - Story 6-1
        // Service Worker Registration & Offline State
        // ============================================
        function useServiceWorker() {
            // SW lifecycle states: unsupported | installing | waiting | active | error
            const [swStatus, setSwStatus] = useState(() => {
                if (typeof navigator === 'undefined' || !('serviceWorker' in navigator)) {
                    return 'unsupported';
                }
                return 'installing'; // Will update once we check
            });

            // Online/offline state
            const [isOffline, setIsOffline] = useState(() =>
                typeof navigator !== 'undefined' ? !navigator.onLine : false
            );

            // New SW version waiting to activate
            const [updateAvailable, setUpdateAvailable] = useState(false);

            // Reference to the waiting SW for update flow
            const waitingSwRef = useRef(null);

            // Reference to track if we've registered
            const registeredRef = useRef(false);

            useEffect(() => {
                // Skip if unsupported or already registered
                if (swStatus === 'unsupported' || registeredRef.current) {
                    return;
                }

                // Setup online/offline listeners
                const handleOnline = () => {
                    setIsOffline(false);
                    console.log('[SW] Network status: online');
                };
                const handleOffline = () => {
                    setIsOffline(true);
                    console.log('[SW] Network status: offline');
                };

                window.addEventListener('online', handleOnline);
                window.addEventListener('offline', handleOffline);

                // Register service worker
                const registerSW = async () => {
                    try {
                        registeredRef.current = true;
                        const registration = await navigator.serviceWorker.register('./sw.js');
                        console.log(`[SW] Registered: ${registration.scope}`);

                        // Check initial state
                        if (registration.active) {
                            setSwStatus('active');
                            // Log cache info if available
                            if ('caches' in window) {
                                const cacheNames = await caches.keys();
                                console.log(`[SW] Cache populated: ${cacheNames.length} caches`);
                            }
                        }

                        // Handle SW updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            console.log('[SW] Update found, new worker installing...');
                            setSwStatus('installing');

                            newWorker.addEventListener('statechange', () => {
                                console.log(`[SW] Worker state changed: ${newWorker.state}`);

                                if (newWorker.state === 'installed') {
                                    if (registration.active) {
                                        // New SW waiting, current one active
                                        setSwStatus('waiting');
                                        setUpdateAvailable(true);
                                        waitingSwRef.current = newWorker;
                                        console.log('[SW] Update available');
                                    } else {
                                        // First install complete
                                        setSwStatus('active');
                                        console.log('[SW] First install complete');
                                    }
                                } else if (newWorker.state === 'activated') {
                                    setSwStatus('active');
                                    setUpdateAvailable(false);
                                    waitingSwRef.current = null;
                                }
                            });
                        });

                        // Handle controller changes (when new SW takes over)
                        navigator.serviceWorker.addEventListener('controllerchange', () => {
                            console.log('[SW] Controller changed, reloading...');
                            // Reload to use new SW
                            window.location.reload();
                        });

                        // Check if there's already a waiting worker (e.g., from previous page load)
                        if (registration.waiting) {
                            setSwStatus('waiting');
                            setUpdateAvailable(true);
                            waitingSwRef.current = registration.waiting;
                            console.log('[SW] Update available (from previous load)');
                        }

                    } catch (error) {
                        console.error('[SW] Registration failed:', error);
                        setSwStatus('error');
                        registeredRef.current = false;
                    }
                };

                registerSW();

                return () => {
                    window.removeEventListener('online', handleOnline);
                    window.removeEventListener('offline', handleOffline);
                };
            }, [swStatus]);

            // Function to apply the waiting update
            const applyUpdate = useCallback(() => {
                if (waitingSwRef.current) {
                    console.log('[SW] Applying update...');
                    // Tell the waiting SW to skip waiting
                    waitingSwRef.current.postMessage({ type: 'SKIP_WAITING' });
                    // The controllerchange event will trigger a reload
                }
            }, []);

            return {
                swStatus,
                isOffline,
                updateAvailable,
                applyUpdate
            };
        }

        // ============================================
        // useInstallPrompt Hook - Story 6-2
        // PWA Install Prompt State & Actions
        // ============================================
        function useInstallPrompt() {
            // Can the app be installed?
            const [canInstall, setCanInstall] = useState(false);

            // Has the app already been installed (standalone mode)?
            const [isInstalled, setIsInstalled] = useState(() => {
                // Check localStorage first for persisted state
                try {
                    const stored = localStorage.getItem('mp3_8d_is_installed');
                    if (stored === 'true') return true;
                } catch {}
                // Check if running in standalone mode
                if (typeof window !== 'undefined' && window.matchMedia) {
                    return window.matchMedia('(display-mode: standalone)').matches;
                }
                return false;
            });

            // Deferred install prompt event
            const installPromptDeferredRef = useRef(null);

            // Track if prompt has been shown this session (for telemetry)
            const promptShownRef = useRef(false);

            // Track if user dismissed the prompt (for "Not now" cooldown)
            const [promptDismissed, setPromptDismissed] = useState(() => {
                try {
                    const dismissedAt = localStorage.getItem('mp3_8d_install_dismissed');
                    if (dismissedAt) {
                        // Show again after 24 hours
                        const dismissedTime = parseInt(dismissedAt, 10);
                        const oneDayMs = 24 * 60 * 60 * 1000;
                        return Date.now() - dismissedTime < oneDayMs;
                    }
                } catch {}
                return false;
            });

            // Log install event to SessionLogging
            const logInstallEvent = useCallback((eventType, metadata = {}) => {
                const event = {
                    type: eventType,
                    timestamp: Date.now(),
                    userAgent: navigator.userAgent,
                    platform: /Mobi|Android/i.test(navigator.userAgent) ? 'mobile' : 'desktop',
                    ...metadata
                };

                console.log(`[PWA] ${eventType}`, event);

                // Store in SessionLogging IndexedDB
                if (typeof SessionLogging !== 'undefined' && SessionLogging.addSession) {
                    SessionLogging.addSession({
                        ...event,
                        profileId: 'pwa_install',
                        presetId: null,
                        ritualUsed: false
                    }).catch(err => console.warn('[PWA] Failed to log event:', err));
                }
            }, []);

            useEffect(() => {
                // Check standalone mode via media query
                const standaloneQuery = window.matchMedia('(display-mode: standalone)');

                const handleDisplayModeChange = (e) => {
                    if (e.matches) {
                        setIsInstalled(true);
                        setCanInstall(false);
                        localStorage.setItem('mp3_8d_is_installed', 'true');
                        console.log('[PWA] Running in standalone mode');
                        logInstallEvent('APP_INSTALLED');
                    }
                };

                // Check initial state
                if (standaloneQuery.matches) {
                    setIsInstalled(true);
                    setCanInstall(false);
                    localStorage.setItem('mp3_8d_is_installed', 'true');
                    console.log('[PWA] Running in standalone mode');
                }

                standaloneQuery.addEventListener('change', handleDisplayModeChange);

                // Capture beforeinstallprompt event
                const handleBeforeInstallPrompt = (e) => {
                    // Prevent the mini-infobar from appearing on mobile
                    e.preventDefault();
                    // Store the event for later use
                    installPromptDeferredRef.current = e;
                    setCanInstall(true);
                    console.log('[PWA] Install prompt available');
                };

                window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);

                // Handle app installed event
                const handleAppInstalled = () => {
                    setIsInstalled(true);
                    setCanInstall(false);
                    installPromptDeferredRef.current = null;
                    localStorage.setItem('mp3_8d_is_installed', 'true');
                    console.log('[PWA] App was installed');
                };

                window.addEventListener('appinstalled', handleAppInstalled);

                return () => {
                    standaloneQuery.removeEventListener('change', handleDisplayModeChange);
                    window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
                    window.removeEventListener('appinstalled', handleAppInstalled);
                };
            }, [logInstallEvent]);

            // Show the native install prompt
            const showInstallPrompt = useCallback(async () => {
                if (!installPromptDeferredRef.current) {
                    console.log('[PWA] No install prompt available');
                    return 'unavailable';
                }

                // Show the prompt
                installPromptDeferredRef.current.prompt();

                // Wait for user choice
                const { outcome } = await installPromptDeferredRef.current.userChoice;
                console.log(`[PWA] User choice: ${outcome}`);

                // Log the outcome
                if (outcome === 'accepted') {
                    logInstallEvent('INSTALL_ACCEPTED');
                } else {
                    logInstallEvent('INSTALL_DISMISSED');
                }

                // Clear the deferred prompt - it can only be used once
                installPromptDeferredRef.current = null;
                setCanInstall(false);

                return outcome;
            }, [logInstallEvent]);

            // Dismiss the install prompt temporarily
            const dismissInstallPrompt = useCallback(() => {
                setPromptDismissed(true);
                localStorage.setItem('mp3_8d_install_dismissed', String(Date.now()));
                logInstallEvent('INSTALL_DISMISSED', { source: 'in_app_dismiss' });
                console.log('[PWA] Install prompt dismissed');
            }, [logInstallEvent]);

            // Log when prompt is first shown
            const markPromptShown = useCallback(() => {
                if (!promptShownRef.current) {
                    promptShownRef.current = true;
                    logInstallEvent('INSTALL_PROMPT_SHOWN');
                }
            }, [logInstallEvent]);

            return {
                canInstall: canInstall && !isInstalled && !promptDismissed,
                isInstalled,
                showInstallPrompt,
                dismissInstallPrompt,
                markPromptShown,
                logInstallEvent
            };
        }

        // ============================================
        // OfflineBanner Component - Story 6-1
        // Shows offline/online status notifications
        // ============================================
        function OfflineBanner({ isOffline, reducedMotion }) {
            const [showBanner, setShowBanner] = useState(false);
            const [wasOffline, setWasOffline] = useState(false);
            const [showOnlineMessage, setShowOnlineMessage] = useState(false);
            const dismissTimeoutRef = useRef(null);

            useEffect(() => {
                if (isOffline) {
                    setShowBanner(true);
                    setWasOffline(true);
                    setShowOnlineMessage(false);
                    // Clear any pending dismiss
                    if (dismissTimeoutRef.current) {
                        clearTimeout(dismissTimeoutRef.current);
                    }
                } else if (wasOffline) {
                    // Was offline, now online - show "Back online" message
                    setShowOnlineMessage(true);
                    // Auto-dismiss after 3 seconds
                    dismissTimeoutRef.current = setTimeout(() => {
                        setShowBanner(false);
                        setShowOnlineMessage(false);
                        setWasOffline(false);
                    }, 3000);
                }

                return () => {
                    if (dismissTimeoutRef.current) {
                        clearTimeout(dismissTimeoutRef.current);
                    }
                };
            }, [isOffline, wasOffline]);

            const handleDismiss = () => {
                setShowBanner(false);
                setShowOnlineMessage(false);
                if (dismissTimeoutRef.current) {
                    clearTimeout(dismissTimeoutRef.current);
                }
            };

            if (!showBanner) return null;

            return (
                <div
                    className={`offline-banner ${showOnlineMessage ? 'online' : ''} ${reducedMotion ? 'no-motion' : ''}`}
                    role="alert"
                    aria-live="assertive"
                >
                    <span className="offline-banner-icon" aria-hidden="true">
                        {showOnlineMessage ? '✓' : '📡'}
                    </span>
                    <span className="offline-banner-text">
                        {showOnlineMessage
                            ? "You're back online!"
                            : "You're offline. Cached content available."}
                    </span>
                    <button
                        className="offline-banner-dismiss"
                        onClick={handleDismiss}
                        aria-label="Dismiss notification"
                    >
                        ✕
                    </button>
                </div>
            );
        }

        // ============================================
        // UpdateToast Component - Story 6-1
        // Shows when a SW update is available
        // ============================================
        function UpdateToast({ isVisible, onUpdate, onDismiss, reducedMotion }) {
            const [dismissed, setDismissed] = useState(false);

            useEffect(() => {
                if (isVisible) {
                    setDismissed(false);
                }
            }, [isVisible]);

            const handleDismiss = () => {
                setDismissed(true);
                if (onDismiss) onDismiss();
            };

            if (!isVisible || dismissed) return null;

            return (
                <div
                    className={`update-toast ${reducedMotion ? 'no-motion' : ''}`}
                    role="alertdialog"
                    aria-labelledby="update-heading"
                    aria-describedby="update-description"
                >
                    <span className="update-toast-icon" aria-hidden="true">🔄</span>
                    <div className="update-toast-text">
                        <strong id="update-heading">Update available</strong>
                        <span id="update-description">Click to refresh and get the latest version.</span>
                    </div>
                    <div className="update-toast-actions">
                        <button
                            type="button"
                            className="update-btn"
                            onClick={onUpdate}
                        >
                            Update
                        </button>
                        <button
                            type="button"
                            className="update-dismiss-btn"
                            onClick={handleDismiss}
                            aria-label="Dismiss update notification"
                        >
                            Later
                        </button>
                    </div>
                </div>
            );
        }

        // ============================================
        // InstallPrompt Component - Story 6-2
        // PWA Install prompt UI with accessibility
        // ============================================
        function InstallPrompt({
            canInstall,
            onInstall,
            onDismiss,
            onShow,
            reducedMotion
        }) {
            const promptRef = useRef(null);
            const [installing, setInstalling] = useState(false);

            // Mark prompt as shown when it first renders
            useEffect(() => {
                if (canInstall && onShow) {
                    onShow();
                }
            }, [canInstall, onShow]);

            // Focus management when prompt opens
            useEffect(() => {
                if (canInstall && promptRef.current) {
                    promptRef.current.focus();
                }
            }, [canInstall]);

            const handleInstall = async () => {
                setInstalling(true);
                try {
                    await onInstall();
                } finally {
                    setInstalling(false);
                }
            };

            if (!canInstall) return null;

            return (
                <div
                    ref={promptRef}
                    className={`install-prompt ${reducedMotion ? 'no-motion' : ''}`}
                    role="dialog"
                    aria-labelledby="install-heading"
                    aria-describedby="install-description"
                    tabIndex={-1}
                >
                    <div className="install-prompt-icon" aria-hidden="true">
                        <img
                            src="./icons/icon-192.png"
                            alt=""
                            width="48"
                            height="48"
                            onError={(e) => { e.target.style.display = 'none'; }}
                        />
                    </div>
                    <div className="install-prompt-content">
                        <strong id="install-heading" className="install-prompt-title">
                            8D Audio
                        </strong>
                        <span id="install-description" className="install-prompt-text">
                            Install for quick access
                        </span>
                    </div>
                    <div className="install-prompt-actions">
                        <button
                            type="button"
                            className="install-btn"
                            onClick={handleInstall}
                            disabled={installing}
                        >
                            {installing ? 'Installing...' : 'Install'}
                        </button>
                        <button
                            type="button"
                            className="install-dismiss-btn"
                            onClick={onDismiss}
                            aria-label="Dismiss install prompt"
                        >
                            Not now
                        </button>
                    </div>
                </div>
            );
        }

        // ============================================
        // SafariInstallInstructions Component - Story 6-2
        // Manual A2HS instructions for Safari users
        // ============================================
        function SafariInstallInstructions({ reducedMotion }) {
            // Detect Safari and check if beforeinstallprompt is NOT supported
            const [showInstructions, setShowInstructions] = useState(() => {
                // Check localStorage for dismissal
                try {
                    const dismissed = localStorage.getItem('mp3_8d_safari_install_dismissed');
                    if (dismissed === 'true') return false;
                } catch {}

                // Check if we're on Safari and beforeinstallprompt is not supported
                if (typeof window === 'undefined') return false;

                const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
                const noBeforeInstallPrompt = !('onbeforeinstallprompt' in window);
                const notStandalone = !window.matchMedia('(display-mode: standalone)').matches;

                return isSafari && noBeforeInstallPrompt && notStandalone;
            });

            // Also check if already installed
            const [isInstalled] = useState(() => {
                try {
                    const stored = localStorage.getItem('mp3_8d_is_installed');
                    if (stored === 'true') return true;
                } catch {}
                if (typeof window !== 'undefined' && window.matchMedia) {
                    return window.matchMedia('(display-mode: standalone)').matches;
                }
                return false;
            });

            const handleDismiss = () => {
                setShowInstructions(false);
                try {
                    localStorage.setItem('mp3_8d_safari_install_dismissed', 'true');
                } catch {}
            };

            if (!showInstructions || isInstalled) return null;

            // Detect iOS vs macOS Safari
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);

            return (
                <div
                    className={`safari-instructions ${reducedMotion ? 'no-motion' : ''}`}
                    role="region"
                    aria-label="Installation instructions for Safari"
                >
                    <div className="safari-instructions-icon" aria-hidden="true">
                        📲
                    </div>
                    <div className="safari-instructions-content">
                        <strong className="safari-instructions-title">
                            Install 8D Audio
                        </strong>
                        <p className="safari-instructions-text">
                            {isIOS
                                ? 'To install: Tap the Share button, then "Add to Home Screen"'
                                : 'To install: Click Share in Safari\'s menu, then "Add to Dock"'}
                        </p>
                        <div className="safari-share-hint" aria-hidden="true">
                            {isIOS ? (
                                <span className="safari-share-icon">⬆</span>
                            ) : (
                                <span className="safari-share-icon">↗</span>
                            )}
                            <span>→ Add to {isIOS ? 'Home Screen' : 'Dock'}</span>
                        </div>
                    </div>
                    <button
                        type="button"
                        className="safari-instructions-dismiss"
                        onClick={handleDismiss}
                        aria-label="Dismiss installation instructions"
                    >
                        Got it
                    </button>
                </div>
            );
        }

        // ============================================
        // OfflineSettings Component - Story 6-1
        // Audio cache consent toggle with storage usage
        // Also includes PWA install option for mobile users
        // ============================================
        function OfflineSettings({
            audioCacheConsent,
            onConsentChange,
            cacheStorageUsed,
            onClearCache,
            // PWA install props
            canInstall,
            isInstalled,
            onInstall
        }) {
            // Detect platform for install instructions
            const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            const isAndroid = /Android/i.test(navigator.userAgent);

            // Check if native install prompt is available
            const hasNativeInstall = 'onbeforeinstallprompt' in window;

            // Show install section on mobile when not installed
            const showInstallSection = isMobile && !isInstalled;
            // Format bytes to human readable
            const formatBytes = (bytes) => {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
            };

            // Estimate max storage (simplified - actual quota varies by browser/device)
            const estimatedMaxStorage = 100 * 1024 * 1024; // 100 MB estimate for audio
            const storagePercent = Math.min(100, (cacheStorageUsed / estimatedMaxStorage) * 100);

            return (
                <div className="offline-settings">
                    <h4 className="offline-settings-title">Offline Settings</h4>

                    <div className="offline-cache-toggle">
                        <label>
                            <input
                                type="checkbox"
                                checked={audioCacheConsent}
                                onChange={(e) => onConsentChange(e.target.checked)}
                                aria-describedby="audio-cache-help"
                            />
                            <span className="offline-cache-toggle-text">Cache audio for offline</span>
                        </label>
                    </div>

                    <p id="audio-cache-help" className="offline-cache-help">
                        Enable to cache audio files for offline playback (uses device storage)
                    </p>

                    {audioCacheConsent && (
                        <div className="offline-storage-usage">
                            <span className="offline-storage-label">Storage used:</span>
                            <span className="offline-storage-value">{formatBytes(cacheStorageUsed)}</span>

                            <div className="offline-storage-bar">
                                <div
                                    className="offline-storage-bar-fill"
                                    style={{ width: `${storagePercent}%` }}
                                />
                            </div>

                            {cacheStorageUsed > 0 && (
                                <button
                                    type="button"
                                    className="offline-clear-btn"
                                    onClick={onClearCache}
                                >
                                    Clear audio cache
                                </button>
                            )}
                        </div>
                    )}

                    {/* Install App Section - for mobile users */}
                    {showInstallSection && (
                        <div className="install-app-section">
                            <h4 className="install-app-title">📲 Install App</h4>

                            {/* Native install available (Chrome/Edge on Android) */}
                            {canInstall && hasNativeInstall && (
                                <div className="install-app-native">
                                    <p className="install-app-text">
                                        Add to your home screen for quick access
                                    </p>
                                    <button
                                        type="button"
                                        className="install-app-btn"
                                        onClick={onInstall}
                                    >
                                        Install App
                                    </button>
                                </div>
                            )}

                            {/* Manual instructions for iOS Safari */}
                            {isIOS && (
                                <div className="install-app-manual">
                                    <p className="install-app-text">
                                        To install on your {isIOS ? 'iPhone/iPad' : 'device'}:
                                    </p>
                                    <ol className="install-app-steps">
                                        <li>Tap the <strong>Share</strong> button <span aria-hidden="true">⬆</span></li>
                                        <li>Scroll down and tap <strong>"Add to Home Screen"</strong></li>
                                        <li>Tap <strong>Add</strong> in the top right</li>
                                    </ol>
                                </div>
                            )}

                            {/* Manual instructions for Android browsers without native install */}
                            {isAndroid && !canInstall && (
                                <div className="install-app-manual">
                                    <p className="install-app-text">
                                        To install on your Android device:
                                    </p>
                                    <ol className="install-app-steps">
                                        <li>Tap the <strong>menu</strong> (⋮) in your browser</li>
                                        <li>Tap <strong>"Add to Home screen"</strong> or <strong>"Install app"</strong></li>
                                    </ol>
                                </div>
                            )}
                        </div>
                    )}
                </div>
            );
        }

function App() {
            const defaultMode = MODE_LIBRARY[0];

            // Service Worker state (Story 6-1)
            const { swStatus, isOffline, updateAvailable, applyUpdate } = useServiceWorker();

            // PWA Install Prompt state (Story 6-2)
            const {
                canInstall,
                isInstalled,
                showInstallPrompt,
                dismissInstallPrompt,
                markPromptShown,
                logInstallEvent
            } = useInstallPrompt();

            const [playlist, setPlaylist] = useState([]);
            const [currentTrackIndex, setCurrentTrackIndex] = useState(null);
            // Track ratings: { trackId: { modeId: 'boost'|'neutral'|'remove' } }
            // Persisted to localStorage, keyed by track name since URLs can change
            const [trackRatings, setTrackRatings] = useState(() => {
                try {
                    const saved = localStorage.getItem('mpe_8d_track_ratings');
                    return saved ? JSON.parse(saved) : {};
                } catch { return {}; }
            });
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentTime, setCurrentTime] = useState(0);
            const [duration, setDuration] = useState(0);
            const [volume, setVolume] = useState(0.7);
            const [showFileWarning, setShowFileWarning] = useState(false);
            
            // 8D Effect Controls
            const [speed, setSpeed] = useState(defaultMode.preset.speed);
            const [intensity, setIntensity] = useState(defaultMode.preset.intensity);
            const [spatialDepth, setSpatialDepth] = useState(defaultMode.preset.spatialDepth);
            const [movementPattern, setMovementPattern] = useState(defaultMode.preset.movement);
            
            // Additional Effects
            const [binauralEnabled, setBinauralEnabled] = useState(defaultMode.preset.binaural.enabled);
            const [binauralFreq, setBinauralFreq] = useState(defaultMode.preset.binaural.freq);
            const [noiseType, setNoiseType] = useState(defaultMode.preset.noise.type);
            const [noiseVolume, setNoiseVolume] = useState(defaultMode.preset.noise.volume);
            const [visualWaveGain, setVisualWaveGain] = useState(defaultMode.preset.noise.volume);

            // EQ Settings (dB values, -12 to +12) - Load from saved calibration
            const [eqBass, setEqBass] = useState(() => {
                try {
                    const saved = localStorage.getItem('mpe_8d_calibration');
                    if (saved) {
                        const data = JSON.parse(saved);
                        return data.eq?.bass ?? 0;
                    }
                } catch {}
                return 0;
            });
            const [eqMid, setEqMid] = useState(() => {
                try {
                    const saved = localStorage.getItem('mpe_8d_calibration');
                    if (saved) {
                        const data = JSON.parse(saved);
                        return data.eq?.mid ?? 0;
                    }
                } catch {}
                return 0;
            });
            const [eqTreble, setEqTreble] = useState(() => {
                try {
                    const saved = localStorage.getItem('mpe_8d_calibration');
                    if (saved) {
                        const data = JSON.parse(saved);
                        return data.eq?.treble ?? 0;
                    }
                } catch {}
                return 0;
            });
            const [eqClarity, setEqClarity] = useState(() => {
                try {
                    const saved = localStorage.getItem('mpe_8d_calibration');
                    if (saved) {
                        const data = JSON.parse(saved);
                        return data.eq?.clarity ?? 0;
                    }
                } catch {}
                return 0;
            });

            // UI + Ritual
            const [darkMode, setDarkMode] = useState(false);
            const [highContrast, setHighContrast] = useState(false);
            const [urlInput, setUrlInput] = useState('');
            const [showVisualizer, setShowVisualizer] = useState(true);
            const [visualizerFullscreen, setVisualizerFullscreen] = useState(false);
            const [visualizerType, setVisualizerType] = useState('bars'); // bars, waveform, circular, mirrored, particles

            // Timer states
            const [activeTimerTab, setActiveTimerTab] = useState('sleep'); // 'sleep' or 'pomodoro'

            // Sleep timer state
            const [sleepTimerActive, setSleepTimerActive] = useState(false);
            const [sleepTimerSeconds, setSleepTimerSeconds] = useState(0);
            const [sleepTimerDuration, setSleepTimerDuration] = useState(60 * 60); // Default 1 hour

            // Pomodoro timer state
            const [pomodoroActive, setPomodoroActive] = useState(false);
            const [pomodoroPhase, setPomodoroPhase] = useState('work'); // 'work' or 'break'
            const [pomodoroSeconds, setPomodoroSeconds] = useState(0);
            const [pomodoroWorkDuration, setPomodoroWorkDuration] = useState(25); // minutes
            const [pomodoroBreakDuration, setPomodoroBreakDuration] = useState(5); // minutes
            const [pomodoroCycles, setPomodoroCycles] = useState(0);
            const [pomodoroBreakAction, setPomodoroBreakAction] = useState('pause'); // 'pause', 'energize', 'calm'

            // Playlist search
            const [playlistSearch, setPlaylistSearch] = useState('');

            // Saved playlists
            const [savedPlaylists, setSavedPlaylists] = useState(() => {
                try {
                    const saved = localStorage.getItem('mpe_8d_saved_playlists');
                    return saved ? JSON.parse(saved) : [];
                } catch { return []; }
            });
            const [showPlaylistModal, setShowPlaylistModal] = useState(false);
            const [newPlaylistName, setNewPlaylistName] = useState('');

            // Mobile navigation
            const [mobileView, setMobileView] = useState('timer'); // 'timer', 'queue', 'settings'
            const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
            const [vizMenuOpen, setVizMenuOpen] = useState(false);

            const [modeIndex, setModeIndex] = useState(0);
            const [focusedModeIndex, setFocusedModeIndex] = useState(0);
            const [activePresetId, setActivePresetId] = useState('focus'); // Story 3-1: Track active preset by ID
            const [ritualStatus, setRitualStatus] = useState('idle');
            const [ritualCountdown, setRitualCountdown] = useState(HERO_BREATH_DURATION);
            const [breathingPhase, setBreathingPhase] = useState(''); // 'inhale', 'hold-in', 'exhale', 'hold-out'
            const [skipRitualPref, setSkipRitualPref] = useState(() => {
                try {
                    return localStorage.getItem('skipBreathingRitual') === 'true';
                } catch {
                    return false;
                }
            });
            const [heroMessage, setHeroMessage] = useState('Select a ritual to begin');
            const [a11yAnnouncement, setA11yAnnouncement] = useState('');
            const [needsAudio, setNeedsAudio] = useState(false);
            const [intakeTab, setIntakeTab] = useState('files');
            // Derived from useServiceWorker hook - no duplicate state needed
            const isOnline = !isOffline;
            const [reducedMotion, setReducedMotion] = useState(false);
            const [dragActive, setDragActive] = useState(false);
            const [audioElementToken, setAudioElementToken] = useState(0);
            
            // Story 3-2: Advanced Controls UI state
            const [isAdvancedControlsExpanded, setIsAdvancedControlsExpanded] = useState(false);
            const [sensorLocked, setSensorLocked] = useState(false); // Epic 5 adaptive mode

            // Story 5-1: Sensor Bridge - Capability Detection & Consent UI
            const [bluetoothSupported, setBluetoothSupported] = useState(false);
            const [serialSupported, setSerialSupported] = useState(false);
            const [sensorStatus, setSensorStatus] = useState('idle'); // "idle" | "scanning" | "connecting" | "connected" | "error"
            const [connectedDevice, setConnectedDevice] = useState(null); // { id, name, type } | null
            const [sensorError, setSensorError] = useState(null); // { code, message } | null
            const [consentedDevices, setConsentedDevices] = useState([]); // Array of consent records
            const [showSensorConsentModal, setShowSensorConsentModal] = useState(false);
            const [pendingSensorType, setPendingSensorType] = useState(null); // 'bluetooth' | 'serial' | null
            const [showForgetDeviceModal, setShowForgetDeviceModal] = useState(false);
            const [deviceToForget, setDeviceToForget] = useState(null);
            const [skipSensorConsent, setSkipSensorConsent] = useState(() => {
                try {
                    return localStorage.getItem('mpe_8d_skip_sensor_consent') === 'true';
                } catch {
                    return false;
                }
            });
            const connectedDeviceRef = useRef(null); // For cleanup during disconnect
            const bluetoothDeviceRef = useRef(null); // Web Bluetooth device reference
            const serialPortRef = useRef(null); // Web Serial port reference

            // Story 5-2: Heart Rate Subscription & Threshold Engine
            const [currentHR, setCurrentHR] = useState(null); // Current heart rate in BPM
            const [hrHistory, setHrHistory] = useState([]); // Rolling 60-second history buffer
            const [hrThreshold, setHrThreshold] = useState(() => {
                try {
                    const saved = localStorage.getItem('mp3_8d_hr_threshold');
                    return saved ? parseInt(saved, 10) : 85;
                } catch {
                    return 85;
                }
            });
            // Story 5-3: Auto-adjust toggle (AC5)
            const [autoAdjustEnabled, setAutoAdjustEnabled] = useState(() => {
                try {
                    const saved = localStorage.getItem('mp3_8d_auto_adjust_enabled');
                    return saved === 'true';
                } catch {
                    return false;
                }
            });
            // Story 6-1: Audio cache consent for offline playback (AC7)
            const [audioCacheConsent, setAudioCacheConsent] = useState(() => {
                try {
                    const saved = localStorage.getItem('mp3_8d_audio_cache_consent');
                    return saved === 'true';
                } catch {
                    return false; // Default: OFF (explicit opt-in required)
                }
            });
            // Story 6-1: Storage usage for audio cache
            const [cacheStorageUsed, setCacheStorageUsed] = useState(0);
            // Story 6-1: Set of cached audio URLs for offline indicator (AC8)
            const [cachedAudioUrls, setCachedAudioUrls] = useState(new Set());
            const [isSimulating, setIsSimulating] = useState(false); // Sensor simulator active
            const [showSuggestionToast, setShowSuggestionToast] = useState(false);
            const [suggestionToastData, setSuggestionToastData] = useState(null);
            const hrCharacteristicRef = useRef(null); // BLE HR characteristic reference
            const hrHistoryRef = useRef([]); // Ref for history buffer (for rule engine access)
            const sensorRuleEngineRef = useRef(null); // Rule engine interval ID
            const lastThresholdTriggerRef = useRef(0); // Cooldown tracking (timestamp)
            const consecutiveExceededRef = useRef(0); // Consecutive threshold exceedances
            const simulatorIntervalRef = useRef(null); // Simulator interval ID
            const reconnectAttemptsRef = useRef(0); // Reconnection attempt counter
            const isManualDisconnectRef = useRef(false); // Track if disconnect was manual

            // Story 3-3: Custom Preset Management
            const [showSavePresetDialog, setShowSavePresetDialog] = useState(false);
            const [editingPreset, setEditingPreset] = useState(null);
            const [allPresets, setAllPresets] = useState([]);

            // Spatial Audio Tuner (debugging tool)
            const [showSpatialTuner, setShowSpatialTuner] = useState(false);
            const spatialTunerActiveRef = useRef(false);

            // Calibration Wizard - first run prompt
            const [showFirstRunPrompt, setShowFirstRunPrompt] = useState(false);
            const [hasRunCalibration, setHasRunCalibration] = useState(() => {
                try {
                    return localStorage.getItem('mpe_8d_calibration') !== null;
                } catch {
                    return false;
                }
            });
            const [calibrationDismissed, setCalibrationDismissed] = useState(() => {
                try {
                    return localStorage.getItem('mpe_8d_calibration_dismissed') === 'true';
                } catch {
                    return false;
                }
            });

            // File intake notifications
            const [toastMessage, setToastMessage] = useState('');
            const [toastType, setToastType] = useState('info');
            const [isProcessingFiles, setIsProcessingFiles] = useState(false);
            const [isValidatingUrl, setIsValidatingUrl] = useState(false);

            const showToast = React.useCallback((message, type = 'info') => {
                if (toastTimeoutRef.current) {
                    clearTimeout(toastTimeoutRef.current);
                }

                setToastMessage(message);
                setToastType(type);
                setA11yAnnouncement(message);

                toastTimeoutRef.current = setTimeout(() => {
                    setToastMessage('');
                    toastTimeoutRef.current = null;
                }, 5000);
            }, []);

            const [activeSessionId, setActiveSessionId] = useState(null);
            const [isClearingSessions, setIsClearingSessions] = useState(false);
            const [isTrimmingSessions, setIsTrimmingSessions] = useState(false);

            // Story 4-2: Check-in modal state
            const [showCheckInModal, setShowCheckInModal] = useState(false);
            const [checkInSessionId, setCheckInSessionId] = useState(null);
            const previousFocusRef = useRef(null);

            // Story 4-3: Insights dashboard state
            const [insightsDateRange, setInsightsDateRange] = useState('7d');
            const [insightsSessions, setInsightsSessions] = useState([]);

            const selectedMode = MODE_LIBRARY[modeIndex];
            const nowPlayingTrack = currentTrackIndex !== null ? playlist[currentTrackIndex] : null;

            // Parse track name for artist/title (supports "Artist - Title" format)
            const parseTrackInfo = (track) => {
                if (!track) {
                    return { title: 'No track selected', artist: null, source: null };
                }

                const name = track.name || 'Unknown Track';
                const source = track.source || 'unknown';

                // Common patterns: "Artist - Title", "Artist — Title", "Artist – Title"
                const separators = [' - ', ' — ', ' – ', ' _ '];
                for (const sep of separators) {
                    if (name.includes(sep)) {
                        const parts = name.split(sep);
                        if (parts.length >= 2) {
                            return {
                                artist: parts[0].trim(),
                                title: parts.slice(1).join(sep).trim(),
                                source
                            };
                        }
                    }
                }

                // No artist found, just use the name as title
                return { title: name, artist: null, source };
            };

            const trackInfo = parseTrackInfo(nowPlayingTrack);

            // Get mode-specific album art icon
            const getAlbumArtIcon = () => {
                const modeIcons = {
                    focus: '🎯',
                    calm: '🌊',
                    energize: '⚡',
                    'apd-friendly': '🔮'
                };
                return modeIcons[activePresetId] || '🎵';
            };

            const playlistMinutes = Math.max(0, Math.floor(playlist.length * 3.5));
            const focusConfidence = Math.min(100, 60 + playlist.length * 8);
            const streakMinutes = Math.min(21, playlist.length * 2);
            
            // Refs
            const audioContextRef = useRef(null);
            const sourceNodeRef = useRef(null);
            const gainNodeRef = useRef(null);
            const audioElementRef = useRef(null);
            const audioEndedHandlerRef = useRef(null);
            const currentBlobUrlRef = useRef(null);
            const fileInputRef = useRef(null);
            const canvasRef = useRef(null);
            const mobileCanvasRef = useRef(null);
            const fullscreenCanvasRef = useRef(null);
            const analyserRef = useRef(null);
            const animationFrameRef = useRef(null);
            const rotationIntervalRef = useRef(null);
            const rotationNodesRef = useRef(null);
            const eqNodesRef = useRef(null); // EQ filters: bass, mid, treble, clarity
            const modeRefs = useRef([]);
            const dropZoneRef = useRef(null);
            const ritualTimeoutRef = useRef(null);
            const ritualIntervalRef = useRef(null);
            const breathingPhaseIntervalRef = useRef(null);
            const gainChainRef = useRef(null);
            const binauralNodesRef = useRef(null);
            const noiseNodesRef = useRef(null);
            const pausedBinauralGainRef = useRef(null);
            const pausedNoiseGainRef = useRef(null);
            const visualWaveGainRef = useRef(visualWaveGain);
            const visualizerTypeRef = useRef(visualizerType);
            const playlistRef = useRef(playlist);
            const currentTrackIndexRef = useRef(currentTrackIndex);
            const playNextRef = useRef(() => {});
            const prevPlaylistLengthRef = useRef(playlist.length);
            const urlValidationControllerRef = useRef(null);
            const toastTimeoutRef = useRef(null);
            const activeSessionIdRef = useRef(null);
            const sessionRitualFlagRef = useRef(false);
            const sleepTimerIntervalRef = useRef(null);
            const pomodoroIntervalRef = useRef(null);
            const previousModeRef = useRef(null); // For restoring mode after pomodoro break

            // Audio parameter refs - allows rotation interval to read current values
            const speedRef = useRef(speed);
            const intensityRef = useRef(intensity);
            const spatialDepthRef = useRef(spatialDepth);
            const movementPatternRef = useRef(movementPattern);

            const cleanupBlobUrl = () => {
                if (currentBlobUrlRef.current) {
                    URL.revokeObjectURL(currentBlobUrlRef.current);
                    currentBlobUrlRef.current = null;
                }
            };

            const tearDownBinauralNodes = () => {
                if (binauralNodesRef.current) {
                    binauralNodesRef.current.stop();
                    binauralNodesRef.current = null;
                }
            };

            const tearDownNoiseNodes = () => {
                if (noiseNodesRef.current) {
                    noiseNodesRef.current.stop();
                    noiseNodesRef.current = null;
                }
            };

            const disposeAudioGraph = () => {
                if (rotationIntervalRef.current) {
                    clearInterval(rotationIntervalRef.current);
                    rotationIntervalRef.current = null;
                }
                rotationNodesRef.current = null;

                tearDownBinauralNodes();
                tearDownNoiseNodes();

                if (animationFrameRef.current) {
                    cancelAnimationFrame(animationFrameRef.current);
                    animationFrameRef.current = null;
                }

                if (gainChainRef.current) {
                    gainChainRef.current.disconnect();
                    gainChainRef.current = null;
                }
                gainNodeRef.current = null;
                analyserRef.current = null;

                if (sourceNodeRef.current) {
                    try {
                        sourceNodeRef.current.disconnect();
                    } catch (error) {
                        console.error('Error disconnecting source node:', error);
                    }
                    sourceNodeRef.current = null;
                }
            };

            const teardownAudioElement = () => {
                if (audioElementRef.current) {
                    const audio = audioElementRef.current;
                    if (audioEndedHandlerRef.current) {
                        audio.removeEventListener('ended', audioEndedHandlerRef.current);
                        audioEndedHandlerRef.current = null;
                    }
                    audio.pause();
                    audio.removeAttribute('src');
                    audio.load();
                    audioElementRef.current = null;
                }
                cleanupBlobUrl();
            };

            const prepareAudioElement = () => {
                teardownAudioElement();
                const audio = new Audio();
                audio.preload = 'auto';
                audio.crossOrigin = 'anonymous';
                audioElementRef.current = audio;
                audioEndedHandlerRef.current = () => {
                    cleanupBlobUrl();
                    endSession(false);
                    if (typeof playNextRef.current === 'function') {
                        playNextRef.current({ shouldEndActiveSession: false });
                    }
                };
                audio.addEventListener('ended', audioEndedHandlerRef.current);
                setAudioElementToken(Date.now());
                return audio;
            };

            const syncBinauralChain = () => {
                tearDownBinauralNodes();
                if (!binauralEnabled || !audioContextRef.current || !gainChainRef.current) {
                    return;
                }
                binauralNodesRef.current = AudioEngine.createBinauralNodes(
                    audioContextRef.current,
                    gainChainRef.current.mainGain,
                    binauralFreq
                );
            };

            const syncNoiseLayer = () => {
                tearDownNoiseNodes();
                if (
                    noiseType === 'none' ||
                    !audioContextRef.current ||
                    !gainChainRef.current
                ) {
                    return;
                }
                noiseNodesRef.current = AudioEngine.createNoiseNode(
                    audioContextRef.current,
                    gainChainRef.current.mainGain,
                    noiseType,
                    noiseVolume
                );
            };

            const clearRitualTimers = () => {
                if (ritualIntervalRef.current) {
                    clearInterval(ritualIntervalRef.current);
                    ritualIntervalRef.current = null;
                }
                if (ritualTimeoutRef.current) {
                    clearTimeout(ritualTimeoutRef.current);
                    ritualTimeoutRef.current = null;
                }
                if (breathingPhaseIntervalRef.current) {
                    clearInterval(breathingPhaseIntervalRef.current);
                    breathingPhaseIntervalRef.current = null;
                }
            };

            useEffect(() => {
                audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();

                if (window.location.protocol === 'file:') {
                    setShowFileWarning(true);
                }

                const savedDarkMode = localStorage.getItem('darkMode');
                const prefersDark = savedDarkMode === null ? true : savedDarkMode === 'true';
                setDarkMode(prefersDark);
                document.body.classList.toggle('dark-mode', prefersDark);
                if (savedDarkMode === null) {
                    localStorage.setItem('darkMode', 'true');
                }

                const savedHighContrast = localStorage.getItem('highContrast');
                if (savedHighContrast === 'true') {
                    setHighContrast(true);
                    document.body.classList.add('high-contrast');
                }

                const savedReducedMotion = localStorage.getItem('reducedMotion');
                if (savedReducedMotion === 'true') {
                    setReducedMotion(true);
                }

                // Story 3-1: Load saved active preset with validation
                const savedActivePreset = localStorage.getItem('activePresetId');
                if (savedActivePreset) {
                    const presetExists = MODE_LIBRARY.some(m => m.id === savedActivePreset);
                    setActivePresetId(presetExists ? savedActivePreset : 'focus');
                }

                const savedPlaylist = localStorage.getItem('playlist');
                if (savedPlaylist) {
                    try {
                        const parsed = JSON.parse(savedPlaylist);
                        const filtered = parsed.filter((track) => track && track.source !== 'local' && track.url);
                        setPlaylist(filtered);
                    } catch (error) {
                        console.error('Error loading saved playlist:', error);
                    }
                }

                // Online/offline listeners moved to useServiceWorker hook

                return () => {
                    endSession(true);
                    disposeAudioGraph();
                    teardownAudioElement();
                    if (audioContextRef.current) {
                        audioContextRef.current.close();
                    }
                    clearRitualTimers();
                };
            }, []);

            // Story 6-2: Parse query params for shortcut mode detection (AC7)
            useEffect(() => {
                const parseAndApplyQueryParams = () => {
                    const params = new URLSearchParams(window.location.search);
                    const mode = params.get('mode');
                    const source = params.get('source');

                    // Log if launched via PWA shortcut
                    if (source === 'pwa') {
                        console.log('[PWA] Launched from installed PWA');
                        logInstallEvent('PWA_LAUNCH', { mode: mode || 'default' });
                    }

                    // Apply preset based on mode param
                    if (mode === 'focus') {
                        const focusPreset = MODE_LIBRARY.find(m => m.id === 'focus');
                        if (focusPreset) {
                            console.log('[PWA] Applying Focus preset from shortcut');
                            // Defer to allow initial render
                            setTimeout(() => {
                                applyPreset(focusPreset.preset, focusPreset.id);
                            }, 100);
                        }
                    } else if (mode === 'calm') {
                        const calmPreset = MODE_LIBRARY.find(m => m.id === 'calm');
                        if (calmPreset) {
                            console.log('[PWA] Applying Calm preset from shortcut');
                            setTimeout(() => {
                                applyPreset(calmPreset.preset, calmPreset.id);
                            }, 100);
                        }
                    }

                    // Clean the URL by removing query params (but keep in history)
                    if (mode || source) {
                        const cleanUrl = window.location.pathname;
                        window.history.replaceState({}, '', cleanUrl);
                        console.log('[PWA] Cleaned URL query params');
                    }
                };

                parseAndApplyQueryParams();
            // eslint-disable-next-line react-hooks/exhaustive-deps
            }, []);

            // Story 3-3: Load all presets on mount
            useEffect(() => {
                const presets = getAllPresets();
                setAllPresets(presets);
                console.log('[PresetManagement] Loaded', presets.length, 'presets');
            }, []);

            // Story 5-1: Sensor capability detection on mount (AC1, AC2)
            // Uses feature detection (not browser sniffing) per requirements
            useEffect(() => {
                const detectCapabilities = () => {
                    const startTime = performance.now();

                    // AC1: Web Bluetooth capability detection
                    const btSupported = typeof navigator !== 'undefined' &&
                        typeof navigator.bluetooth !== 'undefined' &&
                        typeof navigator.bluetooth.requestDevice === 'function';
                    setBluetoothSupported(btSupported);
                    console.log(`[SensorBridge] Bluetooth: ${btSupported ? 'supported' : 'unsupported'}`);

                    // AC2: Web Serial capability detection
                    const serialSupport = typeof navigator !== 'undefined' &&
                        typeof navigator.serial !== 'undefined' &&
                        typeof navigator.serial.requestPort === 'function';
                    setSerialSupported(serialSupport);
                    console.log(`[SensorBridge] Serial: ${serialSupport ? 'supported' : 'unsupported'}`);

                    const elapsed = performance.now() - startTime;
                    console.log(`[SensorBridge] Capability detection completed in ${elapsed.toFixed(2)}ms`);

                    // Log browser compatibility summary
                    if (!btSupported && !serialSupport) {
                        console.log('[SensorBridge] No sensor APIs available - Safari or unsupported browser');
                    } else if (!btSupported && serialSupport) {
                        console.log('[SensorBridge] Serial only (Firefox behavior)');
                    } else {
                        console.log('[SensorBridge] Full sensor support available');
                    }
                };

                detectCapabilities();
            }, []);

            // Story 5-1: Initialize sensor consent database and load consented devices
            useEffect(() => {
                const consentApi = getSensorConsentApi();
                if (!consentApi) {
                    console.warn('[SensorBridge] IndexedDB unavailable — sensor consent storage disabled.');
                    return;
                }

                let canceled = false;
                const initSensorConsent = async () => {
                    try {
                        await consentApi.initDatabase();
                        const devices = await consentApi.getConsentedDevices();
                        if (!canceled) {
                            setConsentedDevices(devices);
                            console.log(`[SensorBridge] Loaded ${devices.length} consented devices`);
                        }
                    } catch (error) {
                        if (!canceled) {
                            console.error('[SensorBridge] Sensor consent initialization failed:', error);
                        }
                    }
                };

                initSensorConsent();

                return () => {
                    canceled = true;
                };
            }, []);

            // Cleanup URL validation on unmount
            useEffect(() => {
                // Initialize controller ref
                urlValidationControllerRef.current = {};
                
                return () => {
                    // Mark component as unmounted to prevent setState after unmount
                    urlValidationControllerRef.current = null;
                    
                    // Clear any pending toast timeout
                    if (toastTimeoutRef.current) {
                        clearTimeout(toastTimeoutRef.current);
                        toastTimeoutRef.current = null;
                    }
                };
            }, []);

            useEffect(() => {
                const sessionApi = getSessionLoggingApi();
                if (!sessionApi) {
                    console.warn('[SessionLogger] IndexedDB unavailable — session logging disabled.');
                    return;
                }
                let canceled = false;
                sessionApi.initDatabase().catch((error) => {
                    if (canceled) {
                        return;
                    }
                    console.error('[SessionLogger] Initialization failed:', error);
                    showToast('Session logging unavailable. See console for details.', 'warning');
                });

                window.SessionLogger = {
                    clearProfile: clearProfileSessions,
                    clearSessionsOlderThanDays,
                    exportSessions: (startDate, endDate) => sessionApi.getSessionsByDateRange(startDate, endDate)
                };

                return () => {
                    canceled = true;
                    delete window.SessionLogger;
                };
            }, [clearProfileSessions, clearSessionsOlderThanDays, showToast]);

            // Story 4-3: Load sessions for insights dashboard based on date range
            useEffect(() => {
                const loadInsightsSessions = async () => {
                    const sessionApi = getSessionLoggingApi();
                    if (!sessionApi) {
                        setInsightsSessions([]);
                        return;
                    }

                    const days = insightsDateRange === '7d' ? 7 : insightsDateRange === '14d' ? 14 : 30;
                    const now = Date.now();
                    const startDate = now - (days * 24 * 60 * 60 * 1000);

                    if (performance?.mark) {
                        performance.mark('insights-load-start');
                    }

                    try {
                        const sessions = await sessionApi.getSessionsByDateRange(startDate, now);
                        setInsightsSessions(sessions || []);

                        if (performance?.mark) {
                            performance.mark('insights-load-end');
                            const measure = performance.measure('insights-load', 'insights-load-start', 'insights-load-end');
                            performance.clearMarks('insights-load-start');
                            performance.clearMarks('insights-load-end');
                            performance.clearMeasures('insights-load');
                            console.log(`[SessionLogger] Loaded ${sessions?.length || 0} sessions for insights in ${measure.duration.toFixed(2)}ms`);
                        }
                    } catch (err) {
                        console.error('[SessionLogger] Failed to load insights sessions:', err);
                        setInsightsSessions([]);
                    }
                };

                loadInsightsSessions();
            }, [insightsDateRange, activeSessionId]); // Reload when date range changes or when a session ends

            // Story 3-1: Persist active preset selection
            useEffect(() => {
                try {
                    localStorage.setItem('activePresetId', activePresetId);
                } catch (err) {
                    console.error('Failed to persist activePresetId:', err);
                }
            }, [activePresetId]);

            // Story 3-1: Apply preset parameters when activePresetId changes
            useEffect(() => {
                const preset = MODE_LIBRARY.find(m => m.id === activePresetId);
                if (preset) {
                    setSpeed(preset.preset.speed);
                    setIntensity(preset.preset.intensity);
                    setSpatialDepth(preset.preset.spatialDepth);
                    setMovementPattern(preset.preset.movement);
                    setBinauralEnabled(preset.preset.binaural.enabled);
                    setBinauralFreq(preset.preset.binaural.freq);
                    setNoiseType(preset.preset.noise.type);
                    setNoiseVolume(preset.preset.noise.volume);
                    setVisualWaveGain(preset.preset.noise.volume);
                }
            }, [activePresetId]);

            useEffect(() => {
                const serialized = playlist
                    .filter((track) => track.source !== 'local' && track.url)
                    .map((track) => ({
                        id: track.id,
                        name: track.name,
                        source: track.source,
                        url: track.url,
                        originalUrl: track.originalUrl || null
                    }));
                if (serialized.length > 0) {
                    localStorage.setItem('playlist', JSON.stringify(serialized));
                } else {
                    localStorage.removeItem('playlist');
                }
            }, [playlist]);

            useEffect(() => {
                const prevLength = prevPlaylistLengthRef.current;
                const isEmpty = playlist.length === 0;

                if (isEmpty) {
                    if (currentTrackIndex !== null) {
                        currentTrackIndexRef.current = null;
                        setCurrentTrackIndex(null);
                    }
                    teardownAudioElement();
                    disposeAudioGraph();
                    setIsPlaying(false);
                    if (prevLength !== 0) {
                        setHeroMessage('Playlist empty. Add audio to start a ritual.');
                        setNeedsAudio(true);
                        setRitualStatus('idle');
                        setRitualCountdown(HERO_BREATH_DURATION);
                        clearRitualTimers();
                    }
                } else if (currentTrackIndex !== null && currentTrackIndex >= playlist.length) {
                    const clampedIndex = Math.max(playlist.length - 1, 0);
                    currentTrackIndexRef.current = clampedIndex;
                    setCurrentTrackIndex(clampedIndex);
                }

                prevPlaylistLengthRef.current = playlist.length;
                playlistRef.current = playlist;
            }, [playlist.length, currentTrackIndex]);

            useEffect(() => {
                playlistRef.current = playlist;
            }, [playlist]);

            useEffect(() => {
                currentTrackIndexRef.current = currentTrackIndex;
            }, [currentTrackIndex]);

            // Keep audio parameter refs in sync with state for rotation interval
            useEffect(() => { speedRef.current = speed; }, [speed]);
            useEffect(() => { intensityRef.current = intensity; }, [intensity]);
            useEffect(() => { spatialDepthRef.current = spatialDepth; }, [spatialDepth]);
            useEffect(() => { movementPatternRef.current = movementPattern; }, [movementPattern]);
            useEffect(() => { spatialTunerActiveRef.current = showSpatialTuner; }, [showSpatialTuner]);

            // Show first-run calibration prompt (only once, unless dismissed)
            useEffect(() => {
                if (!hasRunCalibration && !calibrationDismissed) {
                    // Small delay to let the app render first
                    const timer = setTimeout(() => {
                        setShowFirstRunPrompt(true);
                    }, 1000);
                    return () => clearTimeout(timer);
                }
            }, [hasRunCalibration, calibrationDismissed]);

            // Clear accessibility announcements after 3 seconds to prevent re-announcements
            useEffect(() => {
                if (a11yAnnouncement) {
                    const timer = setTimeout(() => {
                        setA11yAnnouncement('');
                    }, 3000);
                    return () => clearTimeout(timer);
                }
            }, [a11yAnnouncement]);

            // Story 3-2: Keyboard shortcut (Ctrl+E) to toggle advanced controls
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'e') {
                        e.preventDefault();
                        setIsAdvancedControlsExpanded(prev => !prev);
                        setA11yAnnouncement(
                            isAdvancedControlsExpanded 
                                ? 'Advanced controls collapsed' 
                                : 'Advanced controls expanded'
                        );
                    }
                };
                
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [isAdvancedControlsExpanded]);

            // Handle Escape key, window resize, and body class for fullscreen visualizer
            useEffect(() => {
                if (visualizerFullscreen) {
                    document.body.classList.add('viz-fullscreen');

                    // Try to use native fullscreen API on mobile for better experience
                    const tryNativeFullscreen = async () => {
                        try {
                            if (document.documentElement.requestFullscreen) {
                                await document.documentElement.requestFullscreen();
                            } else if (document.documentElement.webkitRequestFullscreen) {
                                await document.documentElement.webkitRequestFullscreen();
                            }
                            // Try to lock orientation to allow rotation
                            if (screen.orientation && screen.orientation.unlock) {
                                screen.orientation.unlock();
                            }
                        } catch (e) {
                            // Fullscreen not supported or denied, continue with CSS fullscreen
                            console.log('Native fullscreen not available, using CSS fallback');
                        }
                    };
                    tryNativeFullscreen();
                } else {
                    document.body.classList.remove('viz-fullscreen');
                    setVizMenuOpen(false); // Close viz menu when exiting fullscreen
                    // Exit native fullscreen if active
                    if (document.fullscreenElement || document.webkitFullscreenElement) {
                        if (document.exitFullscreen) {
                            document.exitFullscreen().catch(() => {});
                        } else if (document.webkitExitFullscreen) {
                            document.webkitExitFullscreen();
                        }
                    }
                }

                if (!visualizerFullscreen) return;

                const handleEscapeFullscreen = (e) => {
                    if (e.key === 'Escape') {
                        setVisualizerFullscreen(false);
                    }
                };

                const handleResize = () => {
                    // Force re-render to update canvas size
                    if (canvasRef.current && visualizerFullscreen) {
                        canvasRef.current.width = window.innerWidth;
                        canvasRef.current.height = window.innerHeight;
                    }
                    if (fullscreenCanvasRef.current) {
                        fullscreenCanvasRef.current.width = window.innerWidth;
                        fullscreenCanvasRef.current.height = window.innerHeight;
                    }
                };

                // Handle native fullscreen exit (e.g., swipe down on mobile)
                const handleFullscreenChange = () => {
                    if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                        setVisualizerFullscreen(false);
                    }
                };

                window.addEventListener('keydown', handleEscapeFullscreen);
                window.addEventListener('resize', handleResize);
                document.addEventListener('fullscreenchange', handleFullscreenChange);
                document.addEventListener('webkitfullscreenchange', handleFullscreenChange);

                return () => {
                    window.removeEventListener('keydown', handleEscapeFullscreen);
                    window.removeEventListener('resize', handleResize);
                    document.removeEventListener('fullscreenchange', handleFullscreenChange);
                    document.removeEventListener('webkitfullscreenchange', handleFullscreenChange);
                    document.body.classList.remove('viz-fullscreen');
                };
            }, [visualizerFullscreen]);

            useEffect(() => {
                const audio = audioElementRef.current;
                if (!audio) {
                    return;
                }
                const handleTimeUpdate = () => {
                    setCurrentTime(audio.currentTime || 0);
                    setDuration(audio.duration || 0);
                };
                audio.addEventListener('timeupdate', handleTimeUpdate);
                audio.addEventListener('loadedmetadata', handleTimeUpdate);
                return () => {
                    audio.removeEventListener('timeupdate', handleTimeUpdate);
                    audio.removeEventListener('loadedmetadata', handleTimeUpdate);
                };
            }, [audioElementToken]);

            const toggleDarkMode = () => {
                const next = !darkMode;
                setDarkMode(next);
                document.body.classList.toggle('dark-mode', next);
                localStorage.setItem('darkMode', String(next));
                setA11yAnnouncement(next ? 'Dark mode enabled' : 'Light mode enabled');
            };

            const toggleHighContrast = () => {
                const next = !highContrast;
                setHighContrast(next);
                document.body.classList.toggle('high-contrast', next);
                try {
                    if (next) {
                        localStorage.setItem('highContrast', 'true');
                    } else {
                        localStorage.removeItem('highContrast');
                    }
                } catch (e) {
                    console.warn('Failed to persist high-contrast preference', e);
                }
                setA11yAnnouncement(next ? 'High contrast mode enabled' : 'High contrast mode disabled');
            };

            const toggleReducedMotion = () => {
                const next = !reducedMotion;
                setReducedMotion(next);
                try {
                    if (next) {
                        localStorage.setItem('reducedMotion', 'true');
                    } else {
                        localStorage.removeItem('reducedMotion');
                    }
                } catch (e) {
                    console.warn('Failed to persist reduced-motion preference', e);
                }
                setA11yAnnouncement(next ? 'Reduced motion enabled' : 'Motion enabled');
            };

            const focusModeChip = (index) => {
                const total = MODE_LIBRARY.length;
                const normalized = ((index % total) + total) % total;
                setFocusedModeIndex(normalized);
                requestAnimationFrame(() => {
                    const chip = modeRefs.current[normalized];
                    if (chip) {
                        chip.focus();
                    }
                });
                return normalized;
            };

            // Story 3-1: Log preset changes for Epic 4 session tracking
            const logPresetChange = (newPresetId) => {
                const event = {
                    event: 'PRESET_CHANGED',
                    presetId: newPresetId,
                    previousPresetId: activePresetId,
                    timestamp: Date.now(),
                    trackId: currentTrackIndex !== null ? playlist[currentTrackIndex].id : null
                };
                console.log('[SessionLogger]', event);
                // E4 integration point - future: dispatch to IndexedDB logger
                // window.dispatchEvent(new CustomEvent('preset-changed', { detail: event }));
            };

            // Story 3-2: Epic 5 API for adaptive mode (sensor lock)
            const enableSensorMode = () => {
                setSensorLocked(true);
                setA11yAnnouncement('Adaptive mode enabled. Controls locked.');
                showToast('Adaptive mode active', 'info');
            };

            const disableSensorMode = () => {
                setSensorLocked(false);
                setA11yAnnouncement('Adaptive mode disabled. Controls unlocked.');
                showToast('Manual control restored', 'info');
            };

            // Expose API for Epic 5 integration
            useEffect(() => {
                window.audioControlsAPI = {
                    enableSensorMode,
                    disableSensorMode
                };
                return () => {
                    delete window.audioControlsAPI;
                };
            }, []);

            // ============================================================
            // Story 3-3: Custom Preset Management Handlers
            // ============================================================
            
            const openSavePresetDialog = () => {
                setEditingPreset(null);
                setShowSavePresetDialog(true);
            };

            const openEditPresetDialog = (preset) => {
                setEditingPreset(preset);
                setShowSavePresetDialog(true);
            };

            const closeSavePresetDialog = () => {
                setShowSavePresetDialog(false);
                setEditingPreset(null);
            };

            const handleSavePreset = (presetId) => {
                // Apply the newly saved/edited preset
                const presets = getAllPresets();
                setAllPresets(presets);
                
                const preset = presets.find(p => p.id === presetId);
                if (preset) {
                    applyPreset(preset.preset, preset.id);
                }
                
                closeSavePresetDialog();
            };

            const handleDeletePreset = (presetId) => {
                // Check how many tracks use this preset
                const tracksUsingPreset = playlist.filter(t => t.lastPresetId === presetId).length;

                let confirmMessage = 'Delete this preset? This cannot be undone.';
                if (tracksUsingPreset > 0) {
                    confirmMessage = `⚠️ This preset is used by ${tracksUsingPreset} track(s).\n\nThey will reset to the default Focus preset.\n\nDelete this preset? This cannot be undone.`;
                }

                if (!confirm(confirmMessage)) {
                    return;
                }

                const result = deleteCustomPreset(presetId, showToast);
                if (result) {
                    showToast(`Preset "${result.name}" deleted`, 'success');
                    setA11yAnnouncement(`Preset ${result.name} deleted`);
                    
                    // Update all presets list
                    const presets = getAllPresets();
                    setAllPresets(presets);
                    
                    // Update tracks using this preset to fallback to focus
                    setPlaylist(prev => prev.map(track => ({
                        ...track,
                        lastPresetId: track.lastPresetId === presetId ? 'focus' : track.lastPresetId
                    })));
                    
                    // If deleted preset was active, switch to focus
                    if (activePresetId === presetId) {
                        const focusMode = MODE_LIBRARY[0];
                        applyPreset(focusMode.preset, focusMode.id);
                        showToast('Switched to Focus preset', 'info');
                    }
                }
            };

            const handleQuickApplyPreset = (preset) => {
                applyPreset(preset.preset, preset.id);
                showToast(`Applied ${preset.name} preset`, 'success');
                setA11yAnnouncement(`${preset.name} preset applied`);
            };

            const handleReorderPresets = (newOrder) => {
                savePresetOrder(newOrder);
                // Reload all presets to reflect new order
                const presets = getAllPresets();
                setAllPresets(presets);
            };

            const setActiveMode = (index) => {
                const normalized = focusModeChip(index);
                const mode = MODE_LIBRARY[normalized];
                setModeIndex(normalized);
                applyPreset(mode.preset, mode.id);
                setHeroMessage(`${mode.label} preset queued. Press Start to begin.`);
                setA11yAnnouncement(`${mode.label} mode selected`);
            };

            const handleModeKeyDown = (event, index) => {
                const { key } = event;
                if (key === 'ArrowRight' || key === 'ArrowDown') {
                    event.preventDefault();
                    focusModeChip(index + 1);
                    return;
                }
                if (key === 'ArrowLeft' || key === 'ArrowUp') {
                    event.preventDefault();
                    focusModeChip(index - 1);
                    return;
                }
                if (key === 'Home') {
                    event.preventDefault();
                    focusModeChip(0);
                    return;
                }
                if (key === 'End') {
                    event.preventDefault();
                    focusModeChip(MODE_LIBRARY.length - 1);
                    return;
                }
                if (key === 'Enter' || key === ' ' || key === 'Spacebar') {
                    event.preventDefault();
                    setActiveMode(index);
                }
            };

            const setupAudioGraph = (audioElement) => {
                const context = audioContextRef.current;
                if (!context) return;

                if (context.state === 'suspended') {
                    context.resume();
                }

                disposeAudioGraph();

                const source = context.createMediaElementSource(audioElement);
                sourceNodeRef.current = source;

                const splitter = context.createChannelSplitter(2);
                const merger = context.createChannelMerger(2);

                const leftToLeftGain = context.createGain();
                const leftToRightGain = context.createGain();
                const rightToLeftGain = context.createGain();
                const rightToRightGain = context.createGain();

                const delayLeft = context.createDelay();
                const delayRight = context.createDelay();
                delayLeft.delayTime.value = 0.05;
                delayRight.delayTime.value = 0.05;

                const delayGainLeft = context.createGain();
                const delayGainRight = context.createGain();
                delayGainLeft.gain.value = 0.05 * spatialDepth;
                delayGainRight.gain.value = 0.05 * spatialDepth;

                const crossDelayLeft = context.createDelay();
                const crossDelayRight = context.createDelay();
                crossDelayLeft.delayTime.value = 0.03;
                crossDelayRight.delayTime.value = 0.03;

                const crossGainLeft = context.createGain();
                const crossGainRight = context.createGain();
                crossGainLeft.gain.value = 0.03 * spatialDepth;
                crossGainRight.gain.value = 0.03 * spatialDepth;

                // ITD (Inter-aural Time Difference) delay nodes
                // Max ITD is ~0.7ms (0.0007s) when sound is directly to one side
                // Extended to 200ms max for calibration/APD testing
                const itdDelayLeft = context.createDelay(0.2); // max 200ms for calibration
                const itdDelayRight = context.createDelay(0.2);
                itdDelayLeft.delayTime.value = 0;
                itdDelayRight.delayTime.value = 0;

                // Low-pass filters for "head shadow" effect
                // High frequencies are blocked more by the head, making sounds behind/opposite darker
                const lpFilterLeft = context.createBiquadFilter();
                const lpFilterRight = context.createBiquadFilter();
                lpFilterLeft.type = 'lowpass';
                lpFilterRight.type = 'lowpass';
                lpFilterLeft.frequency.value = 20000; // Start fully open
                lpFilterRight.frequency.value = 20000;
                lpFilterLeft.Q.value = 0.7; // Gentle rolloff
                lpFilterRight.Q.value = 0.7;

                rotationNodesRef.current = {
                    leftToLeftGain,
                    leftToRightGain,
                    rightToLeftGain,
                    rightToRightGain,
                    delayGainLeft,
                    delayGainRight,
                    crossGainLeft,
                    crossGainRight,
                    itdDelayLeft,
                    itdDelayRight,
                    lpFilterLeft,
                    lpFilterRight
                };

                source.connect(splitter);

                splitter.connect(leftToLeftGain, 0);
                splitter.connect(leftToRightGain, 0);
                splitter.connect(rightToLeftGain, 1);
                splitter.connect(rightToRightGain, 1);

                // Route through ITD delays and low-pass filters before merger
                // Left channel: gains -> ITD delay -> low-pass filter -> merger
                leftToLeftGain.connect(itdDelayLeft);
                rightToLeftGain.connect(itdDelayLeft);
                itdDelayLeft.connect(lpFilterLeft);
                lpFilterLeft.connect(merger, 0, 0);

                // Right channel: gains -> ITD delay -> low-pass filter -> merger
                rightToRightGain.connect(itdDelayRight);
                leftToRightGain.connect(itdDelayRight);
                itdDelayRight.connect(lpFilterRight);
                lpFilterRight.connect(merger, 0, 1);

                leftToLeftGain.connect(delayLeft);
                delayLeft.connect(delayGainLeft);
                delayGainLeft.connect(merger, 0, 0);

                rightToRightGain.connect(delayRight);
                delayRight.connect(delayGainRight);
                delayGainRight.connect(merger, 0, 1);

                leftToLeftGain.connect(crossDelayRight);
                crossDelayRight.connect(crossGainRight);
                crossGainRight.connect(merger, 0, 1);

                rightToRightGain.connect(crossDelayLeft);
                crossDelayLeft.connect(crossGainLeft);
                crossGainLeft.connect(merger, 0, 0);

                // EQ Filters - applied after spatial processing, before output
                // Bass: Low shelf filter (~150Hz)
                const bassFilter = context.createBiquadFilter();
                bassFilter.type = 'lowshelf';
                bassFilter.frequency.value = 150;
                bassFilter.gain.value = 0; // -12 to +12 dB

                // Mid: Peaking filter (~1000Hz)
                const midFilter = context.createBiquadFilter();
                midFilter.type = 'peaking';
                midFilter.frequency.value = 1000;
                midFilter.Q.value = 1.0;
                midFilter.gain.value = 0; // -12 to +12 dB

                // Treble: High shelf filter (~4000Hz)
                const trebleFilter = context.createBiquadFilter();
                trebleFilter.type = 'highshelf';
                trebleFilter.frequency.value = 4000;
                trebleFilter.gain.value = 0; // -12 to +12 dB

                // Clarity/Presence: Peaking filter (~2500Hz) - speech intelligibility range
                const clarityFilter = context.createBiquadFilter();
                clarityFilter.type = 'peaking';
                clarityFilter.frequency.value = 2500;
                clarityFilter.Q.value = 1.5; // Narrower band for presence
                clarityFilter.gain.value = 0; // -12 to +12 dB

                // Store EQ nodes for later adjustment
                eqNodesRef.current = {
                    bassFilter,
                    midFilter,
                    trebleFilter,
                    clarityFilter
                };

                // Chain: merger → bass → mid → treble → clarity → gainChain
                merger.connect(bassFilter);
                bassFilter.connect(midFilter);
                midFilter.connect(trebleFilter);
                trebleFilter.connect(clarityFilter);

                const gainChain = AudioEngine.connectGainStaging(context, clarityFilter, {
                    volume,
                    fftSize: 2048
                });

                gainChainRef.current = gainChain;
                gainNodeRef.current = gainChain.mainGain;
                analyserRef.current = gainChain.analyser;

                syncBinauralChain();
                syncNoiseLayer();

                startRotation();

                if (showVisualizer) {
                    visualize();
                }
            };

            // Apply gains directly from Spatial Tuner (bypasses rotation interval)
            const applyTunerGains = React.useCallback((leftGain, rightGain, crossGain, itdLeftDelay = 0, itdRightDelay = 0, leftFilterFreq = 20000, rightFilterFreq = 20000, forceHardPan = false) => {
                const nodes = rotationNodesRef.current;
                const ctx = audioContextRef.current;
                if (!nodes || !ctx) return;

                const clamp = (val) => Math.max(0.0001, Math.min(1, val));
                const now = ctx.currentTime;
                const rampTime = now + 0.05; // Fast 50ms ramp

                // Apply the gains directly
                if (nodes.leftToLeftGain) {
                    nodes.leftToLeftGain.gain.setValueAtTime(clamp(nodes.leftToLeftGain.gain.value), now);
                    nodes.leftToLeftGain.gain.exponentialRampToValueAtTime(clamp(leftGain * 0.5), rampTime);
                }
                if (nodes.rightToRightGain) {
                    nodes.rightToRightGain.gain.setValueAtTime(clamp(nodes.rightToRightGain.gain.value), now);
                    nodes.rightToRightGain.gain.exponentialRampToValueAtTime(clamp(rightGain * 0.5), rampTime);
                }
                // Cross-channel (near zero for hard pan)
                if (nodes.leftToRightGain) {
                    nodes.leftToRightGain.gain.setValueAtTime(clamp(nodes.leftToRightGain.gain.value), now);
                    nodes.leftToRightGain.gain.exponentialRampToValueAtTime(clamp(crossGain), rampTime);
                }
                if (nodes.rightToLeftGain) {
                    nodes.rightToLeftGain.gain.setValueAtTime(clamp(nodes.rightToLeftGain.gain.value), now);
                    nodes.rightToLeftGain.gain.exponentialRampToValueAtTime(clamp(crossGain), rampTime);
                }

                // Apply ITD (Inter-aural Time Difference) delays
                // Sound on right = delay left ear, sound on left = delay right ear
                // Max 200ms for calibration testing (normal ITD is ~0.7ms)
                const leftDelayValue = Math.min(0.2, Math.max(0, itdLeftDelay));
                const rightDelayValue = Math.min(0.2, Math.max(0, itdRightDelay));
                console.log(`[applyTunerGains] ITD Delays requested - Left: ${(leftDelayValue * 1000).toFixed(1)}ms, Right: ${(rightDelayValue * 1000).toFixed(1)}ms`);

                if (nodes.itdDelayLeft) {
                    // Cancel any pending automation and set immediately
                    nodes.itdDelayLeft.delayTime.cancelScheduledValues(now);
                    nodes.itdDelayLeft.delayTime.setValueAtTime(leftDelayValue, now);
                    console.log(`  -> itdDelayLeft: was ${(nodes.itdDelayLeft.delayTime.value * 1000).toFixed(1)}ms, set to ${(leftDelayValue * 1000).toFixed(1)}ms`);
                } else {
                    console.warn('  -> itdDelayLeft node NOT FOUND!');
                }
                if (nodes.itdDelayRight) {
                    // Cancel any pending automation and set immediately
                    nodes.itdDelayRight.delayTime.cancelScheduledValues(now);
                    nodes.itdDelayRight.delayTime.setValueAtTime(rightDelayValue, now);
                    console.log(`  -> itdDelayRight: was ${(nodes.itdDelayRight.delayTime.value * 1000).toFixed(1)}ms, set to ${(rightDelayValue * 1000).toFixed(1)}ms`);
                } else {
                    console.warn('  -> itdDelayRight node NOT FOUND!');
                }

                // Verify the values were actually set (read back)
                setTimeout(() => {
                    if (nodes.itdDelayLeft) console.log(`  [VERIFY] itdDelayLeft actual value: ${(nodes.itdDelayLeft.delayTime.value * 1000).toFixed(1)}ms`);
                    if (nodes.itdDelayRight) console.log(`  [VERIFY] itdDelayRight actual value: ${(nodes.itdDelayRight.delayTime.value * 1000).toFixed(1)}ms`);
                }, 100);

                // CRITICAL: Mute the parallel delay paths that bypass ITD
                // These paths create undelayed signal that drowns out ITD timing
                // Also mute during calibration (forceHardPan) for clean L/R separation
                const hasITDDelay = leftDelayValue > 0.001 || rightDelayValue > 0.001;
                const needsHardPan = hasITDDelay || forceHardPan;
                const parallelPathGain = needsHardPan ? 0.0001 : 0.05; // Mute when testing ITD or calibrating
                // Cross-delay paths (left→right, right→left) - ALWAYS mute during hard pan for clean separation
                const crossPathGain = needsHardPan ? 0.0001 : 0.03;

                if (nodes.delayGainLeft) {
                    nodes.delayGainLeft.gain.cancelScheduledValues(now);
                    nodes.delayGainLeft.gain.setValueAtTime(parallelPathGain, now);
                }
                if (nodes.delayGainRight) {
                    nodes.delayGainRight.gain.cancelScheduledValues(now);
                    nodes.delayGainRight.gain.setValueAtTime(parallelPathGain, now);
                }
                if (nodes.crossGainLeft) {
                    nodes.crossGainLeft.gain.cancelScheduledValues(now);
                    nodes.crossGainLeft.gain.setValueAtTime(crossPathGain, now);
                }
                if (nodes.crossGainRight) {
                    nodes.crossGainRight.gain.cancelScheduledValues(now);
                    nodes.crossGainRight.gain.setValueAtTime(crossPathGain, now);
                }

                if (needsHardPan) {
                    console.log(`  [HARD PAN MODE] Muted parallel/cross paths - ITD: ${hasITDDelay}, Calibration: ${forceHardPan}`);
                }

                // Apply low-pass filter frequencies for "head shadow" effect
                // This makes sounds darker/muffled when behind or on opposite side
                if (nodes.lpFilterLeft) {
                    nodes.lpFilterLeft.frequency.setValueAtTime(nodes.lpFilterLeft.frequency.value, now);
                    nodes.lpFilterLeft.frequency.exponentialRampToValueAtTime(Math.max(200, leftFilterFreq), rampTime);
                }
                if (nodes.lpFilterRight) {
                    nodes.lpFilterRight.frequency.setValueAtTime(nodes.lpFilterRight.frequency.value, now);
                    nodes.lpFilterRight.frequency.exponentialRampToValueAtTime(Math.max(200, rightFilterFreq), rampTime);
                }
            }, []);

            // Apply EQ settings to the audio chain
            const applyEQ = React.useCallback((bass, mid, treble, clarity) => {
                const eq = eqNodesRef.current;
                const ctx = audioContextRef.current;
                if (!eq || !ctx) {
                    console.warn('[applyEQ] EQ nodes not available');
                    return;
                }

                const now = ctx.currentTime;
                const rampTime = now + 0.05; // 50ms smooth transition

                // Clamp values to -12 to +12 dB range
                const clampDB = (val) => Math.max(-12, Math.min(12, val || 0));

                const bassDB = clampDB(bass);
                const midDB = clampDB(mid);
                const trebleDB = clampDB(treble);
                const clarityDB = clampDB(clarity);

                console.log(`[applyEQ] Bass: ${bassDB}dB, Mid: ${midDB}dB, Treble: ${trebleDB}dB, Clarity: ${clarityDB}dB`);

                if (eq.bassFilter) {
                    eq.bassFilter.gain.setValueAtTime(eq.bassFilter.gain.value, now);
                    eq.bassFilter.gain.linearRampToValueAtTime(bassDB, rampTime);
                }
                if (eq.midFilter) {
                    eq.midFilter.gain.setValueAtTime(eq.midFilter.gain.value, now);
                    eq.midFilter.gain.linearRampToValueAtTime(midDB, rampTime);
                }
                if (eq.trebleFilter) {
                    eq.trebleFilter.gain.setValueAtTime(eq.trebleFilter.gain.value, now);
                    eq.trebleFilter.gain.linearRampToValueAtTime(trebleDB, rampTime);
                }
                if (eq.clarityFilter) {
                    eq.clarityFilter.gain.setValueAtTime(eq.clarityFilter.gain.value, now);
                    eq.clarityFilter.gain.linearRampToValueAtTime(clarityDB, rampTime);
                }
            }, []);

            const startRotation = () => {
                if (rotationIntervalRef.current) {
                    clearInterval(rotationIntervalRef.current);
                }
                if (!rotationNodesRef.current) {
                    return;
                }
                
                let time = 0;
                // Use a slightly longer interval to allow meaningful ramps (avoid overlapping automation)
                const ROTATION_INTERVAL_MS = 100; // 100ms ticks
                rotationIntervalRef.current = setInterval(() => {
                    // Skip rotation when Spatial Tuner is active (tuner controls audio directly)
                    if (spatialTunerActiveRef.current) {
                        return;
                    }

                    const nodes = rotationNodesRef.current;
                    const ctx = audioContextRef.current;
                    if (
                        !nodes ||
                        !ctx ||
                        !nodes.leftToLeftGain ||
                        !nodes.leftToRightGain ||
                        !nodes.rightToLeftGain ||
                        !nodes.rightToRightGain
                    ) {
                        return;
                    }
                    
                    // Read current values from refs (not stale closure)
                    const currentSpeed = speedRef.current;
                    const currentMovement = movementPatternRef.current;
                    const currentIntensity = intensityRef.current;
                    const currentSpatialDepth = spatialDepthRef.current;

                    const angle = 2 * Math.PI * currentSpeed * time;
                    let panPosition = 0;

                    // Calculate pan position based on movement pattern
                    switch(currentMovement) {
                        case 'circle':
                            panPosition = Math.sin(angle);
                            break;
                        case 'figure8':
                            // True figure-8: Loop on right side, then loop on left side
                            // Creates the sensation of sound tracing an "8" around your head
                            const f8Cycle = ((angle / (2 * Math.PI)) % 1 + 1) % 1; // 0 to 1, normalized
                            if (f8Cycle < 0.5) {
                                // Right side loop: center → full right → center
                                const rightPhase = f8Cycle * 2; // 0 to 1
                                panPosition = Math.sin(rightPhase * Math.PI); // 0 → 1 → 0
                            } else {
                                // Left side loop: center → full left → center
                                const leftPhase = (f8Cycle - 0.5) * 2; // 0 to 1
                                panPosition = -Math.sin(leftPhase * Math.PI); // 0 → -1 → 0
                            }
                            // Add subtle depth variation (quieter at the "crossing point" of the 8)
                            const f8DepthPhase = Math.abs(Math.sin(f8Cycle * 2 * Math.PI));
                            window._quadrantDepthMultiplier = 0.7 + 0.3 * f8DepthPhase; // 0.7 to 1.0
                            break;
                        case 'leftright':
                            panPosition = Math.sin(angle);
                            break;
                        case 'frontback':
                            panPosition = Math.cos(angle) * 0.5;
                            break;
                        case 'random':
                            if (Math.random() > 0.9) {
                                panPosition = (Math.random() * 2 - 1);
                            }
                            break;
                        case 'quadrant':
                            // 360-degree circular sound: Right -> Back(quiet) -> Left -> Front -> repeat
                            // Creates immersive feeling of sound orbiting around your head
                            const fullCycle = (angle / (2 * Math.PI)); // cycles (may be >1)
                            const cyclePos = fullCycle - Math.floor(fullCycle); // 0..1 within cycle
                            const segment = Math.floor(cyclePos * 4); // 0=right, 1=back, 2=left, 3=front
                            const segmentPhase = (cyclePos * 4) - segment; // 0..1 within segment

                            // Pan positions: Right(1) -> Center(0) -> Left(-1) -> Center(0)
                            const panAnchors = [1, 0, -1, 0];
                            const panA = panAnchors[segment];
                            const panB = panAnchors[(segment + 1) % panAnchors.length];

                            // Depth/volume multipliers: Right(1.0) -> Back(0.55) -> Left(1.0) -> Front(1.0)
                            // Back position is quieter to simulate sound being behind your head
                            const depthAnchors = [1.0, 0.55, 1.0, 1.0];
                            const depthA = depthAnchors[segment];
                            const depthB = depthAnchors[(segment + 1) % depthAnchors.length];

                            // Smooth easing for more natural circular motion (ease-in-out)
                            const easeInOut = (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                            const smoothPhase = easeInOut(segmentPhase);

                            // Interpolate pan position with easing
                            panPosition = panA + (panB - panA) * smoothPhase;

                            // Store depth multiplier for gain calculation (accessed below)
                            // Using a variable name that won't conflict
                            window._quadrantDepthMultiplier = depthA + (depthB - depthA) * smoothPhase;
                            break;
                        default:
                            panPosition = Math.sin(angle);
                    }
                    
                    // Apply intensity to pan position
                    panPosition *= currentIntensity;
                    
                    // CRITICAL FIX: Normalized gain distribution to prevent clipping
                    // Total energy must equal 1.0 to prevent gain accumulation
                    const normalizationFactor = 0.5; // Base gain per channel before panning

                    // Quadrant uses HARD panning (no cross-channel) for clear L/R separation
                    const isHardPan = currentMovement === 'quadrant';
                    const crossChannelMix = isHardPan ? 0 : 0.15; // Zero bleeding for quadrant

                    // For 'quadrant' and 'figure8' patterns, apply depth simulation
                    // Creates immersive 3D sound by varying volume based on perceived position
                    const use3DDepth = currentMovement === 'quadrant' || currentMovement === 'figure8';
                    const depthGainMultiplier = use3DDepth
                        ? (window._quadrantDepthMultiplier || 1.0)
                        : 1.0;

                    // Main channel gains - Quadrant uses hard panning for maximum separation
                    let leftChannelGain, rightChannelGain;
                    if (isHardPan) {
                        // HARD PAN: When right, left is silent. When left, right is silent.
                        // panPosition: -1 = full left, 0 = center, +1 = full right
                        if (panPosition > 0.1) {
                            // Panning right: left ear gets less/none
                            leftChannelGain = Math.max(0, 1 - panPosition * 2); // Drops to 0 at pan=0.5+
                            rightChannelGain = 1;
                        } else if (panPosition < -0.1) {
                            // Panning left: right ear gets less/none
                            leftChannelGain = 1;
                            rightChannelGain = Math.max(0, 1 + panPosition * 2); // Drops to 0 at pan=-0.5+
                        } else {
                            // Center (back/front): both ears equal
                            leftChannelGain = 0.5;
                            rightChannelGain = 0.5;
                        }
                    } else {
                        // Standard soft panning for other patterns
                        leftChannelGain = (1 - panPosition) * 0.5; // 0.0 to 1.0
                        rightChannelGain = (1 + panPosition) * 0.5; // 0.0 to 1.0
                    }

                    // Apply depth multiplier for 3D spatial patterns
                    const targetLeftGain = Math.max(0.001, leftChannelGain * normalizationFactor * depthGainMultiplier);
                    const targetRightGain = Math.max(0.001, rightChannelGain * normalizationFactor * depthGainMultiplier);

                    // Cross-channel gains - ZERO for quadrant (hard pan), small for others
                    const targetLeftToRight = isHardPan ? 0.001 : Math.max(0.001, rightChannelGain * crossChannelMix * normalizationFactor);
                    const targetRightToLeft = isHardPan ? 0.001 : Math.max(0.001, leftChannelGain * crossChannelMix * normalizationFactor);

                    // Delay/cross-delay gains - minimal for quadrant to keep separation clean
                    const delayBase = isHardPan ? 0.02 : 0.05 * currentSpatialDepth;
                    const crossDelayBase = isHardPan ? 0 : 0.03 * currentSpatialDepth;
                    const targetDelayLeft = Math.max(0.0001, delayBase * Math.abs(panPosition));
                    const targetDelayRight = Math.max(0.0001, delayBase * Math.abs(panPosition));
                    const targetCrossDelayLeft = Math.max(0.0001, crossDelayBase * Math.abs(panPosition));
                    const targetCrossDelayRight = Math.max(0.0001, crossDelayBase * Math.abs(panPosition));
                    
                    // Use exponentialRampToValueAtTime for smoother transitions (prevents clicks better than linear)
                    const now = ctx.currentTime;
                    const rampSec = 0.1; // 100ms ramp for perceptible movement
                    const rampTime = now + rampSec;
                    
                    // Clamp to prevent automation errors
                    const clamp = (val) => Math.max(0.0001, Math.min(1, val));
                    
                    nodes.leftToLeftGain.gain.setValueAtTime(clamp(nodes.leftToLeftGain.gain.value), now);
                    nodes.leftToLeftGain.gain.exponentialRampToValueAtTime(clamp(targetLeftGain), rampTime);
                    
                    nodes.rightToRightGain.gain.setValueAtTime(clamp(nodes.rightToRightGain.gain.value), now);
                    nodes.rightToRightGain.gain.exponentialRampToValueAtTime(clamp(targetRightGain), rampTime);
                    
                    nodes.leftToRightGain.gain.setValueAtTime(clamp(nodes.leftToRightGain.gain.value), now);
                    nodes.leftToRightGain.gain.exponentialRampToValueAtTime(clamp(targetLeftToRight), rampTime);
                    
                    nodes.rightToLeftGain.gain.setValueAtTime(clamp(nodes.rightToLeftGain.gain.value), now);
                    nodes.rightToLeftGain.gain.exponentialRampToValueAtTime(clamp(targetRightToLeft), rampTime);

                    // Ramp delay/cross-delay gains as well to enhance spatial cues
                    if (nodes.delayGainLeft) {
                        nodes.delayGainLeft.gain.setValueAtTime(clamp(nodes.delayGainLeft.gain.value), now);
                        nodes.delayGainLeft.gain.exponentialRampToValueAtTime(clamp(targetDelayLeft), rampTime);
                    }
                    if (nodes.delayGainRight) {
                        nodes.delayGainRight.gain.setValueAtTime(clamp(nodes.delayGainRight.gain.value), now);
                        nodes.delayGainRight.gain.exponentialRampToValueAtTime(clamp(targetDelayRight), rampTime);
                    }
                    if (nodes.crossGainLeft) {
                        nodes.crossGainLeft.gain.setValueAtTime(clamp(nodes.crossGainLeft.gain.value), now);
                        nodes.crossGainLeft.gain.exponentialRampToValueAtTime(clamp(targetCrossDelayLeft), rampTime);
                    }
                    if (nodes.crossGainRight) {
                        nodes.crossGainRight.gain.setValueAtTime(clamp(nodes.crossGainRight.gain.value), now);
                        nodes.crossGainRight.gain.exponentialRampToValueAtTime(clamp(targetCrossDelayRight), rampTime);
                    }
                    
                    // Increment time according to interval (seconds)
                    time += ROTATION_INTERVAL_MS / 1000;
                }, ROTATION_INTERVAL_MS);
            };

            const visualize = () => {
                if (!analyserRef.current) return;

                const analyser = analyserRef.current;
                const bufferLength = analyser.frequencyBinCount;
                const frequencyData = new Uint8Array(bufferLength);
                const waveformData = new Uint8Array(bufferLength);

                // Particles state for particle visualizer (per canvas)
                let particlesDesktop = [];
                let particlesMobile = [];
                let particlesFullscreen = [];
                const maxParticles = 100;

                const drawOnCanvas = (canvas, particles) => {
                    if (!canvas) return particles;
                    const ctx = canvas.getContext('2d');
                    const visType = visualizerTypeRef.current;
                    const visualGain = Math.max(0.1, Math.min(visualWaveGainRef.current / 0.5, 1));
                    const bgColor = darkMode ? '#1a2332' : '#0a0a0a';

                    // Clear canvas
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    if (visType === 'bars') {
                        const barWidth = (canvas.width / bufferLength) * 2.5;
                        let x = 0;
                        for (let i = 0; i < bufferLength; i++) {
                            const barHeight = ((frequencyData[i] / 255) * canvas.height) * visualGain;
                            const hue = (i / bufferLength) * 360;
                            ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                            ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                            x += barWidth + 1;
                        }
                    } else if (visType === 'waveform') {
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = '#4ade80';
                        ctx.beginPath();
                        const sliceWidth = canvas.width / bufferLength;
                        let x = 0;
                        for (let i = 0; i < bufferLength; i++) {
                            const v = waveformData[i] / 128.0;
                            const y = (v * canvas.height / 2) * visualGain;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                            x += sliceWidth;
                        }
                        ctx.lineTo(canvas.width, canvas.height / 2);
                        ctx.stroke();
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#4ade80';
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    } else if (visType === 'circular') {
                        const centerX = canvas.width / 2;
                        const centerY = canvas.height / 2;
                        const radius = Math.min(centerX, centerY) * 0.6;
                        const bars = 64;
                        for (let i = 0; i < bars; i++) {
                            const freqIndex = Math.floor(i * bufferLength / bars);
                            const amplitude = (frequencyData[freqIndex] / 255) * visualGain;
                            const angle = (i / bars) * Math.PI * 2;
                            const innerR = radius * 0.3;
                            const outerR = radius + (amplitude * radius * 0.8);
                            const hue = (i / bars) * 360;
                            ctx.beginPath();
                            ctx.moveTo(centerX + Math.cos(angle) * innerR, centerY + Math.sin(angle) * innerR);
                            ctx.lineTo(centerX + Math.cos(angle) * outerR, centerY + Math.sin(angle) * outerR);
                            ctx.strokeStyle = `hsl(${hue}, 80%, 60%)`;
                            ctx.lineWidth = 3;
                            ctx.stroke();
                        }
                    } else if (visType === 'mirrored') {
                        const barWidth = (canvas.width / bufferLength) * 2.5;
                        let x = 0;
                        const centerY = canvas.height / 2;

                        // Draw center line
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(0, centerY);
                        ctx.lineTo(canvas.width, centerY);
                        ctx.stroke();

                        for (let i = 0; i < bufferLength; i++) {
                            const barHeight = ((frequencyData[i] / 255) * centerY * 0.9) * visualGain;

                            // Top bars - blues -> yellow -> orange -> red (no greens)
                            const topGradient = ctx.createLinearGradient(0, centerY - barHeight, 0, centerY);
                            topGradient.addColorStop(0, `hsl(0, 90%, 50%)`);     // Red (loudest)
                            topGradient.addColorStop(0.12, `hsl(15, 90%, 50%)`);  // Orange-red
                            topGradient.addColorStop(0.25, `hsl(35, 95%, 50%)`);  // Orange
                            topGradient.addColorStop(0.38, `hsl(50, 90%, 50%)`);  // Yellow
                            topGradient.addColorStop(0.5, `hsl(200, 80%, 55%)`);  // Light blue
                            topGradient.addColorStop(0.65, `hsl(210, 80%, 50%)`); // Sky blue
                            topGradient.addColorStop(0.8, `hsl(220, 75%, 55%)`);  // Blue
                            topGradient.addColorStop(0.92, `hsl(230, 70%, 55%)`); // Medium blue
                            topGradient.addColorStop(1, `hsl(240, 70%, 60%)`);    // Deep blue (center)
                            ctx.fillStyle = topGradient;
                            ctx.fillRect(x, centerY - barHeight, barWidth, barHeight);

                            // Bottom bars (reflection - same spectrum, faded)
                            const bottomGradient = ctx.createLinearGradient(0, centerY, 0, centerY + barHeight);
                            bottomGradient.addColorStop(0, `hsla(240, 70%, 60%, 0.8)`);    // Deep blue at center
                            bottomGradient.addColorStop(0.08, `hsla(230, 70%, 55%, 0.75)`); // Medium blue
                            bottomGradient.addColorStop(0.2, `hsla(220, 75%, 55%, 0.65)`);  // Blue
                            bottomGradient.addColorStop(0.35, `hsla(210, 80%, 50%, 0.55)`); // Sky blue
                            bottomGradient.addColorStop(0.5, `hsla(200, 80%, 55%, 0.45)`);  // Light blue
                            bottomGradient.addColorStop(0.62, `hsla(50, 90%, 50%, 0.4)`);   // Yellow
                            bottomGradient.addColorStop(0.75, `hsla(35, 95%, 50%, 0.35)`);  // Orange
                            bottomGradient.addColorStop(0.88, `hsla(15, 90%, 50%, 0.3)`);   // Orange-red
                            bottomGradient.addColorStop(1, `hsla(0, 90%, 45%, 0.25)`);     // Red (faded)
                            ctx.fillStyle = bottomGradient;
                            ctx.fillRect(x, centerY, barWidth, barHeight);

                            x += barWidth + 1;
                        }
                    } else if (visType === 'particles') {
                        const avgFreq = frequencyData.reduce((a, b) => a + b, 0) / bufferLength;
                        if (avgFreq > 50 && particles.length < maxParticles) {
                            particles.push({
                                x: Math.random() * canvas.width,
                                y: canvas.height,
                                vx: (Math.random() - 0.5) * 4,
                                vy: -Math.random() * 5 - 2,
                                life: 1,
                                hue: Math.random() * 360,
                                size: Math.random() * 4 + 2
                            });
                        }
                        particles = particles.filter(p => p.life > 0);
                        particles.forEach(p => {
                            p.x += p.vx;
                            p.y += p.vy;
                            p.vy += 0.05;
                            p.life -= 0.015;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                            ctx.fillStyle = `hsla(${p.hue}, 80%, 60%, ${p.life})`;
                            ctx.fill();
                        });
                    }
                    return particles;
                };

                const draw = () => {
                    animationFrameRef.current = requestAnimationFrame(draw);

                    // Get audio data once
                    analyser.getByteFrequencyData(frequencyData);
                    analyser.getByteTimeDomainData(waveformData);

                    // Draw on all available canvases
                    if (canvasRef.current) {
                        particlesDesktop = drawOnCanvas(canvasRef.current, particlesDesktop);
                    }
                    if (mobileCanvasRef.current) {
                        particlesMobile = drawOnCanvas(mobileCanvasRef.current, particlesMobile);
                    }
                    if (fullscreenCanvasRef.current) {
                        particlesFullscreen = drawOnCanvas(fullscreenCanvasRef.current, particlesFullscreen);
                    }
                };

                draw();
            };

            // File validation helper
            const validateFile = (file) => {
                // Check for empty files
                if (file.size === 0) {
                    return { valid: false, reason: 'empty', file };
                }
                
                // Check MIME type
                if (!SUPPORTED_MIME_TYPES.includes(file.type)) {
                    return { valid: false, reason: 'unsupported', file };
                }
                
                return { valid: true, file };
            };

            // File size formatter
            const formatFileSize = (bytes) => {
                if (bytes === 0) return '0 B';
                if (bytes < 1024) return `${bytes} B`;
                if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
                return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
            };

            // File type formatter
            const formatFileType = (mimeType) => {
                const typeMap = {
                    'audio/mpeg': 'MP3',
                    'audio/wav': 'WAV',
                    'audio/wave': 'WAV',
                    'audio/ogg': 'OGG',
                    'audio/x-wav': 'WAV'
                };
                return typeMap[mimeType] || 'Audio';
            };

            const SESSION_DEFAULT_PROFILE = 'default';

            const getPresetLabel = React.useCallback(() => {
                const presetMatch = allPresets.find(preset => preset.id === activePresetId);
                if (presetMatch) {
                    return presetMatch.name || presetMatch.label || 'Custom preset';
                }
                const defaultMode = MODE_LIBRARY.find(mode => mode.id === activePresetId);
                if (defaultMode) {
                    return defaultMode.label;
                }
                return MODE_LIBRARY[modeIndex]?.label || 'Focus';
            }, [activePresetId, allPresets, modeIndex]);

            const getSessionLoggingApi = () => {
                if (typeof window === 'undefined' || typeof indexedDB === 'undefined') {
                    return null;
                }
                return window.SessionLogging || null;
            };

            const handleSessionError = React.useCallback(async (error, phase) => {
                if (!error) {
                    return;
                }
                console.error(`[SessionLogger] Error during ${phase}:`, error);
                if (error.name === 'QuotaExceededError') {
                    const sessionApi = getSessionLoggingApi();
                    if (sessionApi?.estimateStorageUsage) {
                        try {
                            const stats = await sessionApi.estimateStorageUsage();
                            const approx = formatFileSize(stats.approxBytes || 0);
                            showToast(`Session log full (~${approx}). Use the Insights panel to clear history.`, 'warning');
                            return;
                        } catch (statsError) {
                            console.warn('[SessionLogger] Failed to estimate storage usage:', statsError);
                        }
                    }
                    showToast('Session log full. Use Insights actions to clear old sessions.', 'warning');
                } else if (error.name === 'VersionError') {
                    showToast('Session log corrupted. Rebuilding...', 'error');
                    try {
                        const sessionApi = getSessionLoggingApi();
                        if (sessionApi?.resetDatabase) {
                            await sessionApi.resetDatabase();
                            showToast('Session log reset. Try your action again.', 'success');
                        }
                    } catch (resetErr) {
                        console.error('[SessionLogger] Failed to reset storage:', resetErr);
                    }
                } else {
                    showToast('Session logging unavailable. See console for details.', 'warning');
                }
            }, [showToast]);

            const startSession = React.useCallback(async ({ track, ritualUsed = false } = {}) => {
                const sessionApi = getSessionLoggingApi();
                if (!sessionApi) {
                    return null;
                }
                if (!track) {
                    console.warn('[SessionLogger] Missing track metadata; session not recorded.');
                    return null;
                }
                if (activeSessionIdRef.current) {
                    return activeSessionIdRef.current;
                }

                const record = {
                    profileId: SESSION_DEFAULT_PROFILE,
                    timestamp: Date.now(),
                    trackId: track.id ?? track.url ?? track.name ?? `track-${Date.now()}`,
                    trackName: track.name || track.label || 'Untitled Track',
                    presetId: activePresetId,
                    presetLabel: getPresetLabel(),
                    ritualUsed: Boolean(ritualUsed),
                    duration: 0,
                    hrAvg: null,
                    hrMax: null,
                    moodBefore: null,
                    moodAfter: null,
                    notes: '',
                    endedManually: false
                };

                try {
                    if (performance?.mark) {
                        performance.mark('session-start-begin');
                    }
                    const sessionId = await sessionApi.addSession(record);
                    setActiveSessionId(sessionId);
                    activeSessionIdRef.current = sessionId;
                    if (performance?.mark) {
                        performance.mark('session-start-end');
                        const measure = performance.measure('session-start', 'session-start-begin', 'session-start-end');
                        performance.clearMarks('session-start-begin');
                        performance.clearMarks('session-start-end');
                        performance.clearMeasures('session-start');
                        console.log(`[SessionLogger] Session started: ${sessionId} in ${measure.duration.toFixed(2)}ms`);
                    } else {
                        console.log(`[SessionLogger] Session started: ${sessionId}`);
                    }
                    return sessionId;
                } catch (error) {
                    await handleSessionError(error, 'start');
                    return null;
                }
            }, [activePresetId, getPresetLabel, handleSessionError]);

            const endSession = React.useCallback(async (manual = false) => {
                const sessionApi = getSessionLoggingApi();
                if (!sessionApi || !activeSessionIdRef.current) {
                    return;
                }
                const sessionId = activeSessionIdRef.current;
                setActiveSessionId(null);
                activeSessionIdRef.current = null;
                try {
                    const session = await sessionApi.getSession(sessionId);
                    if (!session) {
                        console.warn('[SessionLogger] Session missing during end call:', sessionId);
                        return;
                    }
                    const rawDuration = (Date.now() - session.timestamp) / 1000;
                    const durationSeconds = Number(rawDuration.toFixed(1));
                    await sessionApi.updateSession(sessionId, {
                        duration: durationSeconds,
                        endedManually: manual
                    });
                    console.log(`[SessionLogger] Session ended: ${sessionId}, duration: ${durationSeconds}s`);

                    // Story 4-2: Trigger check-in modal after session ends
                    previousFocusRef.current = document.activeElement;
                    setCheckInSessionId(sessionId);
                    setShowCheckInModal(true);
                } catch (error) {
                    await handleSessionError(error, 'end');
                }
            }, [handleSessionError]);

            const clearProfileSessions = React.useCallback(async (profileId = SESSION_DEFAULT_PROFILE) => {
                const sessionApi = getSessionLoggingApi();
                if (!sessionApi) {
                    showToast('Session logging not supported in this browser.', 'warning');
                    return 0;
                }
                if (activeSessionIdRef.current) {
                    await endSession(true);
                }
                try {
                    const deletedCount = await sessionApi.clearProfile(profileId);
                    if (deletedCount > 0) {
                        showToast(`${deletedCount} sessions deleted`, 'success');
                    } else {
                        showToast('No sessions found for this profile.', 'info');
                    }
                    console.log(`[SessionLogger] Cleared ${deletedCount} sessions for profile "${profileId}"`);
                    return deletedCount;
                } catch (error) {
                    await handleSessionError(error, 'clear-profile');
                    return 0;
                }
            }, [endSession, handleSessionError, showToast]);

            const clearSessionsOlderThanDays = React.useCallback(async (days = 30, profileId = SESSION_DEFAULT_PROFILE) => {
                const sessionApi = getSessionLoggingApi();
                if (!sessionApi) {
                    showToast('Session logging not supported in this browser.', 'warning');
                    return 0;
                }
                try {
                    const deletedCount = await sessionApi.clearSessionsOlderThanDays(days, profileId);
                    if (deletedCount > 0) {
                        showToast(`${deletedCount} sessions older than ${days} days deleted`, 'success');
                    } else {
                        showToast(`No sessions older than ${days} days to delete.`, 'info');
                    }
                    console.log(`[SessionLogger] Cleared ${deletedCount} sessions older than ${days} days for "${profileId}"`);
                    return deletedCount;
                } catch (error) {
                    await handleSessionError(error, 'trim-old');
                    return 0;
                }
            }, [handleSessionError, showToast]);

            // Story 4-2: Check-in modal handlers
            const handleCheckInSubmit = React.useCallback(async (data) => {
                if (!checkInSessionId) return;

                const sessionApi = getSessionLoggingApi();
                if (!sessionApi) {
                    showToast('Session logging not available', 'warning');
                    return;
                }

                try {
                    await sessionApi.updateSession(checkInSessionId, {
                        moodAfter: data.moodAfter,
                        notes: data.notes || ''
                    });

                    setShowCheckInModal(false);
                    setCheckInSessionId(null);
                    showToast('Session saved', 'success');

                    // Restore focus to previous element
                    if (previousFocusRef.current && previousFocusRef.current.focus) {
                        previousFocusRef.current.focus();
                    }
                } catch (err) {
                    console.error('[SessionLogger] Failed to save check-in:', err);
                    showToast('Failed to save check-in', 'error');
                }
            }, [checkInSessionId, showToast]);

            const handleCheckInSkip = React.useCallback(() => {
                setShowCheckInModal(false);
                setCheckInSessionId(null);
                showToast('Check-in skipped', 'info');

                // Restore focus to previous element
                if (previousFocusRef.current && previousFocusRef.current.focus) {
                    previousFocusRef.current.focus();
                }
            }, [showToast]);

            const handleClearSessions = async () => {
                if (isClearingSessions) {
                    return;
                }
                setIsClearingSessions(true);
                try {
                    await clearProfileSessions(SESSION_DEFAULT_PROFILE);
                } finally {
                    setIsClearingSessions(false);
                }
            };

            const handleTrimOldSessions = async () => {
                if (isTrimmingSessions) {
                    return;
                }
                setIsTrimmingSessions(true);
                try {
                    await clearSessionsOlderThanDays(30, SESSION_DEFAULT_PROFILE);
                } finally {
                    setIsTrimmingSessions(false);
                }
            };

            // ============================================================
            // Story 5-1: Sensor Connection Handlers (AC5, AC6)
            // ============================================================

            // Error code constants
            const SENSOR_ERRORS = {
                BT_NOT_SUPPORTED: { code: 'BT_NOT_SUPPORTED', message: 'Bluetooth not supported in this browser.' },
                SERIAL_NOT_SUPPORTED: { code: 'SERIAL_NOT_SUPPORTED', message: 'Serial not supported in this browser.' },
                PERMISSION_DENIED: { code: 'PERMISSION_DENIED', message: 'Permission needed to connect your sensor. Please allow when prompted.' },
                DEVICE_NOT_FOUND: { code: 'DEVICE_NOT_FOUND', message: "Couldn't find your device. Make sure it's powered on and nearby." },
                CONNECTION_FAILED: { code: 'CONNECTION_FAILED', message: 'Connection failed. Try turning your device off and on.' },
                TIMEOUT: { code: 'TIMEOUT', message: 'No devices found. Make sure your sensor is powered on.' },
                USER_CANCELLED: { code: 'USER_CANCELLED', message: 'Connection cancelled.' }
            };

            const CONNECTION_TIMEOUT = 10000; // 10 seconds

            // Refresh consented devices list from IndexedDB
            const refreshConsentedDevices = React.useCallback(async () => {
                const consentApi = getSensorConsentApi();
                if (!consentApi) return;
                try {
                    const devices = await consentApi.getConsentedDevices();
                    setConsentedDevices(devices);
                } catch (err) {
                    console.error('[SensorBridge] Failed to refresh consented devices:', err);
                }
            }, []);

            // Handle initiating Bluetooth connection
            const handleConnectBluetooth = React.useCallback(() => {
                if (!bluetoothSupported) {
                    showToast(SENSOR_ERRORS.BT_NOT_SUPPORTED.message, 'error');
                    return;
                }
                // Check if we should skip consent modal
                if (skipSensorConsent) {
                    startBluetoothScan();
                } else {
                    setPendingSensorType('bluetooth');
                    setShowSensorConsentModal(true);
                }
            }, [bluetoothSupported, skipSensorConsent, showToast]);

            // Handle initiating Serial connection
            const handleConnectSerial = React.useCallback(() => {
                if (!serialSupported) {
                    showToast(SENSOR_ERRORS.SERIAL_NOT_SUPPORTED.message, 'error');
                    return;
                }
                // Check if we should skip consent modal
                if (skipSensorConsent) {
                    startSerialConnection();
                } else {
                    setPendingSensorType('serial');
                    setShowSensorConsentModal(true);
                }
            }, [serialSupported, skipSensorConsent, showToast]);

            // Start Bluetooth scanning with Heart Rate Service filter (AC5)
            const startBluetoothScan = React.useCallback(async () => {
                setShowSensorConsentModal(false);
                setSensorStatus('scanning');
                setSensorError(null);
                isManualDisconnectRef.current = false; // Story 5-2: Reset manual disconnect flag

                const timeoutId = setTimeout(() => {
                    if (sensorStatus === 'scanning') {
                        setSensorStatus('error');
                        setSensorError(SENSOR_ERRORS.TIMEOUT);
                        showToast(SENSOR_ERRORS.TIMEOUT.message, 'error');
                    }
                }, CONNECTION_TIMEOUT);

                try {
                    // Request device with Heart Rate Service filter (0x180D)
                    const device = await navigator.bluetooth.requestDevice({
                        filters: [{ services: ['heart_rate'] }],
                        optionalServices: ['battery_service']
                    });

                    clearTimeout(timeoutId);
                    setSensorStatus('connecting');

                    // Store device reference for later disconnect
                    bluetoothDeviceRef.current = device;

                    // Connect to GATT server
                    const server = await device.gatt.connect();
                    console.log('[SensorBridge] Connected to GATT server:', device.name);

                    // Story 5-2: Subscribe to Heart Rate Measurement characteristic (AC1)
                    const hrService = await server.getPrimaryService('heart_rate');
                    const hrCharacteristic = await hrService.getCharacteristic('heart_rate_measurement');
                    hrCharacteristicRef.current = hrCharacteristic;

                    // Set up HR notification handler
                    hrCharacteristic.addEventListener('characteristicvaluechanged', (event) => {
                        performance.mark('hr-notification-received');
                        const dataView = event.target.value;

                        // Parse HR Measurement per Bluetooth spec (flags byte + HR value)
                        if (!dataView || dataView.byteLength < 2) return;
                        const flags = dataView.getUint8(0);
                        const is16Bit = (flags & 0x01) === 1;
                        let heartRate = is16Bit ? dataView.getUint16(1, true) : dataView.getUint8(1);

                        // Sanity check
                        if (heartRate < 30 || heartRate > 250) return;

                        console.log(`[SensorBridge] HR: ${heartRate} bpm`);
                        setCurrentHR(heartRate);

                        // Add to history buffer (rolling 60-second window)
                        const now = Date.now();
                        setHrHistory(prev => {
                            const cutoff = now - 60000;
                            const filtered = prev.filter(entry => entry.timestamp > cutoff);
                            const updated = [...filtered, { hr: heartRate, timestamp: now }];
                            hrHistoryRef.current = updated;
                            return updated;
                        });

                        performance.mark('hr-state-updated');
                        performance.measure('hr-update-latency', 'hr-notification-received', 'hr-state-updated');
                    });

                    await hrCharacteristic.startNotifications();
                    console.log('[SensorBridge] HR notifications started');

                    // Store consent record (AC6)
                    const consentApi = getSensorConsentApi();
                    if (consentApi) {
                        const existingConsent = await consentApi.getConsent(device.id);
                        if (existingConsent) {
                            await consentApi.recordConnection(device.id);
                        } else {
                            await consentApi.addConsent({
                                deviceId: device.id,
                                deviceName: device.name || 'Unknown Bluetooth Device',
                                type: 'bluetooth',
                                scopes: ['heart_rate']
                            });
                        }
                        await refreshConsentedDevices();
                    }

                    setConnectedDevice({
                        id: device.id,
                        name: device.name || 'Bluetooth Sensor',
                        type: 'bluetooth'
                    });
                    connectedDeviceRef.current = { id: device.id, name: device.name, type: 'bluetooth' };
                    setSensorStatus('connected');
                    showToast(`Connected to ${device.name || 'Bluetooth Sensor'}`, 'success');
                    setA11yAnnouncement(`Connected to ${device.name || 'Bluetooth Sensor'}`);

                    // Story 5-2: Listen for disconnection with auto-reconnect (AC3)
                    device.addEventListener('gattserverdisconnected', async () => {
                        console.log('[SensorBridge] Device disconnected:', device.name);
                        if (isManualDisconnectRef.current) {
                            return; // User initiated, don't auto-reconnect
                        }

                        // Attempt auto-reconnect
                        console.log('[SensorBridge] Unexpected disconnect, attempting reconnection...');
                        setSensorStatus('reconnecting');
                        hrCharacteristicRef.current = null;

                        for (let i = 0; i < 6; i++) {
                            if (isManualDisconnectRef.current) return;

                            try {
                                console.log(`[SensorBridge] Reconnect attempt ${i + 1}/6`);
                                const newServer = await device.gatt.connect();

                                // Re-subscribe to HR
                                const newHrService = await newServer.getPrimaryService('heart_rate');
                                const newHrChar = await newHrService.getCharacteristic('heart_rate_measurement');
                                hrCharacteristicRef.current = newHrChar;
                                await newHrChar.startNotifications();

                                setSensorStatus('connected');
                                showToast(`Reconnected to ${device.name || 'sensor'}`, 'success');
                                console.log('[SensorBridge] Reconnected successfully');
                                return;
                            } catch (err) {
                                console.warn('[SensorBridge] Reconnect attempt failed:', err);
                            }

                            if (i < 5) await new Promise(r => setTimeout(r, 500));
                        }

                        // All attempts failed
                        setSensorStatus('disconnected');
                        setCurrentHR(null);
                        showToast("Couldn't reconnect. Please reconnect manually.", 'error');
                    });

                } catch (err) {
                    clearTimeout(timeoutId);
                    console.error('[SensorBridge] Bluetooth connection error:', err);

                    // Map error to user-friendly message
                    let errorInfo = SENSOR_ERRORS.CONNECTION_FAILED;
                    if (err.name === 'NotFoundError' || err.message?.includes('cancelled')) {
                        errorInfo = SENSOR_ERRORS.USER_CANCELLED;
                    } else if (err.name === 'SecurityError' || err.message?.includes('permission')) {
                        errorInfo = SENSOR_ERRORS.PERMISSION_DENIED;
                    }

                    setSensorStatus('error');
                    setSensorError(errorInfo);
                    if (errorInfo.code !== 'USER_CANCELLED') {
                        showToast(errorInfo.message, 'error');
                    } else {
                        showToast(errorInfo.message, 'info');
                    }
                }
            }, [sensorStatus, showToast, setA11yAnnouncement, refreshConsentedDevices]);

            // Start Serial connection (placeholder - actual parsing in Story 5-2)
            const startSerialConnection = React.useCallback(async () => {
                setShowSensorConsentModal(false);
                setSensorStatus('scanning');
                setSensorError(null);

                try {
                    // Request any serial port
                    const port = await navigator.serial.requestPort();
                    setSensorStatus('connecting');

                    // Store port reference
                    serialPortRef.current = port;

                    // Open the port with default baud rate for HR sensors
                    await port.open({ baudRate: 115200 });
                    console.log('[SensorBridge] Serial port opened');

                    // Get port info for device identification
                    const info = port.getInfo();
                    const deviceId = `serial-${info.usbVendorId || 'unknown'}-${info.usbProductId || 'unknown'}`;
                    const deviceName = `Serial Device (${info.usbVendorId || 'USB'})`;

                    // Store consent record (AC6)
                    const consentApi = getSensorConsentApi();
                    if (consentApi) {
                        const existingConsent = await consentApi.getConsent(deviceId);
                        if (existingConsent) {
                            await consentApi.recordConnection(deviceId);
                        } else {
                            await consentApi.addConsent({
                                deviceId,
                                deviceName,
                                type: 'serial',
                                scopes: ['heart_rate']
                            });
                        }
                        await refreshConsentedDevices();
                    }

                    setConnectedDevice({
                        id: deviceId,
                        name: deviceName,
                        type: 'serial'
                    });
                    connectedDeviceRef.current = { id: deviceId, name: deviceName, type: 'serial' };
                    setSensorStatus('connected');
                    showToast(`Connected to ${deviceName}`, 'success');
                    setA11yAnnouncement(`Connected to ${deviceName}`);

                } catch (err) {
                    console.error('[SensorBridge] Serial connection error:', err);

                    let errorInfo = SENSOR_ERRORS.CONNECTION_FAILED;
                    if (err.name === 'NotFoundError' || err.message?.includes('cancelled')) {
                        errorInfo = SENSOR_ERRORS.USER_CANCELLED;
                    } else if (err.name === 'SecurityError') {
                        errorInfo = SENSOR_ERRORS.PERMISSION_DENIED;
                    }

                    setSensorStatus('error');
                    setSensorError(errorInfo);
                    if (errorInfo.code !== 'USER_CANCELLED') {
                        showToast(errorInfo.message, 'error');
                    } else {
                        showToast(errorInfo.message, 'info');
                    }
                }
            }, [showToast, setA11yAnnouncement, refreshConsentedDevices]);

            // Handle consent modal confirmation
            const handleSensorConsentConfirm = React.useCallback(() => {
                if (pendingSensorType === 'bluetooth') {
                    startBluetoothScan();
                } else if (pendingSensorType === 'serial') {
                    startSerialConnection();
                }
                setPendingSensorType(null);
            }, [pendingSensorType, startBluetoothScan, startSerialConnection]);

            // Handle consent modal cancel
            const handleSensorConsentCancel = React.useCallback(() => {
                setShowSensorConsentModal(false);
                setPendingSensorType(null);
            }, []);

            // Handle reconnection to a known device
            const handleReconnectDevice = React.useCallback(async (device) => {
                if (device.type === 'bluetooth') {
                    handleConnectBluetooth();
                } else {
                    handleConnectSerial();
                }
            }, [handleConnectBluetooth, handleConnectSerial]);

            // Handle sensor disconnection
            const handleSensorDisconnect = React.useCallback(async () => {
                // Mark as manual disconnect to prevent auto-reconnect
                isManualDisconnectRef.current = true;

                // Story 5-2: Stop rule engine and clean up HR state
                if (sensorRuleEngineRef.current) {
                    clearInterval(sensorRuleEngineRef.current);
                    sensorRuleEngineRef.current = null;
                }
                if (simulatorIntervalRef.current) {
                    clearInterval(simulatorIntervalRef.current);
                    simulatorIntervalRef.current = null;
                }
                hrCharacteristicRef.current = null;
                setCurrentHR(null);
                setHrHistory([]);
                hrHistoryRef.current = [];
                consecutiveExceededRef.current = 0;
                setIsSimulating(false);
                setShowSuggestionToast(false);

                // Disconnect Bluetooth if connected
                if (bluetoothDeviceRef.current && bluetoothDeviceRef.current.gatt?.connected) {
                    try {
                        bluetoothDeviceRef.current.gatt.disconnect();
                    } catch (err) {
                        console.warn('[SensorBridge] Error disconnecting Bluetooth:', err);
                    }
                }
                bluetoothDeviceRef.current = null;

                // Close Serial port if open
                if (serialPortRef.current) {
                    try {
                        await serialPortRef.current.close();
                    } catch (err) {
                        console.warn('[SensorBridge] Error closing serial port:', err);
                    }
                }
                serialPortRef.current = null;

                setConnectedDevice(null);
                connectedDeviceRef.current = null;
                setSensorStatus('idle');
                setSensorError(null);
                showToast('Sensor disconnected', 'info');
                setA11yAnnouncement('Sensor disconnected');
            }, [showToast, setA11yAnnouncement]);

            // ============================================================
            // Story 5-2: Heart Rate Subscription & Threshold Engine
            // ============================================================

            // Parse Heart Rate Measurement characteristic (0x2A37) per Bluetooth spec
            // Bit 0 of flags byte: 0 = 8-bit HR, 1 = 16-bit HR
            const parseHeartRateMeasurement = (dataView) => {
                try {
                    if (!dataView || dataView.byteLength < 2) {
                        console.warn('[SensorBridge] Invalid HR data: insufficient bytes');
                        return null;
                    }
                    const flags = dataView.getUint8(0);
                    const is16Bit = (flags & 0x01) === 1;

                    let heartRate;
                    if (is16Bit) {
                        if (dataView.byteLength < 3) {
                            console.warn('[SensorBridge] Invalid HR data: expected 16-bit value');
                            return null;
                        }
                        heartRate = dataView.getUint16(1, true); // Little-endian
                    } else {
                        heartRate = dataView.getUint8(1);
                    }

                    // Sanity check: HR should be between 30-250 BPM
                    if (heartRate < 30 || heartRate > 250) {
                        console.warn(`[SensorBridge] HR value out of range: ${heartRate}`);
                        return null;
                    }

                    return heartRate;
                } catch (err) {
                    console.error('[SensorBridge] Error parsing HR data:', err);
                    return null;
                }
            };

            // Handle incoming HR notification
            const handleHRNotification = React.useCallback((event) => {
                performance.mark('hr-notification-received');

                const dataView = event.target.value;
                const hr = parseHeartRateMeasurement(dataView);

                if (hr !== null) {
                    console.log(`[SensorBridge] HR: ${hr} bpm`);

                    // Update current HR state
                    setCurrentHR(hr);

                    // Add to history buffer (rolling 60-second window, ~60 samples at 1Hz)
                    const now = Date.now();
                    const newEntry = { hr, timestamp: now };

                    setHrHistory(prev => {
                        const cutoff = now - 60000; // 60 seconds ago
                        const filtered = prev.filter(entry => entry.timestamp > cutoff);
                        const updated = [...filtered, newEntry];
                        hrHistoryRef.current = updated;
                        return updated;
                    });

                    performance.mark('hr-state-updated');
                    performance.measure('hr-update-latency', 'hr-notification-received', 'hr-state-updated');
                }
            }, []);

            // Subscribe to Heart Rate Measurement characteristic
            const subscribeToHeartRate = React.useCallback(async (server) => {
                try {
                    console.log('[SensorBridge] Getting Heart Rate Service...');
                    const hrService = await server.getPrimaryService('heart_rate');

                    console.log('[SensorBridge] Getting Heart Rate Measurement characteristic...');
                    const hrCharacteristic = await hrService.getCharacteristic('heart_rate_measurement');
                    hrCharacteristicRef.current = hrCharacteristic;

                    // Set up notification handler
                    hrCharacteristic.addEventListener('characteristicvaluechanged', handleHRNotification);

                    // Start notifications
                    await hrCharacteristic.startNotifications();
                    console.log('[SensorBridge] HR notifications started');

                    return true;
                } catch (err) {
                    console.error('[SensorBridge] Failed to subscribe to HR:', err);
                    setSensorError({
                        code: 'HR_SUBSCRIPTION_FAILED',
                        message: 'Could not read heart rate data from device'
                    });
                    return false;
                }
            }, [handleHRNotification]);

            // Attempt to reconnect to a disconnected BLE device
            const attemptReconnect = React.useCallback(async () => {
                const device = bluetoothDeviceRef.current;
                if (!device || isManualDisconnectRef.current) {
                    return false;
                }

                reconnectAttemptsRef.current++;
                console.log(`[SensorBridge] Reconnect attempt ${reconnectAttemptsRef.current}/6`);

                try {
                    const server = await device.gatt.connect();
                    console.log('[SensorBridge] Reconnected to GATT server');

                    // Re-subscribe to HR
                    const subscribed = await subscribeToHeartRate(server);
                    if (subscribed) {
                        reconnectAttemptsRef.current = 0;
                        setSensorStatus('connected');
                        showToast(`Reconnected to ${device.name || 'sensor'}`, 'success');
                        return true;
                    }
                } catch (err) {
                    console.warn('[SensorBridge] Reconnect attempt failed:', err);
                }

                return false;
            }, [subscribeToHeartRate, showToast]);

            // Handle unexpected disconnection with auto-reconnect (AC3)
            const handleUnexpectedDisconnect = React.useCallback(async () => {
                if (isManualDisconnectRef.current) {
                    return; // User initiated disconnect, don't auto-reconnect
                }

                console.log('[SensorBridge] Unexpected disconnect, attempting reconnection...');
                setSensorStatus('reconnecting');
                reconnectAttemptsRef.current = 0;

                // Clean up HR state temporarily
                hrCharacteristicRef.current = null;

                // Attempt reconnection every 500ms for up to 3 seconds (6 attempts)
                const maxAttempts = 6;
                const attemptInterval = 500;

                for (let i = 0; i < maxAttempts; i++) {
                    if (isManualDisconnectRef.current) {
                        return; // User disconnected during reconnect attempt
                    }

                    const success = await attemptReconnect();
                    if (success) {
                        return;
                    }

                    if (i < maxAttempts - 1) {
                        await new Promise(resolve => setTimeout(resolve, attemptInterval));
                    }
                }

                // All attempts failed
                console.log('[SensorBridge] Reconnection failed after 6 attempts');
                setSensorStatus('disconnected');
                setCurrentHR(null);
                showToast("Couldn't reconnect. Please reconnect manually.", 'error');
                setA11yAnnouncement("Couldn't reconnect to sensor. Please reconnect manually.");
            }, [attemptReconnect, showToast, setA11yAnnouncement]);

            // Handle forget device request (opens confirmation modal)
            const handleForgetDeviceRequest = React.useCallback((device) => {
                setDeviceToForget(device);
                setShowForgetDeviceModal(true);
            }, []);

            // Handle forget device confirmation (AC7)
            const handleForgetDeviceConfirm = React.useCallback(async (device) => {
                setShowForgetDeviceModal(false);
                setDeviceToForget(null);

                // Disconnect if this is the currently connected device
                if (connectedDeviceRef.current?.id === device.deviceId) {
                    await handleSensorDisconnect();
                }

                // Revoke consent in IndexedDB
                const consentApi = getSensorConsentApi();
                if (consentApi) {
                    try {
                        await consentApi.revokeConsent(device.deviceId);
                        await refreshConsentedDevices();
                        showToast(`Forgot ${device.deviceName}`, 'success');
                        console.log(`[SensorBridge] Device forgotten: ${device.deviceId}`);
                    } catch (err) {
                        console.error('[SensorBridge] Failed to forget device:', err);
                        showToast('Failed to forget device', 'error');
                    }
                }
            }, [handleSensorDisconnect, refreshConsentedDevices, showToast]);

            // Handle forget device cancel
            const handleForgetDeviceCancel = React.useCallback(() => {
                setShowForgetDeviceModal(false);
                setDeviceToForget(null);
            }, []);

            // ============================================================
            // Story 5-2: Sensor Rule Engine & Session Event Logging (AC4, AC6)
            // ============================================================

            // Log sensor event to current session (AC6)
            const logSensorEvent = React.useCallback((eventType, data = {}) => {
                const event = {
                    timestamp: Date.now(),
                    type: eventType,
                    data: {
                        hr: currentHR,
                        hrAvg: hrHistoryRef.current.length >= 10
                            ? Math.round(hrHistoryRef.current.reduce((sum, e) => sum + e.hr, 0) / hrHistoryRef.current.length)
                            : null,
                        threshold: hrThreshold,
                        ...data
                    }
                };
                console.log(`[SensorRuleEngine] Event: ${eventType}`, event.data);

                // Store in session if active (integrate with SessionLogger from Epic 4)
                if (activeSessionIdRef.current) {
                    // Session events will be collected and saved on session end
                    // For now, we track them via console and state
                }
            }, [currentHR, hrThreshold]);

            // Calculate rolling HR average
            const calculateHRAverage = React.useCallback(() => {
                const history = hrHistoryRef.current;
                if (history.length < 10) return null;
                const sum = history.reduce((acc, entry) => acc + entry.hr, 0);
                return Math.round(sum / history.length);
            }, []);

            // Handle suggestion toast response
            const handleSuggestionAccept = React.useCallback(() => {
                logSensorEvent('SUGGESTION_ACCEPTED', { presetApplied: 'calm' });
                setShowSuggestionToast(false);
                setSuggestionToastData(null);

                // Apply the calm preset
                const calmPreset = MODE_LIBRARY.find(m => m.id === 'calm');
                if (calmPreset) {
                    applyPreset(calmPreset, 'calm');
                    showToast('Switched to Calm preset', 'success');
                }
            }, [logSensorEvent, applyPreset, showToast]);

            const handleSuggestionDismiss = React.useCallback(() => {
                logSensorEvent('SUGGESTION_DISMISSED');
                setShowSuggestionToast(false);
                setSuggestionToastData(null);
            }, [logSensorEvent]);

            const handleSuggestionTimeout = React.useCallback(() => {
                logSensorEvent('SUGGESTION_TIMEOUT');
                setShowSuggestionToast(false);
                setSuggestionToastData(null);
            }, [logSensorEvent]);

            // Start the sensor rule engine (AC4)
            const startRuleEngine = React.useCallback(() => {
                if (sensorRuleEngineRef.current) {
                    clearInterval(sensorRuleEngineRef.current);
                }

                console.log('[SensorRuleEngine] Starting rule engine');
                consecutiveExceededRef.current = 0;

                // Evaluate every 10 seconds
                sensorRuleEngineRef.current = setInterval(() => {
                    const history = hrHistoryRef.current;
                    if (history.length < 10) return; // Need enough samples

                    const hrAvg = history.reduce((sum, e) => sum + e.hr, 0) / history.length;
                    const threshold = hrThreshold;

                    console.log(`[SensorRuleEngine] Evaluating: avg=${Math.round(hrAvg)} threshold=${threshold} consecutive=${consecutiveExceededRef.current}`);

                    if (hrAvg > threshold) {
                        consecutiveExceededRef.current++;

                        // Trigger after 3 consecutive checks (30 seconds)
                        if (consecutiveExceededRef.current >= 3) {
                            const now = Date.now();
                            const cooldownMs = 5 * 60 * 1000; // 5 minutes

                            // Check cooldown
                            if (now - lastThresholdTriggerRef.current < cooldownMs) {
                                console.log('[SensorRuleEngine] In cooldown, skipping trigger');
                                return;
                            }

                            // Trigger threshold exceeded
                            lastThresholdTriggerRef.current = now;
                            consecutiveExceededRef.current = 0;

                            logSensorEvent('THRESHOLD_EXCEEDED', { hr: Math.round(hrAvg), threshold });

                            // Story 5-3: Check auto-adjust mode (AC1, AC7)
                            if (autoAdjustEnabled) {
                                // Auto-apply mode: Apply preset directly with performance measurement
                                console.log('[SensorRuleEngine] Auto-applying preset: calm');
                                performance.mark('sensor-preset-start');

                                const calmPreset = MODE_LIBRARY.find(m => m.id === 'calm');
                                if (calmPreset) {
                                    applyPreset(calmPreset, 'calm');

                                    performance.mark('sensor-preset-end');
                                    const measure = performance.measure('sensor-preset-apply', 'sensor-preset-start', 'sensor-preset-end');
                                    console.log(`[SensorRuleEngine] Preset applied in ${measure.duration.toFixed(2)}ms`);

                                    logSensorEvent('AUTOMATION_APPLIED', {
                                        hr: Math.round(hrAvg),
                                        hrAvg: Math.round(hrAvg),
                                        threshold,
                                        presetApplied: 'calm',
                                        trigger: 'rule_engine',
                                        latencyMs: measure.duration
                                    });

                                    showToast('Auto-adjusted to Calm preset', 'info');
                                    setA11yAnnouncement(`Heart rate elevated. Automatically switched to Calm preset.`);
                                }
                            } else {
                                // Suggest mode: Show suggestion toast
                                console.log('[SensorRuleEngine] Threshold exceeded! Triggering suggestion');
                                logSensorEvent('SUGGESTION_SHOWN');

                                setSuggestionToastData({
                                    hr: Math.round(hrAvg),
                                    threshold,
                                    timestamp: now
                                });
                                setShowSuggestionToast(true);
                                setA11yAnnouncement(`Heart rate elevated at ${Math.round(hrAvg)} bpm. Suggestion: Switch to Calm preset.`);
                            }
                        }
                    } else {
                        // Reset consecutive counter if below threshold
                        consecutiveExceededRef.current = 0;
                    }
                }, 10000); // 10 seconds
            }, [hrThreshold, autoAdjustEnabled, logSensorEvent, applyPreset, showToast, setA11yAnnouncement]);

            // Stop the rule engine
            const stopRuleEngine = React.useCallback(() => {
                if (sensorRuleEngineRef.current) {
                    clearInterval(sensorRuleEngineRef.current);
                    sensorRuleEngineRef.current = null;
                    console.log('[SensorRuleEngine] Stopped');
                }
            }, []);

            // Start rule engine when sensor connects, stop when disconnects
            useEffect(() => {
                if (sensorStatus === 'connected' && (currentHR !== null || isSimulating)) {
                    startRuleEngine();
                } else {
                    stopRuleEngine();
                }
                return () => stopRuleEngine();
            }, [sensorStatus, currentHR, isSimulating, startRuleEngine, stopRuleEngine]);

            // Persist HR threshold to localStorage (AC7)
            useEffect(() => {
                try {
                    localStorage.setItem('mp3_8d_hr_threshold', String(hrThreshold));
                } catch (err) {
                    console.warn('[SensorBridge] Failed to persist HR threshold:', err);
                }
            }, [hrThreshold]);

            // Story 5-3: Persist auto-adjust toggle to localStorage (AC5)
            useEffect(() => {
                try {
                    localStorage.setItem('mp3_8d_auto_adjust_enabled', String(autoAdjustEnabled));
                    // Wire toggle to sensorLocked state
                    if (autoAdjustEnabled && (sensorStatus === 'connected' || isSimulating)) {
                        setSensorLocked(true);
                    } else if (!autoAdjustEnabled) {
                        setSensorLocked(false);
                    }
                } catch (err) {
                    console.warn('[SensorBridge] Failed to persist auto-adjust setting:', err);
                }
            }, [autoAdjustEnabled, sensorStatus, isSimulating]);

            // Story 6-1: Persist audio cache consent to localStorage (AC7)
            useEffect(() => {
                try {
                    localStorage.setItem('mp3_8d_audio_cache_consent', String(audioCacheConsent));
                    console.log(`[SW] Audio cache consent: ${audioCacheConsent ? 'enabled' : 'disabled'}`);
                } catch (err) {
                    console.warn('[SW] Failed to persist audio cache consent:', err);
                }
            }, [audioCacheConsent]);

            // Story 6-1: Calculate and update cache storage usage and cached URLs
            const updateCacheStorageUsage = useCallback(async () => {
                if (!('caches' in window)) {
                    setCacheStorageUsed(0);
                    setCachedAudioUrls(new Set());
                    return;
                }
                try {
                    const cache = await caches.open('audio-cache');
                    const keys = await cache.keys();
                    let totalSize = 0;
                    const urls = new Set();
                    for (const request of keys) {
                        const response = await cache.match(request);
                        if (response) {
                            const blob = await response.clone().blob();
                            totalSize += blob.size;
                            urls.add(request.url);
                        }
                    }
                    setCacheStorageUsed(totalSize);
                    setCachedAudioUrls(urls);
                } catch (err) {
                    console.warn('[SW] Failed to calculate cache storage:', err);
                    setCacheStorageUsed(0);
                    setCachedAudioUrls(new Set());
                }
            }, []);

            // Update storage usage on mount and when consent changes
            useEffect(() => {
                if (audioCacheConsent) {
                    updateCacheStorageUsage();
                } else {
                    setCacheStorageUsed(0);
                }
            }, [audioCacheConsent, updateCacheStorageUsage]);

            // Story 6-1: Clear audio cache function
            const handleClearAudioCache = useCallback(async () => {
                if (!('caches' in window)) return;
                try {
                    const deleted = await caches.delete('audio-cache');
                    if (deleted) {
                        console.log('[SW] Audio cache cleared');
                        setCacheStorageUsed(0);
                        setCachedAudioUrls(new Set());
                    }
                } catch (err) {
                    console.error('[SW] Failed to clear audio cache:', err);
                }
            }, []);

            // Story 6-1: Check if a track URL is cached (AC8)
            const isTrackCached = useCallback((track) => {
                if (!audioCacheConsent || cachedAudioUrls.size === 0) return false;
                // Check if track URL is in cached set
                if (track.url) {
                    return cachedAudioUrls.has(track.url);
                }
                return false;
            }, [audioCacheConsent, cachedAudioUrls]);

            // ============================================================
            // Story 5-2: Sensor Simulator (AC8)
            // ============================================================

            // Check for simulator mode on mount
            const simulatorEnabled = React.useMemo(() => {
                try {
                    const urlParams = new URLSearchParams(window.location.search);
                    return urlParams.get('simulate_sensor') === 'true' ||
                           localStorage.getItem('mp3_8d_simulate_sensor') === 'true';
                } catch {
                    return false;
                }
            }, []);

            // Start sensor simulation
            const startSensorSimulation = React.useCallback((config = {}) => {
                const {
                    baseHR = 70,
                    stressHR = 95,
                    stressInterval = 60000, // 60 seconds
                    stressRampDuration = 20000 // 20 seconds to ramp up
                } = config;

                if (simulatorIntervalRef.current) {
                    clearInterval(simulatorIntervalRef.current);
                }

                console.log('[SensorSimulator] Starting simulation', { baseHR, stressHR, stressInterval });

                setIsSimulating(true);
                setSensorStatus('connected');
                setConnectedDevice({
                    id: 'simulator',
                    name: 'Simulated Sensor',
                    type: 'simulator'
                });
                connectedDeviceRef.current = { id: 'simulator', name: 'Simulated Sensor', type: 'simulator' };

                let simulationStart = Date.now();
                let isInStressEvent = false;
                let stressEventStart = 0;

                // Generate HR every second
                simulatorIntervalRef.current = setInterval(() => {
                    const now = Date.now();
                    const elapsed = now - simulationStart;

                    // Check if we should start a stress event
                    if (!isInStressEvent && elapsed % stressInterval < 1000) {
                        isInStressEvent = true;
                        stressEventStart = now;
                        console.log('[SensorSimulator] Starting stress event');
                    }

                    let hr;
                    if (isInStressEvent) {
                        const stressElapsed = now - stressEventStart;
                        if (stressElapsed < stressRampDuration) {
                            // Ramping up
                            const progress = stressElapsed / stressRampDuration;
                            hr = Math.round(baseHR + (stressHR - baseHR) * progress);
                        } else if (stressElapsed < stressRampDuration * 2) {
                            // Hold at stress HR
                            hr = stressHR + Math.round((Math.random() - 0.5) * 4);
                        } else {
                            // End stress event
                            isInStressEvent = false;
                            hr = baseHR + Math.round((Math.random() - 0.5) * 10);
                        }
                    } else {
                        // Normal variation
                        hr = baseHR + Math.round((Math.random() - 0.5) * 10);
                    }

                    // Clamp to valid range
                    hr = Math.max(40, Math.min(200, hr));

                    console.log(`[SensorBridge] HR: ${hr} bpm (simulated)`);
                    setCurrentHR(hr);

                    // Add to history buffer
                    setHrHistory(prev => {
                        const cutoff = now - 60000;
                        const filtered = prev.filter(entry => entry.timestamp > cutoff);
                        const updated = [...filtered, { hr, timestamp: now }];
                        hrHistoryRef.current = updated;
                        return updated;
                    });
                }, 1000);

                showToast('Sensor simulation started', 'info');
            }, [showToast]);

            // Stop sensor simulation
            const stopSensorSimulation = React.useCallback(() => {
                if (simulatorIntervalRef.current) {
                    clearInterval(simulatorIntervalRef.current);
                    simulatorIntervalRef.current = null;
                }
                setIsSimulating(false);
                setCurrentHR(null);
                setHrHistory([]);
                hrHistoryRef.current = [];
                setSensorStatus('idle');
                setConnectedDevice(null);
                connectedDeviceRef.current = null;
                console.log('[SensorSimulator] Stopped');
                showToast('Sensor simulation stopped', 'info');
            }, [showToast]);

            // Manually set HR (for testing)
            const setSensorHR = React.useCallback((value) => {
                if (!isSimulating) {
                    console.warn('[SensorSimulator] Not in simulation mode');
                    return;
                }
                const hr = Math.max(30, Math.min(250, Math.round(value)));
                console.log(`[SensorBridge] HR: ${hr} bpm (manual)`);
                setCurrentHR(hr);

                const now = Date.now();
                setHrHistory(prev => {
                    const cutoff = now - 60000;
                    const filtered = prev.filter(entry => entry.timestamp > cutoff);
                    const updated = [...filtered, { hr, timestamp: now }];
                    hrHistoryRef.current = updated;
                    return updated;
                });
            }, [isSimulating]);

            // Expose simulator API on window for console access (AC8)
            useEffect(() => {
                window.startSensorSimulation = startSensorSimulation;
                window.stopSensorSimulation = stopSensorSimulation;
                window.setSensorHR = setSensorHR;

                return () => {
                    delete window.startSensorSimulation;
                    delete window.stopSensorSimulation;
                    delete window.setSensorHR;
                };
            }, [startSensorSimulation, stopSensorSimulation, setSensorHR]);

            const addLocalFiles = (files) => {
                const fileArray = Array.from(files);
                
                try {
                    // Show progress indicator for large batches
                    if (fileArray.length > 5) {
                        setIsProcessingFiles(true);
                        setHeroMessage(`Adding ${fileArray.length} tracks...`);
                    }
                    
                    // Validate and filter files
                    const validFiles = [];
                    const rejectedFiles = [];
                    
                    fileArray.forEach(file => {
                        const validation = validateFile(file);
                        if (validation.valid) {
                            validFiles.push(file);
                        } else {
                            rejectedFiles.push({ 
                                name: file.name, 
                                reason: validation.reason 
                            });
                        }
                    });
                    
                    // Create playlist tracks from valid files
                    const newTracks = validFiles.map((file, index) => {
                        // Remove any audio extension, not just .mp3
                        const baseName = file.name.replace(/\.(mp3|wav|ogg)$/i, '');
                        return {
                            id: Date.now() + index,
                            name: baseName,
                            source: 'local',
                            file: file,
                            url: null,
                            lastPresetId: null, // Story 3-3: Track preset for auto-restore
                            preferredPresetId: null, // Story 3-3: User can pin preset (future)
                            metadata: {
                                size: file.size,
                                type: file.type,
                                lastModified: file.lastModified
                            }
                        };
                    });
                    
                    // Update playlist
                    if (newTracks.length > 0) {
                        setPlaylist(prev => [...prev, ...newTracks]);
                        setNeedsAudio(false);
                        
                        const trackWord = newTracks.length === 1 ? 'track' : 'tracks';
                        setHeroMessage(`Added ${newTracks.length} ${trackWord}. Pick a ritual and press Start.`);
                        setA11yAnnouncement(`${newTracks.length} ${trackWord} added to playlist`);
                    }
                    
                    // Show rejection toast if needed
                    if (rejectedFiles.length > 0) {
                        const emptyCount = rejectedFiles.filter(f => f.reason === 'empty').length;
                        const unsupportedCount = rejectedFiles.filter(f => f.reason === 'unsupported').length;
                        
                        let message = '';
                        if (emptyCount > 0) {
                            message += `${emptyCount} empty file${emptyCount > 1 ? 's' : ''} rejected. `;
                        }
                        if (unsupportedCount > 0) {
                            message += `${unsupportedCount} unsupported file${unsupportedCount > 1 ? 's' : ''} rejected. Use MP3, WAV, or OGG.`;
                        }
                        
                        showToast(message, 'warning');
                        setA11yAnnouncement(message);
                    }
                } finally {
                    // Always hide progress indicator, even if errors occur
                    setIsProcessingFiles(false);
                }
            };

            const handleDrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                const files = e.dataTransfer.files;
                if (files && files.length > 0) {
                    addLocalFiles(files);
                }
                setDragActive(false);
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!dragActive) {
                    setDragActive(true);
                }
            };

            const handleDragEnter = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setDragActive(true);
            };

            const handleDragLeave = (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (e.relatedTarget && e.currentTarget.contains(e.relatedTarget)) {
                    return;
                }
                setDragActive(false);
            };

            // URL format validator
            const isValidUrl = (str) => {
                try {
                    const url = new URL(str);
                    return url.protocol === 'http:' || url.protocol === 'https:';
                } catch {
                    return false;
                }
            };

            // Unsupported service detector
            const detectUnsupportedService = (url) => {
                const urlLower = url.toLowerCase();
                if (urlLower.includes('youtube.com') || urlLower.includes('youtu.be')) {
                    return { service: 'YouTube', supported: false };
                }
                if (urlLower.includes('spotify.com')) {
                    return { service: 'Spotify', supported: false };
                }
                return { supported: true };
            };

            // Stream URL validator (async)
            const validateStreamUrl = async (url) => {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                try {
                    const response = await fetch(url, {
                        method: 'HEAD',
                        mode: 'cors',
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                    
                    if (response.ok) {
                        return { valid: true, url };
                    } else {
                        return { 
                            valid: false, 
                            reason: 'unreachable',
                            status: response.status 
                        };
                    }
                } catch (err) {
                    clearTimeout(timeoutId);
                    
                    if (err.name === 'AbortError') {
                        return { valid: false, reason: 'timeout' };
                    }
                    
                    // CORS or network error
                    return { valid: false, reason: 'cors', error: err };
                }
            };

            const addUrl = async () => {
                const url = urlInput.trim();
                
                // Ignore empty input
                if (!url) return;
                
                // 1. Format validation
                if (!isValidUrl(url)) {
                    showToast('Invalid URL format. Use: https://example.com/song.mp3', 'error');
                    setA11yAnnouncement('Invalid URL format');
                    return;
                }
                
                // 2. Unsupported service detection
                const serviceCheck = detectUnsupportedService(url);
                if (!serviceCheck.supported) {
                    showToast(
                        `${serviceCheck.service} playback requires authenticated proxy. Direct MP3 URLs only.`,
                        'warning'
                    );
                    setA11yAnnouncement(`${serviceCheck.service} not supported`);
                    return;
                }
                
                // 3. Show validating state
                setIsValidatingUrl(true);
                setHeroMessage('Validating stream URL...');
                
                // 4. HEAD request validation with cleanup tracking
                try {
                    const validation = await validateStreamUrl(url);
                    
                    // Check if component still mounted
                    if (!urlValidationControllerRef.current) {
                        return; // Component unmounted during validation
                    }
                    
                    setIsValidatingUrl(false);
                    
                    if (!validation.valid) {
                        let message = '';
                        
                        switch (validation.reason) {
                            case 'cors':
                                message = 'Stream blocked by CORS. Use direct MP3 link or enable server CORS.';
                                break;
                            case 'timeout':
                                message = 'Request timeout (5s). Server unreachable or slow.';
                                break;
                            case 'unreachable':
                                message = `Stream unreachable (${validation.status}). Check URL and try again.`;
                                break;
                            default:
                                message = 'Unable to validate stream. Check URL.';
                        }
                        
                        showToast(message, 'error');
                        setA11yAnnouncement(message);
                        setHeroMessage('Stream validation failed. Try another URL.');
                        return;
                    }
                    
                    // 5. Add validated URL to playlist
                    const newTrack = {
                        id: Date.now(),
                        name: 'Remote Track',
                        source: 'url',
                        url: url,
                        originalUrl: url,
                        lastPresetId: null, // Story 3-3: Track preset for auto-restore
                        preferredPresetId: null // Story 3-3: User can pin preset (future)
                    };
                    
                    setPlaylist(prev => [...prev, newTrack]);
                    setUrlInput('');
                    setNeedsAudio(false);
                    setHeroMessage('Stream validated and added. Start your ritual to hear it.');
                    setA11yAnnouncement('Stream added to playlist');
                } catch (err) {
                    // Handle unexpected errors
                    if (urlValidationControllerRef.current) {
                        setIsValidatingUrl(false);
                        showToast('Validation error. Please try again.', 'error');
                    }
                }
            };

            const playTrack = async (index, options = {}) => {
                const { ritualUsed, shouldEndActiveSession = true } = options;
                const activePlaylist = playlistRef.current || playlist;
                const track = activePlaylist[index];
                if (!track) return;

                if (typeof ritualUsed !== 'undefined') {
                    sessionRitualFlagRef.current = ritualUsed;
                }

                if (activeSessionIdRef.current && shouldEndActiveSession) {
                    await endSession(true);
                }
                
                // Story 3-3: Auto-restore last-used preset for this track
                if (track.lastPresetId) {
                    const presets = getAllPresets();
                    const savedPreset = presets.find(p => p.id === track.lastPresetId);
                    
                    if (savedPreset) {
                        // Restore the preset if it's different from current
                        if (activePresetId !== track.lastPresetId) {
                            applyPreset(savedPreset.preset, savedPreset.id);
                            showToast(`Restored ${savedPreset.name} preset for "${track.name}"`, 'info');
                            setA11yAnnouncement(`Restored ${savedPreset.name} preset`);
                        }
                    } else {
                        // Preset was deleted, fallback to focus
                        console.warn(`[AutoRestore] Preset ${track.lastPresetId} not found for track ${track.name}, using Focus`);
                        const focusMode = MODE_LIBRARY[0];
                        applyPreset(focusMode.preset, focusMode.id);
                    }
                } else {
                    // First time playing this track - save current preset
                    setPlaylist(prev => prev.map((t, i) => 
                        i === index ? { ...t, lastPresetId: activePresetId } : t
                    ));
                    console.log(`[AutoRestore] Saved preset ${activePresetId} for track ${track.name}`);
                }
                
                const audio = prepareAudioElement();
                
                const handleLoadedMetadata = () => {
                    setupAudioGraph(audio);
                    audio.play().then(() => {
                        setIsPlaying(true);
                        const resolvedRitualUsed = typeof ritualUsed === 'undefined'
                            ? sessionRitualFlagRef.current
                            : ritualUsed;
                        startSession({ track, ritualUsed: resolvedRitualUsed });
                    }).catch(err => {
                        console.error('Playback error:', err);
                        alert('Playback error. If you opened this from file://, please run a local web server.\n\nQuick fix: Run "python3 -m http.server 8000" in this folder');
                    });
                };
                
                audio.addEventListener('loadedmetadata', handleLoadedMetadata, { once: true });
                
                const assignSource = () => {
                    if (track.source === 'local' && track.file) {
                        try {
                            const blobUrl = URL.createObjectURL(track.file);
                            currentBlobUrlRef.current = blobUrl;
                            audio.src = blobUrl;
                        } catch (err) {
                            console.error('Error creating blob URL:', err);
                            audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
                            alert('Error loading file. Please serve this HTML from a web server (see console for instructions).\n\nQuick fix: Run "python3 -m http.server 8000" in this folder, then open http://localhost:8000/8d-player-live.html');
                            return false;
                        }
                    } else if (track.source === 'youtube') {
                        audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
                        alert('YouTube playback requires a backend server or YouTube API. Please use direct MP3 URLs or local files.');
                        teardownAudioElement();
                        return false;
                    } else if (track.url) {
                        audio.src = track.url;
                    } else {
                        audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
                        alert('Invalid track source');
                        teardownAudioElement();
                        return false;
                    }
                    return true;
                };
                
                const assigned = assignSource();
                if (!assigned) {
                    return;
                }
                
                audio.load();
                
                currentTrackIndexRef.current = index;
                setCurrentTrackIndex(index);
                setRitualStatus('active');
                setHeroMessage(`Now playing ${track.name} • ${selectedMode.label}`);
                setNeedsAudio(false);
            };

            playNextRef.current = (options = {}) => {
                const { shouldEndActiveSession = true } = options;
                const playlistSnapshot = playlistRef.current;
                if (!playlistSnapshot || playlistSnapshot.length === 0) {
                    return;
                }
                const indexSnapshot = currentTrackIndexRef.current;
                if (
                    indexSnapshot === null ||
                    indexSnapshot === undefined ||
                    indexSnapshot < 0 ||
                    indexSnapshot >= playlistSnapshot.length
                ) {
                    playTrack(0, { shouldEndActiveSession });
                    return;
                }
                const nextIndex = (indexSnapshot + 1) % playlistSnapshot.length;
                playTrack(nextIndex, { shouldEndActiveSession });
            };

            // ==================== TIMER FUNCTIONS ====================

            // Format seconds to MM:SS or HH:MM:SS
            const formatTimerDisplay = (totalSeconds) => {
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;

                if (hours > 0) {
                    return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            };

            // Sleep Timer Functions
            const startSleepTimer = () => {
                if (sleepTimerIntervalRef.current) {
                    clearInterval(sleepTimerIntervalRef.current);
                }

                setSleepTimerSeconds(sleepTimerDuration);
                setSleepTimerActive(true);
                showToast(`Sleep timer set for ${formatTimerDisplay(sleepTimerDuration)}`, 'info');

                sleepTimerIntervalRef.current = setInterval(() => {
                    setSleepTimerSeconds(prev => {
                        if (prev <= 1) {
                            // Timer finished - fade out and stop
                            clearInterval(sleepTimerIntervalRef.current);
                            sleepTimerIntervalRef.current = null;
                            setSleepTimerActive(false);

                            // Fade out audio over 5 seconds
                            if (audioElementRef.current && gainNodeRef.current) {
                                const fadeInterval = setInterval(() => {
                                    if (gainNodeRef.current && gainNodeRef.current.gain.value > 0.05) {
                                        gainNodeRef.current.gain.value *= 0.9;
                                    } else {
                                        clearInterval(fadeInterval);
                                        if (audioElementRef.current) {
                                            audioElementRef.current.pause();
                                            setIsPlaying(false);
                                        }
                                        showToast('Sleep timer ended. Sweet dreams!', 'success');
                                    }
                                }, 200);
                            }
                            return 0;
                        }
                        return prev - 1;
                    });
                }, 1000);
            };

            const stopSleepTimer = () => {
                if (sleepTimerIntervalRef.current) {
                    clearInterval(sleepTimerIntervalRef.current);
                    sleepTimerIntervalRef.current = null;
                }
                setSleepTimerActive(false);
                setSleepTimerSeconds(0);
                showToast('Sleep timer cancelled', 'info');
            };

            // Pomodoro Timer Functions
            const startPomodoro = () => {
                if (pomodoroIntervalRef.current) {
                    clearInterval(pomodoroIntervalRef.current);
                }

                // Store current mode to restore after break
                previousModeRef.current = activePresetId;

                setPomodoroPhase('work');
                setPomodoroSeconds(pomodoroWorkDuration * 60);
                setPomodoroActive(true);
                setPomodoroCycles(0);
                showToast(`Pomodoro started: ${pomodoroWorkDuration} min work`, 'info');

                // Start playing if not already
                if (!isPlaying && playlist.length > 0) {
                    togglePlayPause();
                }

                pomodoroIntervalRef.current = setInterval(() => {
                    setPomodoroSeconds(prev => {
                        if (prev <= 1) {
                            // Phase ended
                            setPomodoroPhase(currentPhase => {
                                if (currentPhase === 'work') {
                                    // Work phase ended, start break
                                    setPomodoroCycles(c => c + 1);
                                    showToast('Work phase complete! Take a break.', 'success');

                                    // Handle break action
                                    if (pomodoroBreakAction === 'pause') {
                                        if (audioElementRef.current) {
                                            audioElementRef.current.pause();
                                            setIsPlaying(false);
                                        }
                                    } else if (pomodoroBreakAction === 'energize') {
                                        // Switch to energize mode for break
                                        const energizeIndex = MODE_LIBRARY.findIndex(m => m.id === 'energize');
                                        if (energizeIndex >= 0) {
                                            setModeIndex(energizeIndex);
                                            setActivePresetId('energize');
                                        }
                                    } else if (pomodoroBreakAction === 'calm') {
                                        // Switch to calm mode for break
                                        const calmIndex = MODE_LIBRARY.findIndex(m => m.id === 'calm');
                                        if (calmIndex >= 0) {
                                            setModeIndex(calmIndex);
                                            setActivePresetId('calm');
                                        }
                                    }

                                    return 'break';
                                } else {
                                    // Break ended, start work
                                    showToast('Break over! Time to focus.', 'info');

                                    // Restore previous mode
                                    if (previousModeRef.current) {
                                        const prevIndex = MODE_LIBRARY.findIndex(m => m.id === previousModeRef.current);
                                        if (prevIndex >= 0) {
                                            setModeIndex(prevIndex);
                                            setActivePresetId(previousModeRef.current);
                                        }
                                    }

                                    // Resume playing if paused during break
                                    if (!isPlaying && playlist.length > 0 && audioElementRef.current) {
                                        audioElementRef.current.play();
                                        setIsPlaying(true);
                                    }

                                    return 'work';
                                }
                            });

                            // Return the new duration
                            return pomodoroPhase === 'work'
                                ? pomodoroBreakDuration * 60
                                : pomodoroWorkDuration * 60;
                        }
                        return prev - 1;
                    });
                }, 1000);
            };

            const stopPomodoro = () => {
                if (pomodoroIntervalRef.current) {
                    clearInterval(pomodoroIntervalRef.current);
                    pomodoroIntervalRef.current = null;
                }

                // Restore previous mode if we were on break
                if (pomodoroPhase === 'break' && previousModeRef.current) {
                    const prevIndex = MODE_LIBRARY.findIndex(m => m.id === previousModeRef.current);
                    if (prevIndex >= 0) {
                        setModeIndex(prevIndex);
                        setActivePresetId(previousModeRef.current);
                    }
                }

                setPomodoroActive(false);
                setPomodoroPhase('work');
                setPomodoroSeconds(0);
                showToast('Pomodoro stopped', 'info');
            };

            // Cleanup timers on unmount
            useEffect(() => {
                return () => {
                    if (sleepTimerIntervalRef.current) {
                        clearInterval(sleepTimerIntervalRef.current);
                    }
                    if (pomodoroIntervalRef.current) {
                        clearInterval(pomodoroIntervalRef.current);
                    }
                };
            }, []);

            // ==================== END TIMER FUNCTIONS ====================

            // ==================== PLAYLIST SAVE/LOAD FUNCTIONS ====================

            const savePlaylist = (name) => {
                if (!name.trim() || playlist.length === 0) return;

                // For local files, we can only save metadata (not the file itself)
                // For streams, we save the URL
                const playlistData = playlist.map(track => ({
                    name: track.name,
                    source: track.source,
                    url: track.url || null,
                    // Can't persist File objects, so local files won't restore
                    isLocal: track.source === 'local'
                }));

                const newPlaylist = {
                    id: Date.now(),
                    name: name.trim(),
                    tracks: playlistData,
                    trackCount: playlist.length,
                    createdAt: new Date().toISOString()
                };

                setSavedPlaylists(prev => {
                    const updated = [...prev, newPlaylist];
                    try {
                        localStorage.setItem('mpe_8d_saved_playlists', JSON.stringify(updated));
                    } catch (e) {
                        console.warn('Failed to save playlist:', e);
                    }
                    return updated;
                });

                setNewPlaylistName('');
                showToast(`Playlist "${name}" saved!`, 'success');
            };

            const loadPlaylist = (savedPlaylist) => {
                // Filter out local files (can't be restored) and load streams
                const restoredTracks = savedPlaylist.tracks
                    .filter(track => !track.isLocal && track.url)
                    .map((track, index) => ({
                        id: Date.now() + index,
                        name: track.name,
                        source: track.source,
                        url: track.url,
                        file: null
                    }));

                const localCount = savedPlaylist.tracks.filter(t => t.isLocal).length;

                if (restoredTracks.length === 0 && localCount > 0) {
                    showToast(`This playlist only had local files which can't be restored. Add them again.`, 'warning');
                    setShowPlaylistModal(false);
                    return;
                }

                setPlaylist(restoredTracks);
                setCurrentTrackIndex(null);
                setShowPlaylistModal(false);

                if (localCount > 0) {
                    showToast(`Loaded ${restoredTracks.length} tracks. ${localCount} local files need to be re-added.`, 'info');
                } else {
                    showToast(`Loaded "${savedPlaylist.name}" with ${restoredTracks.length} tracks`, 'success');
                }
            };

            const deletePlaylist = (playlistId) => {
                setSavedPlaylists(prev => {
                    const updated = prev.filter(p => p.id !== playlistId);
                    try {
                        localStorage.setItem('mpe_8d_saved_playlists', JSON.stringify(updated));
                    } catch (e) {
                        console.warn('Failed to update saved playlists:', e);
                    }
                    return updated;
                });
                showToast('Playlist deleted', 'info');
            };

            // ==================== END PLAYLIST FUNCTIONS ====================

            const togglePlayPause = () => {
                if (!audioElementRef.current) {
                    if (playlist.length > 0) {
                        playTrack(0, { ritualUsed: sessionRitualFlagRef.current });
                    }
                    return;
                }

                const audio = audioElementRef.current;

                if (isPlaying) {
                    // Pause main audio
                    audio.pause();

                    // Mute binaural beats (store original gain for resume)
                    if (binauralNodesRef.current?.gain) {
                        pausedBinauralGainRef.current = binauralNodesRef.current.gain.gain.value;
                        binauralNodesRef.current.gain.gain.value = 0;
                    }

                    // Mute noise (store original gain for resume)
                    if (noiseNodesRef.current?.gain) {
                        pausedNoiseGainRef.current = noiseNodesRef.current.gain.gain.value;
                        noiseNodesRef.current.gain.gain.value = 0;
                    }

                    setIsPlaying(false);
                    endSession(true);
                } else {
                    audio.play().then(() => {
                        // Restore binaural beats
                        if (binauralNodesRef.current?.gain && pausedBinauralGainRef.current !== null) {
                            binauralNodesRef.current.gain.gain.value = pausedBinauralGainRef.current;
                            pausedBinauralGainRef.current = null;
                        }

                        // Restore noise
                        if (noiseNodesRef.current?.gain && pausedNoiseGainRef.current !== null) {
                            noiseNodesRef.current.gain.gain.value = pausedNoiseGainRef.current;
                            pausedNoiseGainRef.current = null;
                        }

                        setIsPlaying(true);
                        if (!activeSessionIdRef.current && nowPlayingTrack) {
                            startSession({ track: nowPlayingTrack, ritualUsed: sessionRitualFlagRef.current });
                        }
                    });
                }
            };

            const playNext = () => {
                if (typeof playNextRef.current === 'function') {
                    playNextRef.current();
                }
            };

            const playPrevious = () => {
                if (currentTrackIndex === null || playlist.length === 0) {
                    return;
                }
                const prevIndex = currentTrackIndex === 0 ? playlist.length - 1 : currentTrackIndex - 1;
                playTrack(prevIndex);
            };

            // Rate a track for the current mode
            // rating: 'boost' | 'neutral' | 'remove'
            const rateTrack = (trackName, rating, modeId) => {
                const currentMode = modeId || activePresetId;
                setTrackRatings(prev => {
                    const updated = {
                        ...prev,
                        [trackName]: {
                            ...(prev[trackName] || {}),
                            [currentMode]: rating
                        }
                    };
                    // Persist to localStorage
                    try {
                        localStorage.setItem('mpe_8d_track_ratings', JSON.stringify(updated));
                    } catch (e) {
                        console.warn('Failed to save track ratings:', e);
                    }
                    return updated;
                });

                // If rating is 'remove', remove from playlist after a brief dim animation
                if (rating === 'remove') {
                    const track = playlist.find(t => t.name === trackName);
                    if (track) {
                        // Small delay for visual feedback
                        setTimeout(() => {
                            removeFromPlaylist(track.id);
                        }, 600);
                    }
                }
            };

            // Get the rating for a track in current mode
            const getTrackRating = (trackName) => {
                return trackRatings[trackName]?.[activePresetId] || null;
            };

            const removeFromPlaylist = async (id) => {
                const currentList = playlist;
                const removedIndex = currentList.findIndex(track => track.id === id);
                if (removedIndex === -1) {
                    return;
                }
                const nextPlaylist = currentList.filter(track => track.id !== id);
                setPlaylist(nextPlaylist);

                const prevIndex = currentTrackIndex;
                const removedWasCurrent = prevIndex === removedIndex;
                if (removedWasCurrent) {
                    await endSession(true);
                    teardownAudioElement();
                    disposeAudioGraph();
                    setIsPlaying(false);
                }

                let nextIndex = prevIndex;
                if (nextPlaylist.length === 0) {
                    nextIndex = null;
                } else if (removedWasCurrent) {
                    nextIndex = Math.min(removedIndex, nextPlaylist.length - 1);
                } else if (typeof prevIndex === 'number' && removedIndex < prevIndex) {
                    nextIndex = Math.max(prevIndex - 1, 0);
                } else if (typeof prevIndex === 'number' && prevIndex >= nextPlaylist.length) {
                    nextIndex = nextPlaylist.length - 1;
                }

                if (nextIndex !== prevIndex) {
                    currentTrackIndexRef.current = nextIndex;
                    setCurrentTrackIndex(nextIndex);
                }
            };

            const handleSeekChange = (event) => {
                if (!audioElementRef.current) return;
                const nextTime = parseFloat(event.target.value);
                if (Number.isNaN(nextTime)) return;
                audioElementRef.current.currentTime = nextTime;
                setCurrentTime(nextTime);
            };

            const ensurePlaylistReady = () => {
                if (playlist.length === 0) {
                    setNeedsAudio(true);
                    setHeroMessage('Add a local file or stream to begin this ritual.');
                    if (dropZoneRef.current) {
                        dropZoneRef.current.focus();
                    }
                    return false;
                }
                return true;
            };

            const launchRitualPlayback = ({ ritualUsed } = {}) => {
                const resolvedRitualUsed = typeof ritualUsed === 'boolean' ? ritualUsed : ritualStatus === 'breathing';
                sessionRitualFlagRef.current = resolvedRitualUsed;

                // Log ritual completion telemetry
                try {
                    const ritualEndTs = Date.now();
                    const ritualEvent = {
                        type: 'FOCUS_RITUAL_COMPLETED',
                        timestamp: ritualEndTs,
                        modeId: selectedMode.id,
                        modeLabel: selectedMode.label,
                        presetApplied: selectedMode.id,
                        duration: HERO_BREATH_DURATION
                    };
                    console.log('[SessionLogger]', ritualEvent);
                    // Future: Store in IndexedDB sessions store
                } catch (e) {
                    console.warn('Failed to log ritual completion', e);
                }

                setRitualStatus('active');
                setHeroMessage(`Ritual active — ${selectedMode.label} preset live.`);
                setNeedsAudio(false);
                setBreathingPhase('');
                
                if (currentTrackIndex === null) {
                    playTrack(0, { ritualUsed: resolvedRitualUsed });
                    return;
                }
                const audio = audioElementRef.current;
                if (audio) {
                    audio.play().then(() => {
                        setIsPlaying(true);
                        if (nowPlayingTrack) {
                            startSession({ track: nowPlayingTrack, ritualUsed: resolvedRitualUsed });
                        }
                    }).catch(() => {
                        setHeroMessage('Press play to continue your ritual.');
                    });
                } else {
                    playTrack(currentTrackIndex, { ritualUsed: resolvedRitualUsed });
                }
            };

            const startRitual = () => {
                if (!ensurePlaylistReady()) {
                    return;
                }
                
                // Check if skip preference is enabled
                if (skipRitualPref) {
                    // Log skip telemetry
                    try {
                        const skipEvent = {
                            type: 'RITUAL_SKIPPED',
                            timestamp: Date.now(),
                            modeId: selectedMode.id,
                            reason: 'skip-preference-enabled'
                        };
                        console.log('[SessionLogger]', skipEvent);
                    } catch (e) {
                        console.warn('Failed to log ritual skip', e);
                    }
                    launchRitualPlayback({ ritualUsed: false });
                    return;
                }
                
                clearRitualTimers();
                setRitualStatus('breathing');
                setHeroMessage(`Breathe in...`);
                setRitualCountdown(HERO_BREATH_DURATION);
                setBreathingPhase('inhale');
                
                // Log ritual start telemetry
                try {
                    const startEvent = {
                        type: 'RITUAL_STARTED',
                        timestamp: Date.now(),
                        modeId: selectedMode.id,
                        modeLabel: selectedMode.label,
                        duration: HERO_BREATH_DURATION
                    };
                    console.log('[SessionLogger]', startEvent);
                } catch (e) {
                    console.warn('Failed to log ritual start', e);
                }
                
                // Countdown timer (1s intervals)
                ritualIntervalRef.current = setInterval(() => {
                    setRitualCountdown((prev) => {
                        const next = Math.max(prev - 1, 0);
                        if (next === 0) {
                            clearInterval(ritualIntervalRef.current);
                            ritualIntervalRef.current = null;
                        }
                        return next;
                    });
                }, 1000);
                
                // 4-2-4 breathing phase cycle (6s total: 2s in, 1s hold, 2s out, 1s hold)
                // Repeat ~3.33 times over 20 seconds
                let phaseStep = 0;
                breathingPhaseIntervalRef.current = setInterval(() => {
                    phaseStep++;
                    const cyclePosition = phaseStep % 6;
                    
                    if (cyclePosition === 0 || cyclePosition === 1) {
                        // Inhale (2 seconds)
                        setBreathingPhase('inhale');
                        setHeroMessage('Breathe in...');
                    } else if (cyclePosition === 2) {
                        // Hold after inhale (1 second)
                        setBreathingPhase('hold-in');
                        setHeroMessage('Hold...');
                    } else if (cyclePosition === 3 || cyclePosition === 4) {
                        // Exhale (2 seconds)
                        setBreathingPhase('exhale');
                        setHeroMessage('Breathe out...');
                    } else if (cyclePosition === 5) {
                        // Hold after exhale (1 second)
                        setBreathingPhase('hold-out');
                        setHeroMessage('Hold...');
                    }
                }, 1000);
                
                // Auto-launch after 20 seconds
                ritualTimeoutRef.current = setTimeout(() => {
                    clearRitualTimers();
                    launchRitualPlayback({ ritualUsed: true });
                }, HERO_BREATH_DURATION * 1000);
            };

            const skipRitual = () => {
                if (!ensurePlaylistReady()) {
                    return;
                }
                
                // Log skip telemetry
                try {
                    const skipEvent = {
                        type: 'RITUAL_SKIPPED',
                        timestamp: Date.now(),
                        modeId: selectedMode.id,
                        reason: 'user-skip-button'
                    };
                    console.log('[SessionLogger]', skipEvent);
                } catch (e) {
                    console.warn('Failed to log ritual skip', e);
                }
                
                clearRitualTimers();
                setRitualCountdown(0);
                setBreathingPhase('');
                launchRitualPlayback({ ritualUsed: false });
            };

            const toggleSkipRitualPref = () => {
                const newValue = !skipRitualPref;
                setSkipRitualPref(newValue);
                try {
                    if (newValue) {
                        localStorage.setItem('skipBreathingRitual', 'true');
                    } else {
                        localStorage.removeItem('skipBreathingRitual');
                    }
                } catch (e) {
                    console.warn('Failed to persist skip preference', e);
                }
            };

            // Story 3-1: Apply preset configuration to all audio parameters
            const applyPreset = (preset, presetId) => {
                performance.mark('preset-apply-start');
                
                // Batch all parameter updates (React 18 auto-batches in event handlers)
                setSpeed(preset.speed);
                setIntensity(preset.intensity);
                setSpatialDepth(preset.spatialDepth);
                setMovementPattern(preset.movement);
                setBinauralEnabled(preset.binaural.enabled);
                setBinauralFreq(preset.binaural.freq);
                setNoiseType(preset.noise.type);
                setNoiseVolume(preset.noise.volume);
                setVisualWaveGain(preset.noise.volume);

                // Apply spatial audio settings if present
                if (preset.spatial) {
                    setItdAmount(preset.spatial.itdAmount ?? 0.7);
                    setHeadShadow(preset.spatial.headShadow ?? 0.5);
                    setDirectionalDepth(preset.spatial.directionalDepth ?? 0.15);
                    setCrossBleed(preset.spatial.crossBleed ?? 0);
                    setPanCurve(preset.spatial.panCurve ?? 2.0);
                    setBackDepth(preset.spatial.backDepth ?? 0.55);
                    setHardPanThreshold(preset.spatial.hardPanThreshold ?? 0.1);
                }

                // Update active preset tracking
                setActivePresetId(presetId);
                
                // Story 3-3: Update current track's lastPresetId when preset changes
                if (currentTrackIndex !== null && playlist[currentTrackIndex]) {
                    setPlaylist(prev => prev.map((track, i) => 
                        i === currentTrackIndex ? { ...track, lastPresetId: presetId } : track
                    ));
                    console.log(`[AutoRestore] Updated track ${playlist[currentTrackIndex].name} lastPresetId to ${presetId}`);
                }
                
                // Log preset change event
                logPresetChange(presetId);
                
                performance.mark('preset-apply-end');
                const measure = performance.measure('preset-apply', 'preset-apply-start', 'preset-apply-end');
                console.log(`[Performance] Preset applied in ${measure.duration.toFixed(2)}ms`);
                
                // Restart rotation with new settings if playing
                if (isPlaying) {
                    startRotation();
                }
            };

            // Update effects in real-time
            useEffect(() => {
                if (isPlaying) {
                    startRotation();
                }
            }, [speed, intensity, movementPattern]);

            useEffect(() => {
                const nodes = rotationNodesRef.current;
                if (!nodes) {
                    return;
                }
                if (nodes.delayGainLeft) {
                    nodes.delayGainLeft.gain.value = 0.05 * spatialDepth;
                }
                if (nodes.delayGainRight) {
                    nodes.delayGainRight.gain.value = 0.05 * spatialDepth;
                }
                if (nodes.crossGainLeft) {
                    nodes.crossGainLeft.gain.value = 0.03 * spatialDepth;
                }
                if (nodes.crossGainRight) {
                    nodes.crossGainRight.gain.value = 0.03 * spatialDepth;
                }
            }, [spatialDepth]);

            useEffect(() => {
                visualWaveGainRef.current = visualWaveGain;
            }, [visualWaveGain]);

            useEffect(() => {
                visualizerTypeRef.current = visualizerType;
            }, [visualizerType]);

            useEffect(() => {
                if (gainChainRef.current) {
                    gainChainRef.current.setVolume(volume);
                }
            }, [volume]);

            useEffect(() => {
                syncBinauralChain();
            }, [binauralEnabled, binauralFreq]);

            useEffect(() => {
                syncNoiseLayer();
            }, [noiseType, noiseVolume]);

            const formatTime = (seconds) => {
                if (!seconds || isNaN(seconds)) return '0:00';
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            };

            const getTotalDuration = () => {
                return playlist.length * 3.5; // Estimate 3.5 minutes per track
            };

            const getBinauralDescription = (freq) => {
                if (freq <= 4) return 'Delta (Sleep)';
                if (freq <= 8) return 'Theta (Meditation)';
                if (freq <= 14) return 'Alpha (Relaxation)';
                if (freq <= 30) return 'Beta (Focus)';
                return 'Gamma (Peak Focus)';
            };

            const dropZoneClasses = ['drop-zone'];
            if (needsAudio) {
                dropZoneClasses.push('drop-zone--attention');
            }
            if (dragActive) {
                dropZoneClasses.push('drop-zone--hover');
            }

return (
                <>
                    {/* Story 6-1: Offline/Online Banner */}
                    <OfflineBanner isOffline={isOffline} reducedMotion={reducedMotion} />

                    {/* Story 6-1: SW Update Toast */}
                    <UpdateToast
                        isVisible={updateAvailable}
                        onUpdate={applyUpdate}
                        reducedMotion={reducedMotion}
                    />

                <div className="screen">
                    {/* First Run Calibration Prompt Modal */}
                    {showFirstRunPrompt && (
                        <div style={{
                            position: 'fixed',
                            top: 0,
                            left: 0,
                            right: 0,
                            bottom: 0,
                            background: 'rgba(0,0,0,0.85)',
                            zIndex: 10000,
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            padding: '20px'
                        }}>
                            <div style={{
                                background: 'var(--card)',
                                borderRadius: '16px',
                                padding: '24px',
                                maxWidth: '450px',
                                width: '100%',
                                border: '2px solid var(--accent)',
                                boxShadow: '0 20px 60px rgba(0,0,0,0.5)'
                            }}>
                                <h2 style={{ margin: '0 0 16px 0', color: 'var(--accent)' }}>
                                    Welcome to 8D Ritual Shell!
                                </h2>
                                <p style={{ color: 'var(--text-secondary)', marginBottom: '16px', lineHeight: '1.5' }}>
                                    This app features <strong>personalized spatial audio</strong> designed to work with different hearing profiles, including APD (Auditory Processing Disorder).
                                </p>
                                <p style={{ color: 'var(--text-secondary)', marginBottom: '20px', lineHeight: '1.5' }}>
                                    Would you like to run the <strong>Calibration Wizard</strong> to optimize the audio for your unique hearing?
                                </p>
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>
                                    <button
                                        onClick={() => {
                                            setShowFirstRunPrompt(false);
                                            setShowSpatialTuner(true);
                                            // The SpatialAudioTuner has the calibration wizard inside
                                        }}
                                        style={{
                                            width: '100%',
                                            padding: '14px',
                                            background: 'var(--accent)',
                                            color: 'white',
                                            border: 'none',
                                            borderRadius: '8px',
                                            cursor: 'pointer',
                                            fontWeight: '600',
                                            fontSize: '1rem'
                                        }}
                                    >
                                        Yes, Calibrate Now
                                    </button>
                                    <button
                                        onClick={() => {
                                            setShowFirstRunPrompt(false);
                                            // Don't set dismissed - will show again next session
                                        }}
                                        style={{
                                            width: '100%',
                                            padding: '12px',
                                            background: 'rgba(255,255,255,0.1)',
                                            color: 'var(--text-primary)',
                                            border: '1px solid var(--border)',
                                            borderRadius: '8px',
                                            cursor: 'pointer',
                                            fontWeight: '500'
                                        }}
                                    >
                                        Later (Ask Again Next Time)
                                    </button>
                                    <button
                                        onClick={() => {
                                            setShowFirstRunPrompt(false);
                                            setCalibrationDismissed(true);
                                            try {
                                                localStorage.setItem('mpe_8d_calibration_dismissed', 'true');
                                            } catch (e) {}
                                        }}
                                        style={{
                                            width: '100%',
                                            padding: '12px',
                                            background: 'transparent',
                                            color: 'var(--text-secondary)',
                                            border: '1px solid var(--text-secondary)',
                                            borderRadius: '8px',
                                            cursor: 'pointer',
                                            fontWeight: '500'
                                        }}
                                    >
                                        No Thanks (Don't Ask Again)
                                    </button>
                                    <button
                                        onClick={() => {
                                            setShowFirstRunPrompt(false);
                                        }}
                                        style={{
                                            width: '100%',
                                            padding: '10px',
                                            background: 'transparent',
                                            color: 'var(--text-tertiary)',
                                            border: 'none',
                                            borderRadius: '8px',
                                            cursor: 'pointer',
                                            fontSize: '0.85rem'
                                        }}
                                    >
                                        Exit
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/*
                    KEYBOARD SHORTCUTS REFERENCE
                    ============================
                    
                    Navigation:
                    - Tab: Move forward through interactive elements
                    - Shift+Tab: Move backward through interactive elements
                    
                    Mode Selection (when mode chips focused):
                    - Arrow Left/Right: Navigate between Focus/Calm/Energize modes
                    - Enter or Space: Activate selected mode
                    
                    Toggle Buttons:
                    - Tab to reach: Dark mode, Reduced motion, High contrast toggles
                    - Enter or Space: Toggle the focused setting
                    
                    Playback Controls:
                    - Tab to reach: Play/Pause, Previous, Next buttons
                    - Enter or Space: Activate playback control
                    
                    Ritual Flow:
                    - Tab to reach: Start button or Skip button during ritual
                    - Enter or Space: Start ritual or skip breathing animation
                    
                    Accessibility Features:
                    - All state changes announced via screen reader
                    - Focus indicators visible on all interactive elements
                    - ≥48px tap targets for touch accessibility
                    */}
                    {/* Mobile Header - Only visible on mobile */}
                    <div className="mobile-header">
                        <div className="mobile-header-bar">
                            <span className="mobile-header-title">8D Ritual Shell</span>
                            <button
                                className="mobile-menu-btn"
                                onClick={() => setMobileMenuOpen(!mobileMenuOpen)}
                                aria-label="Toggle menu"
                                aria-expanded={mobileMenuOpen}
                            >
                                {mobileMenuOpen ? '✕' : '☰'}
                            </button>
                        </div>
                        <div className={`mobile-menu-dropdown ${mobileMenuOpen ? 'open' : ''}`}>
                            <div className="calibration-bar">
                                <span className={`calibration-status ${hasRunCalibration ? 'calibrated' : ''}`}>
                                    {hasRunCalibration ? '✓ Calibrated' : '⚠ Not calibrated'}
                                </span>
                                <button
                                    className={`calibration-btn ${!hasRunCalibration ? 'not-calibrated' : ''}`}
                                    onClick={() => { setShowSpatialTuner(true); setMobileMenuOpen(false); }}
                                >
                                    Audio Settings
                                </button>
                            </div>
                            <button type="button" className="primary-btn" aria-label="Install unified ritual shell">
                                📲 Install
                            </button>
                            <button
                                type="button"
                                onClick={() => { toggleDarkMode(); setMobileMenuOpen(false); }}
                                aria-pressed={darkMode}
                            >
                                {darkMode ? '☀️ Light mode' : '🌙 Dark mode'}
                            </button>
                            <button
                                type="button"
                                onClick={() => { toggleReducedMotion(); setMobileMenuOpen(false); }}
                                aria-pressed={reducedMotion}
                            >
                                {reducedMotion ? 'Motion reduced' : 'Motion on'}
                            </button>
                            <button
                                type="button"
                                onClick={() => { toggleHighContrast(); setMobileMenuOpen(false); }}
                                aria-pressed={highContrast}
                            >
                                {highContrast ? '◐ High contrast' : '○ Normal contrast'}
                            </button>
                        </div>
                    </div>

                    {/* Desktop Header - Single row */}
                    <header className="app-header">
                        {/* Title - Compact */}
                        <div>
                            <p className="eyebrow" style={{ marginBottom: '0' }}>Unified Ritual Player</p>
                            <h1 style={{ fontSize: '1.4rem', margin: '0' }}>8D Ritual Shell</h1>
                        </div>
                        {/* Actions row - Buttons + Calibration */}
                        <div style={{ display: 'flex', alignItems: 'center', gap: '8px', flexWrap: 'wrap' }}>
                            <button type="button" className="primary-btn" aria-label="Install">
                                📲 Install
                            </button>
                            <button type="button" onClick={toggleDarkMode} aria-pressed={darkMode} aria-label="Toggle dark mode" title={darkMode ? 'Light mode' : 'Dark mode'}>
                                {darkMode ? '☀️' : '🌙'}
                            </button>
                            <button type="button" onClick={toggleReducedMotion} aria-pressed={reducedMotion} aria-label="Toggle reduced motion" title={reducedMotion ? 'Motion reduced' : 'Motion on'}>
                                {reducedMotion ? '⏸' : '▶'}
                            </button>
                            <button type="button" onClick={toggleHighContrast} aria-pressed={highContrast} aria-label="Toggle high contrast" title={highContrast ? 'High contrast' : 'Normal contrast'}>
                                {highContrast ? '◐' : '○'}
                            </button>
                            <div style={{ height: '20px', width: '1px', background: 'var(--card-border)' }}></div>
                            <span style={{ fontSize: '0.75rem', color: hasRunCalibration ? '#4ade80' : 'var(--text-secondary)' }}>
                                {hasRunCalibration ? '✓ Calibrated' : '⚠'}
                            </span>
                            <button
                                onClick={() => setShowSpatialTuner(true)}
                                style={{
                                    padding: '6px 12px',
                                    background: hasRunCalibration ? 'rgba(74, 222, 128, 0.2)' : 'var(--accent-focus)',
                                    color: hasRunCalibration ? '#4ade80' : 'white',
                                    border: hasRunCalibration ? '1px solid #4ade80' : 'none',
                                    borderRadius: '6px',
                                    cursor: 'pointer',
                                    fontWeight: '500',
                                    fontSize: '0.8rem'
                                }}
                            >
                                Audio Settings
                            </button>
                        </div>
                    </header>

                    {/* Accessibility announcements for screen readers */}
                    <div 
                        className="sr-only" 
                        role="status" 
                        aria-live="polite" 
                        aria-atomic="true"
                    >
                        {a11yAnnouncement}
                    </div>

                    {/* Toast Notification */}
                    {toastMessage && (
                        <div 
                            className={`toast toast-${toastType}`}
                            role="alert"
                            aria-live="polite"
                            style={{
                                position: 'fixed',
                                bottom: '24px',
                                left: '50%',
                                transform: 'translateX(-50%)',
                                backgroundColor: toastType === 'warning' ? '#fbbf24' : 
                                               toastType === 'error' ? '#f87171' : 
                                               toastType === 'success' ? '#4ade80' : 
                                               '#a78bfa',
                                color: toastType === 'warning' || toastType === 'success' ? '#1f2937' : '#111827',
                                padding: '12px 24px',
                                borderRadius: '8px',
                                boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
                                fontWeight: '500',
                                fontSize: '14px',
                                maxWidth: '500px',
                                zIndex: 10000,
                                animation: 'slideUp 0.3s ease-out'
                            }}
                        >
                            {toastMessage}
                        </div>
                    )}

                    {/* Processing Spinner */}
                    {isProcessingFiles && (
                        <div 
                            className="processing-spinner"
                            role="status"
                            aria-live="polite"
                            style={{
                                position: 'fixed',
                                top: '50%',
                                left: '50%',
                                transform: 'translate(-50%, -50%)',
                                backgroundColor: 'rgba(0, 0, 0, 0.85)',
                                padding: '24px 32px',
                                borderRadius: '12px',
                                display: 'flex',
                                flexDirection: 'column',
                                alignItems: 'center',
                                gap: '16px',
                                zIndex: 9999
                            }}
                        >
                            <div style={{
                                width: '40px',
                                height: '40px',
                                border: '4px solid #4b5563',
                                borderTop: '4px solid #a78bfa',
                                borderRadius: '50%',
                                animation: 'spin 1s linear infinite'
                            }} />
                            <span style={{ color: '#f3f4f6', fontSize: '14px' }}>
                                Processing files...
                            </span>
                        </div>
                    )}

                    {showFileWarning && (
                        <div className="alert-inline" role="alert" style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: '12px' }}>
                            <span>Web Audio needs to run over HTTP. From repo root run <code>python3 -m http.server 8000</code> then open http://localhost:8000/index.html.</span>
                            <button
                                onClick={() => setShowFileWarning(false)}
                                style={{
                                    background: 'transparent',
                                    border: 'none',
                                    color: 'inherit',
                                    cursor: 'pointer',
                                    fontSize: '1.2rem',
                                    padding: '4px',
                                    opacity: 0.7
                                }}
                                aria-label="Dismiss"
                            >
                                ✕
                            </button>
                        </div>
                    )}

                    <div className="main-grid">
                        <section className="column-card panel" aria-label="Ritual selection">
                            <div className="mode-tabs" role="tablist" aria-label="Ritual modes">
                                {MODE_LIBRARY.map((mode, index) => (
                                    <button
                                        key={mode.id}
                                        id={`mode-tab-${mode.id}`}
                                        role="tab"
                                        aria-selected={activePresetId === mode.id}
                                        aria-current={activePresetId === mode.id ? 'step' : undefined}
                                        tabIndex={focusedModeIndex === index ? 0 : -1}
                                        ref={(el) => (modeRefs.current[index] = el)}
                                        data-selected={activePresetId === mode.id}
                                        className="mode-chip"
                                        style={{ '--chip-accent': mode.accent }}
                                        onClick={() => setActiveMode(index)}
                                        onKeyDown={(event) => handleModeKeyDown(event, index)}
                                    >
                                        <span>{mode.label}</span>
                                        <small>{mode.short}</small>
                                    </button>
                                ))}
                            </div>

                            {/* Story 3-2: Advanced Controls Drawer */}
                            <AdvancedControls
                                speed={speed}
                                setSpeed={setSpeed}
                                intensity={intensity}
                                setIntensity={setIntensity}
                                spatialDepth={spatialDepth}
                                setSpatialDepth={setSpatialDepth}
                                movementPattern={movementPattern}
                                setMovementPattern={setMovementPattern}
                                binauralEnabled={binauralEnabled}
                                setBinauralEnabled={setBinauralEnabled}
                                binauralFreq={binauralFreq}
                                setBinauralFreq={setBinauralFreq}
                                noiseType={noiseType}
                                setNoiseType={setNoiseType}
                                noiseVolume={noiseVolume}
                                setNoiseVolume={setNoiseVolume}
                                isExpanded={isAdvancedControlsExpanded}
                                setIsExpanded={setIsAdvancedControlsExpanded}
                                sensorLocked={sensorLocked}
                                setSensorLocked={setSensorLocked}
                                setA11yAnnouncement={setA11yAnnouncement}
                                onSavePreset={openSavePresetDialog}
                                onOpenTuner={() => setShowSpatialTuner(true)}
                                sensorStatus={sensorStatus}
                                autoAdjustEnabled={autoAdjustEnabled}
                                onAutoAdjustChange={setAutoAdjustEnabled}
                                showToast={showToast}
                                logSensorEvent={logSensorEvent}
                            />

                            {/* Story 3-3: PresetList Component */}
                            <PresetList
                                presets={allPresets}
                                activePresetId={activePresetId}
                                onSelect={handleQuickApplyPreset}
                                onEdit={openEditPresetDialog}
                                onDelete={handleDeletePreset}
                                onReorder={handleReorderPresets}
                            />

                            {/* Story 5-1: Sensor Settings Component */}
                            {(bluetoothSupported || serialSupported || simulatorEnabled || (!bluetoothSupported && !serialSupported)) && (
                                <SensorSettings
                                    bluetoothSupported={bluetoothSupported}
                                    serialSupported={serialSupported}
                                    sensorStatus={sensorStatus}
                                    connectedDevice={connectedDevice}
                                    consentedDevices={consentedDevices}
                                    onConnectBluetooth={handleConnectBluetooth}
                                    onConnectSerial={handleConnectSerial}
                                    onReconnect={handleReconnectDevice}
                                    onForget={handleForgetDeviceRequest}
                                    onDisconnect={handleSensorDisconnect}
                                    reducedMotion={reducedMotion}
                                    currentHR={currentHR}
                                    hrHistory={hrHistory}
                                    hrThreshold={hrThreshold}
                                    onThresholdChange={setHrThreshold}
                                    isSimulating={isSimulating}
                                    simulatorEnabled={simulatorEnabled}
                                    onStartSimulation={startSensorSimulation}
                                    onStopSimulation={stopSensorSimulation}
                                    autoAdjustEnabled={autoAdjustEnabled}
                                    onAutoAdjustChange={setAutoAdjustEnabled}
                                    logSensorEvent={logSensorEvent}
                                />
                            )}

                            {/* Story 6-1: Offline Settings (includes install option) */}
                            <OfflineSettings
                                audioCacheConsent={audioCacheConsent}
                                onConsentChange={setAudioCacheConsent}
                                cacheStorageUsed={cacheStorageUsed}
                                onClearCache={handleClearAudioCache}
                                canInstall={canInstall}
                                isInstalled={isInstalled}
                                onInstall={showInstallPrompt}
                            />

                            <article
                                className="hero-card"
                                id={`mode-panel-${selectedMode.id}`}
                                role="tabpanel"
                                aria-labelledby={`mode-tab-${selectedMode.id}`}
                            >
                                <p className="eyebrow">{selectedMode.label} ritual</p>
                                <h2>{selectedMode.heroCopy}</h2>
                                <div className="hero-message" aria-live="polite">{heroMessage}</div>
                                {ritualStatus === 'breathing' && (
                                    <div className="hero-countdown" aria-live="assertive">
                                        {!reducedMotion && (
                                            <div
                                                className="hero-animation"
                                                aria-hidden="true"
                                                style={{ borderColor: selectedMode.accent }}
                                            />
                                        )}
                                        <div>
                                            <div className="hero-countdown__value">{ritualCountdown}s</div>
                                            <p className="hero-support" aria-live="polite">
                                                {breathingPhase === 'inhale' && 'Breathe in (2s)'}
                                                {breathingPhase === 'hold-in' && 'Hold (1s)'}
                                                {breathingPhase === 'exhale' && 'Breathe out (2s)'}
                                                {breathingPhase === 'hold-out' && 'Hold (1s)'}
                                                {!breathingPhase && '4-2-4 cadence'}
                                            </p>
                                        </div>
                                    </div>
                                )}
                                <p className="hero-support">{selectedMode.description}</p>
                                <div className="hero-actions">
                                    <button type="button" className="primary-btn" onClick={startRitual}>
                                        Start {selectedMode.label}
                                    </button>
                                    {ritualStatus === 'breathing' && (
                                        <>
                                            <button type="button" className="ghost-btn" onClick={skipRitual}>
                                                Skip ritual
                                            </button>
                                            <label style={{ 
                                                display: 'flex', 
                                                alignItems: 'center', 
                                                gap: '8px',
                                                fontSize: '0.9rem',
                                                width: '100%',
                                                cursor: 'pointer'
                                            }}>
                                                <input 
                                                    type="checkbox" 
                                                    checked={skipRitualPref}
                                                    onChange={toggleSkipRitualPref}
                                                    aria-label="Always skip breathing ritual"
                                                />
                                                <span>Always skip ritual</span>
                                            </label>
                                        </>
                                    )}
                                </div>
                                {skipRitualPref && ritualStatus === 'idle' && (
                                    <div className="alert-inline" role="status" style={{ marginTop: '12px' }}>
                                        ℹ️ Breathing ritual auto-skipped (your preference). 
                                        <button 
                                            type="button" 
                                            onClick={toggleSkipRitualPref}
                                            style={{ 
                                                marginLeft: '8px', 
                                                textDecoration: 'underline',
                                                background: 'none',
                                                border: 'none',
                                                color: 'inherit',
                                                cursor: 'pointer',
                                                padding: 0
                                            }}
                                        >
                                            Restore ritual
                                        </button>
                                    </div>
                                )}
                                {needsAudio && (
                                    <div className="alert-inline" role="alert">
                                        Add a local file or stream to begin this ritual.
                                    </div>
                                )}

                                {/* Story 6-2: PWA Install Prompt */}
                                <InstallPrompt
                                    canInstall={canInstall}
                                    onInstall={showInstallPrompt}
                                    onDismiss={dismissInstallPrompt}
                                    onShow={markPromptShown}
                                    reducedMotion={reducedMotion}
                                />

                                {/* Story 6-2: Safari Manual Install Instructions */}
                                <SafariInstallInstructions reducedMotion={reducedMotion} />
                            </article>

                            <div className="preset-grid">
                                {selectedMode.highlights.map((highlight) => (
                                    <div key={highlight} className="preset-card">
                                        {highlight}
                                    </div>
                                ))}
                            </div>
                        </section>

                        <section className="column-card">
                            <article className="panel now-playing-card">
                                <div className="playlist-header" style={{ marginBottom: nowPlayingTrack ? '0' : '16px' }}>
                                    <div>
                                        <p className="eyebrow">Now Playing</p>
                                    </div>
                                    <span className="status-pill" style={{ borderColor: selectedMode.accent }}>
                                        {selectedMode.label}
                                    </span>
                                </div>

                                {/* Track Info with Album Art */}
                                <div className="now-playing-track-info">
                                    <div className="album-art" style={{
                                        boxShadow: isPlaying ? `0 0 20px ${selectedMode.accent}40` : 'none',
                                        transition: 'box-shadow 0.3s ease'
                                    }}>
                                        {nowPlayingTrack?.albumArt ? (
                                            <img src={nowPlayingTrack.albumArt} alt="Album art" />
                                        ) : (
                                            <span style={{
                                                animation: isPlaying ? 'pulse 2s ease-in-out infinite' : 'none'
                                            }}>
                                                {getAlbumArtIcon()}
                                            </span>
                                        )}
                                    </div>
                                    <div className="track-details">
                                        <h3 className="track-title" title={trackInfo.title}>
                                            {trackInfo.title}
                                        </h3>
                                        {trackInfo.artist && (
                                            <p className="track-artist" title={trackInfo.artist}>
                                                {trackInfo.artist}
                                            </p>
                                        )}
                                        <p className="track-source">
                                            {trackInfo.source || 'playlist empty'} • {playlist.length} track{playlist.length === 1 ? '' : 's'}
                                        </p>
                                    </div>
                                </div>

                                <div className="transport-controls" aria-label="Playback controls">
                                    <button
                                        type="button"
                                        className="transport-button"
                                        onClick={playPrevious}
                                        aria-label="Play previous track"
                                        disabled={playlist.length === 0}
                                    >
                                        ⏮
                                    </button>
                                    <button
                                        type="button"
                                        className="transport-button play"
                                        onClick={togglePlayPause}
                                        aria-label={isPlaying ? 'Pause playback' : 'Play'}
                                        disabled={playlist.length === 0}
                                    >
                                        {isPlaying ? '⏸' : '▶️'}
                                    </button>
                                    <button
                                        type="button"
                                        className="transport-button"
                                        onClick={playNext}
                                        aria-label="Play next track"
                                        disabled={playlist.length === 0}
                                    >
                                        ⏭
                                    </button>
                                </div>
                                <div className="timeline">
                                    <label htmlFor="timeline" className="eyebrow">Timeline</label>
                                    <input
                                        id="timeline"
                                        type="range"
                                        min="0"
                                        max={duration || 0}
                                        step="0.1"
                                        value={Math.min(currentTime, duration || 0)}
                                        onChange={handleSeekChange}
                                        aria-valuetext={`${formatTime(currentTime)} of ${formatTime(duration)}`}
                                        disabled={!duration}
                                    />
                                    <div className="timeline-labels">
                                        <span>{formatTime(currentTime)}</span>
                                        <span>{formatTime(duration)}</span>
                                    </div>
                                </div>
                                <label htmlFor="volume" className="eyebrow">Volume</label>
                                <input
                                    id="volume"
                                    type="range"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value={volume}
                                    onChange={(e) => setVolume(parseFloat(e.target.value))}
                                    aria-valuetext={`${Math.round(volume * 100)} percent`}
                                />
                                {showVisualizer && (
                                    <>
                                        <div style={{ display: 'flex', gap: '4px', marginBottom: '8px', flexWrap: 'wrap' }}>
                                            {[
                                                { id: 'bars', icon: '📊', label: 'Bars' },
                                                { id: 'waveform', icon: '〰️', label: 'Wave' },
                                                { id: 'circular', icon: '🔘', label: 'Circular' },
                                                { id: 'mirrored', icon: '🪞', label: 'Mirror' },
                                                { id: 'particles', icon: '✨', label: 'Particles' }
                                            ].map(vis => (
                                                <button
                                                    key={vis.id}
                                                    onClick={() => setVisualizerType(vis.id)}
                                                    style={{
                                                        padding: '6px 10px',
                                                        background: visualizerType === vis.id ? 'var(--accent)' : 'rgba(255,255,255,0.1)',
                                                        color: visualizerType === vis.id ? 'black' : 'var(--text-primary)',
                                                        border: 'none',
                                                        borderRadius: '6px',
                                                        cursor: 'pointer',
                                                        fontSize: '0.75rem',
                                                        fontWeight: visualizerType === vis.id ? '600' : '400',
                                                        transition: 'all 0.2s'
                                                    }}
                                                    title={vis.label}
                                                >
                                                    {vis.icon} {vis.label}
                                                </button>
                                            ))}
                                        </div>
                                        <canvas
                                            ref={canvasRef}
                                            width={visualizerFullscreen ? window.innerWidth : 600}
                                            height={visualizerFullscreen ? window.innerHeight : 160}
                                            role="img"
                                            aria-label="Audio visualizer - click to toggle fullscreen"
                                            title="Click to toggle fullscreen"
                                            onClick={() => setVisualizerFullscreen(!visualizerFullscreen)}
                                            style={visualizerFullscreen ? {
                                                position: 'fixed',
                                                top: 0,
                                                left: 0,
                                                width: '100vw',
                                                height: '100vh',
                                                zIndex: 9999,
                                                cursor: 'zoom-out',
                                                background: darkMode ? '#1a2332' : '#0a0a0a'
                                            } : {
                                                cursor: 'zoom-in',
                                                borderRadius: '8px'
                                            }}
                                        ></canvas>
                                        {visualizerFullscreen && (
                                            <button
                                                onClick={() => setVisualizerFullscreen(false)}
                                                style={{
                                                    position: 'fixed',
                                                    top: '20px',
                                                    right: '20px',
                                                    zIndex: 10000,
                                                    padding: '12px 20px',
                                                    background: 'rgba(0,0,0,0.7)',
                                                    color: 'white',
                                                    border: '1px solid rgba(255,255,255,0.3)',
                                                    borderRadius: '8px',
                                                    cursor: 'pointer',
                                                    fontSize: '1rem',
                                                    fontWeight: '600',
                                                    backdropFilter: 'blur(10px)'
                                                }}
                                                aria-label="Exit fullscreen"
                                            >
                                                ✕ Exit
                                            </button>
                                        )}
                                    </>
                                )}

                                {/* Timer Section */}
                                <div className="timer-section">
                                    <div className="timer-tabs">
                                        <button
                                            className={`timer-tab ${activeTimerTab === 'sleep' ? 'active' : ''}`}
                                            onClick={() => setActiveTimerTab('sleep')}
                                        >
                                            😴 Sleep Timer
                                        </button>
                                        <button
                                            className={`timer-tab ${activeTimerTab === 'pomodoro' ? 'active' : ''}`}
                                            onClick={() => setActiveTimerTab('pomodoro')}
                                        >
                                            🍅 Focus Timer
                                        </button>
                                    </div>

                                    {activeTimerTab === 'sleep' && (
                                        <>
                                            <div className="timer-display">
                                                <div className="timer-time">
                                                    {sleepTimerActive
                                                        ? formatTimerDisplay(sleepTimerSeconds)
                                                        : formatTimerDisplay(sleepTimerDuration)
                                                    }
                                                </div>
                                                <div className="timer-label">
                                                    {sleepTimerActive ? 'Until sleep' : 'Set duration'}
                                                </div>
                                            </div>

                                            {!sleepTimerActive && (
                                                <div className="timer-presets">
                                                    {[
                                                        { label: '15m', seconds: 15 * 60 },
                                                        { label: '30m', seconds: 30 * 60 },
                                                        { label: '45m', seconds: 45 * 60 },
                                                        { label: '1h', seconds: 60 * 60 },
                                                        { label: '1.5h', seconds: 90 * 60 },
                                                        { label: '2h', seconds: 120 * 60 }
                                                    ].map(preset => (
                                                        <button
                                                            key={preset.label}
                                                            className={`timer-preset ${sleepTimerDuration === preset.seconds ? 'selected' : ''}`}
                                                            onClick={() => setSleepTimerDuration(preset.seconds)}
                                                        >
                                                            {preset.label}
                                                        </button>
                                                    ))}
                                                </div>
                                            )}

                                            <div className="timer-controls">
                                                {!sleepTimerActive ? (
                                                    <button
                                                        className="timer-btn start"
                                                        onClick={startSleepTimer}
                                                        disabled={playlist.length === 0}
                                                    >
                                                        Start Sleep Timer
                                                    </button>
                                                ) : (
                                                    <button
                                                        className="timer-btn stop"
                                                        onClick={stopSleepTimer}
                                                    >
                                                        Cancel Timer
                                                    </button>
                                                )}
                                            </div>
                                        </>
                                    )}

                                    {activeTimerTab === 'pomodoro' && (
                                        <>
                                            {pomodoroActive && (
                                                <div className={`pomodoro-phase ${pomodoroPhase}`}>
                                                    {pomodoroPhase === 'work' ? '🎯 Focus Time' : '☕ Break Time'}
                                                </div>
                                            )}

                                            <div className="timer-display">
                                                <div className="timer-time" style={{
                                                    color: pomodoroActive
                                                        ? (pomodoroPhase === 'work' ? 'var(--accent-focus)' : '#4ade80')
                                                        : 'var(--text-primary)'
                                                }}>
                                                    {pomodoroActive
                                                        ? formatTimerDisplay(pomodoroSeconds)
                                                        : formatTimerDisplay(pomodoroWorkDuration * 60)
                                                    }
                                                </div>
                                                <div className="timer-label">
                                                    {pomodoroActive
                                                        ? (pomodoroPhase === 'work' ? 'Until break' : 'Break remaining')
                                                        : 'Work duration'
                                                    }
                                                </div>
                                            </div>

                                            {pomodoroActive && pomodoroCycles > 0 && (
                                                <div className="pomodoro-cycles">
                                                    {Array.from({ length: Math.min(pomodoroCycles + 1, 8) }).map((_, i) => (
                                                        <div
                                                            key={i}
                                                            className={`cycle-dot ${i < pomodoroCycles ? 'completed' : 'current'}`}
                                                        />
                                                    ))}
                                                </div>
                                            )}

                                            {!pomodoroActive && (
                                                <>
                                                    <div className="pomodoro-settings">
                                                        <div className="pomodoro-setting">
                                                            <label>Work (min)</label>
                                                            <input
                                                                type="number"
                                                                min="1"
                                                                max="120"
                                                                value={pomodoroWorkDuration}
                                                                onChange={(e) => setPomodoroWorkDuration(Math.max(1, parseInt(e.target.value) || 25))}
                                                            />
                                                        </div>
                                                        <div className="pomodoro-setting">
                                                            <label>Break (min)</label>
                                                            <input
                                                                type="number"
                                                                min="1"
                                                                max="60"
                                                                value={pomodoroBreakDuration}
                                                                onChange={(e) => setPomodoroBreakDuration(Math.max(1, parseInt(e.target.value) || 5))}
                                                            />
                                                        </div>
                                                    </div>

                                                    <select
                                                        className="break-action-select"
                                                        value={pomodoroBreakAction}
                                                        onChange={(e) => setPomodoroBreakAction(e.target.value)}
                                                    >
                                                        <option value="pause">During break: Pause music</option>
                                                        <option value="energize">During break: Play energizing music</option>
                                                        <option value="calm">During break: Play calming music</option>
                                                    </select>
                                                </>
                                            )}

                                            <div className="timer-controls">
                                                {!pomodoroActive ? (
                                                    <button
                                                        className="timer-btn start"
                                                        onClick={startPomodoro}
                                                        disabled={playlist.length === 0}
                                                    >
                                                        Start Focus Session
                                                    </button>
                                                ) : (
                                                    <button
                                                        className="timer-btn stop"
                                                        onClick={stopPomodoro}
                                                    >
                                                        End Session
                                                    </button>
                                                )}
                                            </div>
                                        </>
                                    )}
                                </div>
                            </article>

                            <article className="panel intake-card">
                                <div className="intake-tabs" role="tablist" aria-label="Audio intake options">
                                    <button
                                        type="button"
                                        role="tab"
                                        aria-selected={intakeTab === 'files'}
                                        className="intake-tab"
                                        onClick={() => setIntakeTab('files')}
                                    >
                                        Files
                                    </button>
                                    <button
                                        type="button"
                                        role="tab"
                                        aria-selected={intakeTab === 'stream'}
                                        className="intake-tab"
                                        disabled={!isOnline}
                                        onClick={() => isOnline && setIntakeTab('stream')}
                                    >
                                        Stream
                                    </button>
                                </div>
                                {intakeTab === 'files' ? (
                                    <>
                                        <p>Add MP3s via drag/drop or picker. Local tracks stay offline.</p>
                                        <div
                                            className={dropZoneClasses.join(' ')}
                                            onClick={() => {
                                                if (fileInputRef.current) {
                                                    fileInputRef.current.click();
                                                }
                                            }}
                                            onDrop={handleDrop}
                                            onDragOver={handleDragOver}
                                            onDragEnter={handleDragEnter}
                                            onDragLeave={handleDragLeave}
                                            role="button"
                                            tabIndex={0}
                                            ref={dropZoneRef}
                                            onKeyDown={(event) => {
                                                if ((event.key === 'Enter' || event.key === ' ' || event.key === 'Spacebar') && fileInputRef.current) {
                                                    event.preventDefault();
                                                    fileInputRef.current.click();
                                                }
                                            }}
                                            aria-label="Add audio files"
                                        >
                                            <strong>📁 Drop files here</strong>
                                            <span>or press Enter to browse</span>
                                        </div>
                                        <label htmlFor="file-picker" className="sr-only">Browse audio files</label>
                                        <input
                                            id="file-picker"
                                            ref={fileInputRef}
                                            type="file"
                                            accept="audio/mpeg,audio/wav,audio/ogg,.mp3,.wav,.ogg"
                                            multiple
                                            className="sr-only"
                                            aria-label="Browse audio files"
                                            onChange={(e) => addLocalFiles(e.target.files)}
                                        />
                                    </>
                                ) : (
                                    <>
                                        {!isOnline && (
                                            <div className="alert-inline" role="alert">
                                                Stream tab disabled while offline.
                                            </div>
                                        )}
                                        <label htmlFor="stream-url" className="eyebrow">Direct MP3 URL</label>
                                        <input
                                            id="stream-url"
                                            type="url"
                                            placeholder={!isOnline ? "Streaming unavailable offline" : "https://example.com/track.mp3"}
                                            value={urlInput}
                                            onChange={(e) => setUrlInput(e.target.value)}
                                            onKeyDown={(e) => e.key === 'Enter' && !isOffline && addUrl()}
                                            disabled={!isOnline}
                                            aria-disabled={!isOnline}
                                        />
                                        <button
                                            type="button"
                                            className="primary-btn"
                                            onClick={addUrl}
                                            disabled={!isOnline || !urlInput.trim() || isValidatingUrl}
                                        >
                                            {isValidatingUrl ? 'Validating...' : 'Add URL'}
                                        </button>
                                    </>
                                )}
                            </article>

                            <article className="panel playlist-card">
                                <div className="playlist-header">
                                    <div>
                                        <p className="eyebrow">Playlist</p>
                                        <h3>{playlist.length} track{playlist.length === 1 ? '' : 's'}</h3>
                                    </div>
                                    <span>{playlistMinutes} min est.</span>
                                </div>

                                {/* Playlist Actions */}
                                <div className="playlist-actions">
                                    <button
                                        className="playlist-action-btn"
                                        onClick={() => setShowPlaylistModal(true)}
                                        title="Manage saved playlists"
                                    >
                                        📁 {savedPlaylists.length > 0 ? `Saved (${savedPlaylists.length})` : 'Save/Load'}
                                    </button>
                                </div>

                                {/* Playlist Search */}
                                {playlist.length > 0 && (
                                    <div className="playlist-search">
                                        <span className="playlist-search-icon">🔍</span>
                                        <input
                                            type="text"
                                            className="playlist-search-input"
                                            placeholder="Search tracks..."
                                            value={playlistSearch}
                                            onChange={(e) => setPlaylistSearch(e.target.value)}
                                            aria-label="Search playlist"
                                        />
                                        {playlistSearch && (
                                            <button
                                                className="playlist-search-clear"
                                                onClick={() => setPlaylistSearch('')}
                                                aria-label="Clear search"
                                            >
                                                ✕
                                            </button>
                                        )}
                                    </div>
                                )}

                                <ul className="playlist-list">
                                    {playlist.length === 0 && (
                                        <li>Add files or streams to populate the playlist.</li>
                                    )}
                                    {(() => {
                                        const filteredPlaylist = playlist.filter(track =>
                                            track.name.toLowerCase().includes(playlistSearch.toLowerCase())
                                        );

                                        if (playlist.length > 0 && filteredPlaylist.length === 0) {
                                            return (
                                                <li className="playlist-no-results">
                                                    No tracks matching "{playlistSearch}"
                                                </li>
                                            );
                                        }

                                        return filteredPlaylist.map((track) => {
                                            const index = playlist.indexOf(track);
                                        const trackRating = getTrackRating(track.name);
                                        const icons = RATING_ICONS[activePresetId] || RATING_ICONS.focus;
                                        const isRemoving = trackRating === 'remove';

                                        return (
                                        <li key={track.id} style={{
                                            transition: 'all 0.3s ease',
                                            opacity: isRemoving ? 0.3 : 1,
                                            transform: isRemoving ? 'translateX(20px)' : 'none'
                                        }}>
                                            <div
                                                className="playlist-button"
                                                role="button"
                                                tabIndex={0}
                                                aria-current={currentTrackIndex === index}
                                                onClick={() => {
                                                    sessionRitualFlagRef.current = false;
                                                    playTrack(index, { ritualUsed: false });
                                                }}
                                                onKeyDown={(event) => {
                                                    if (event.key === 'Enter') {
                                                        sessionRitualFlagRef.current = false;
                                                        playTrack(index, { ritualUsed: false });
                                                    }
                                                }}
                                                style={{
                                                    boxShadow: trackRating === 'boost'
                                                        ? `0 0 12px ${selectedMode.accent}, inset 0 0 8px rgba(255,255,255,0.1)`
                                                        : trackRating === 'neutral'
                                                        ? '0 0 4px rgba(255,255,255,0.1)'
                                                        : 'none',
                                                    borderLeft: trackRating === 'boost'
                                                        ? `3px solid ${selectedMode.accent}`
                                                        : trackRating === 'neutral'
                                                        ? '3px solid rgba(255,255,255,0.2)'
                                                        : '3px solid transparent'
                                                }}
                                            >
                                                <span className="badge">{track.source}</span>
                                                <div style={{ flex: 1 }}>
                                                    <div style={{
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        gap: '6px'
                                                    }}>
                                                        {track.name}
                                                        {trackRating === 'boost' && (
                                                            <span style={{ fontSize: '0.8rem' }}>{icons.boost.icon}</span>
                                                        )}
                                                        {/* Story 6-1: Cached track indicator (AC8) */}
                                                        {isTrackCached(track) && (
                                                            <span
                                                                className="cached-indicator"
                                                                title="Available offline"
                                                                aria-label="Track available offline"
                                                            >
                                                                <span className="cached-indicator-icon">
                                                                    ☁️✓
                                                                    <span className="cached-indicator-tooltip">Available offline</span>
                                                                </span>
                                                            </span>
                                                        )}
                                                    </div>

                                                    {/* File metadata */}
                                                    {track.metadata && (
                                                        <div className="playlist-meta">
                                                            <span>{formatFileType(track.metadata.type)}</span>
                                                            <span> • </span>
                                                            <span>{formatFileSize(track.metadata.size)}</span>
                                                        </div>
                                                    )}

                                                    {/* URL indicator or default preset message */}
                                                    {!track.metadata && (
                                                        <div className="playlist-meta">
                                                            <span>{track.source === 'url' ? '🌐 Streaming' : `${selectedMode.label} preset`}</span>
                                                        </div>
                                                    )}
                                                </div>

                                                {/* Rating buttons */}
                                                <div style={{
                                                    display: 'flex',
                                                    gap: '2px',
                                                    marginRight: '8px'
                                                }} onClick={e => e.stopPropagation()}>
                                                    <button
                                                        type="button"
                                                        title={`${icons.boost.label}: ${icons.boost.desc}`}
                                                        onClick={() => rateTrack(track.name, trackRating === 'boost' ? null : 'boost')}
                                                        style={{
                                                            padding: '4px 6px',
                                                            background: trackRating === 'boost' ? selectedMode.accent : 'rgba(255,255,255,0.1)',
                                                            border: 'none',
                                                            borderRadius: '4px',
                                                            cursor: 'pointer',
                                                            fontSize: '0.9rem',
                                                            opacity: trackRating === 'boost' ? 1 : 0.6,
                                                            transition: 'all 0.2s'
                                                        }}
                                                    >
                                                        {icons.boost.icon}
                                                    </button>
                                                    <button
                                                        type="button"
                                                        title={`${icons.neutral.label}: ${icons.neutral.desc}`}
                                                        onClick={() => rateTrack(track.name, trackRating === 'neutral' ? null : 'neutral')}
                                                        style={{
                                                            padding: '4px 6px',
                                                            background: trackRating === 'neutral' ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.1)',
                                                            border: 'none',
                                                            borderRadius: '4px',
                                                            cursor: 'pointer',
                                                            fontSize: '0.9rem',
                                                            opacity: trackRating === 'neutral' ? 1 : 0.6,
                                                            transition: 'all 0.2s'
                                                        }}
                                                    >
                                                        {icons.neutral.icon}
                                                    </button>
                                                    <button
                                                        type="button"
                                                        title={`${icons.remove.label}: ${icons.remove.desc}`}
                                                        onClick={() => rateTrack(track.name, 'remove')}
                                                        style={{
                                                            padding: '4px 6px',
                                                            background: 'rgba(239,68,68,0.2)',
                                                            border: 'none',
                                                            borderRadius: '4px',
                                                            cursor: 'pointer',
                                                            fontSize: '0.9rem',
                                                            opacity: 0.6,
                                                            transition: 'all 0.2s'
                                                        }}
                                                    >
                                                        {icons.remove.icon}
                                                    </button>
                                                </div>
                                            </div>
                                        </li>
                                        );
                                    });
                                    })()}
                                </ul>
                            </article>

                            <article className="panel advanced-controls">
                                <p className="eyebrow">Advanced Controls</p>
                                <div className="controls">
                                    <div className="control-group">
                                        <label htmlFor="speed">Rotation Speed</label>
                                        <input
                                            id="speed"
                                            type="range"
                                            min="0.1"
                                            max="2.0"
                                            step="0.1"
                                            value={speed}
                                            onChange={(e) => setSpeed(parseFloat(e.target.value))}
                                        />
                                        <div className="value-display">{speed.toFixed(1)}x</div>
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="intensity">Effect Intensity</label>
                                        <input
                                            id="intensity"
                                            type="range"
                                            min="0.0"
                                            max="1.0"
                                            step="0.1"
                                            value={intensity}
                                            onChange={(e) => setIntensity(parseFloat(e.target.value))}
                                        />
                                        <div className="value-display">{(intensity * 100).toFixed(0)}%</div>
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="depth">Spatial Depth</label>
                                        <input
                                            id="depth"
                                            type="range"
                                            min="0.0"
                                            max="1.0"
                                            step="0.1"
                                            value={spatialDepth}
                                            onChange={(e) => setSpatialDepth(parseFloat(e.target.value))}
                                        />
                                        <div className="value-display">{(spatialDepth * 100).toFixed(0)}%</div>
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="movement">Movement Pattern</label>
                                        <select
                                            id="movement"
                                            value={movementPattern}
                                            onChange={(e) => setMovementPattern(e.target.value)}
                                        >
                                            <option value="circle">🔄 Circle</option>
                                            <option value="figure8">∞ Figure-8</option>
                                            <option value="leftright">↔️ Left-Right</option>
                                            <option value="frontback">↕️ Front-Back</option>
                                            <option value="quadrant">Quadrant (Discrete Circle)</option>
                                            <option value="random">🎲 Random</option>
                                        </select>
                                    </div>
                                    <div className="control-group">
                                        <label>Binaural Beats {binauralEnabled && (
                                            <span className="badge">{getBinauralDescription(binauralFreq)}</span>
                                        )}</label>
                                        <div className="checkbox-wrapper">
                                            <input
                                                id="binaural-toggle"
                                                type="checkbox"
                                                checked={binauralEnabled}
                                                onChange={(e) => setBinauralEnabled(e.target.checked)}
                                            />
                                            <label htmlFor="binaural-toggle">Enable</label>
                                        </div>
                                        {binauralEnabled && (
                                            <>
                                                <input
                                                    id="binaural-frequency"
                                                    type="range"
                                                    min="1"
                                                    max="40"
                                                    step="1"
                                                    value={binauralFreq}
                                                    onChange={(e) => setBinauralFreq(parseInt(e.target.value, 10))}
                                                    style={{ marginTop: '10px' }}
                                                    aria-label="Binaural frequency"
                                                    aria-valuetext={`${binauralFreq} hertz`}
                                                />
                                                <div className="value-display">{binauralFreq}Hz</div>
                                            </>
                                        )}
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="noise">Background Noise</label>
                                        <select id="noise" value={noiseType} onChange={(e) => setNoiseType(e.target.value)}>
                                            <option value="none">None</option>
                                            <option value="white">White Noise</option>
                                            <option value="pink">Pink Noise</option>
                                        </select>
                                        <label htmlFor="noise-volume" className="sr-only">Noise volume</label>
                                        <input
                                            id="noise-volume"
                                            type="range"
                                            min="0.0"
                                            max="0.5"
                                            step="0.05"
                                            value={noiseVolume}
                                            onChange={(e) => setNoiseVolume(parseFloat(e.target.value))}
                                            style={{ marginTop: '10px' }}
                                            aria-label="Noise volume"
                                            aria-valuetext={`${Math.round(noiseVolume * 100)} percent`}
                                            disabled={noiseType === 'none'}
                                        />
                                        <div className="value-display">{noiseType === 'none' ? 'Muted' : `${(noiseVolume * 100).toFixed(0)}%`}</div>
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="visual-wave">Visualizer Intensity</label>
                                        <input
                                            id="visual-wave"
                                            type="range"
                                            min="0.0"
                                            max="0.5"
                                            step="0.05"
                                            value={visualWaveGain}
                                            onChange={(e) => setVisualWaveGain(parseFloat(e.target.value))}
                                            aria-label="Visualizer intensity"
                                            aria-valuetext={`${Math.round(visualWaveGain * 100)} percent`}
                                        />
                                        <div className="value-display">{(visualWaveGain * 100).toFixed(0)}%</div>
                                    </div>
                                </div>
                            </article>
                        </section>

                        <aside className="column-card insights-column">
                            {/* Story 4-3: Insights Dashboard */}
                            <InsightsPanel
                                sessions={insightsSessions}
                                dateRange={insightsDateRange}
                                setDateRange={setInsightsDateRange}
                                selectedMode={selectedMode}
                                reducedMotion={reducedMotion}
                                showToast={showToast}
                                allPresets={allPresets}
                            />

                            <div className="panel insight-card">
                                <p className="eyebrow">Focus confidence</p>
                                <div className="insight-value">{focusConfidence}%</div>
                                <p className="hero-support">Derived from preset + playlist depth.</p>
                            </div>
                            <div className="panel insight-card">
                                <p className="eyebrow">Calm streak</p>
                                <div className="insight-value">{streakMinutes} min</div>
                                <p className="hero-support">Last {playlist.length || 0} sessions logged.</p>
                            </div>
                            <div className="panel sensor-card">
                                <strong>Sensor readiness</strong>
                                <p>{isOnline ? 'Optional BLE strap ready—pair via browser settings.' : 'Reconnect to the internet to enable streaming + sensors.'}</p>
                            </div>
                            <div className="panel insight-card">
                                <p className="eyebrow">Session log</p>
                                <p className="hero-support">
                                    {activeSessionId ? `Logging session #${activeSessionId}` : 'Idle — starts automatically when playback begins.'}
                                </p>
                                <div className="session-log-actions">
                                    <button
                                        type="button"
                                        onClick={handleClearSessions}
                                        disabled={isClearingSessions}
                                    >
                                        {isClearingSessions ? 'Clearing…' : 'Clear profile history'}
                                    </button>
                                    <button
                                        type="button"
                                        onClick={handleTrimOldSessions}
                                        disabled={isTrimmingSessions}
                                    >
                                        {isTrimmingSessions ? 'Trimming…' : 'Clear 30-day+ history'}
                                    </button>
                                </div>
                            </div>
                        </aside>
                    </div>

                    {/* Mobile Views Container - Only visible on mobile */}
                    <div className="mobile-views-container">
                        {/* Now Playing - Always visible at top on mobile */}
                        <article className="panel now-playing-card mobile-player-fixed">
                            <div className="playlist-header" style={{ marginBottom: nowPlayingTrack ? '0' : '16px' }}>
                                <div>
                                    <p className="eyebrow">Now Playing</p>
                                </div>
                                <span className="status-pill" style={{ borderColor: selectedMode.accent }}>
                                    {selectedMode.label}
                                </span>
                            </div>

                            {/* Track Info with Album Art */}
                            <div className="now-playing-track-info">
                                <div className="album-art" style={{
                                    boxShadow: isPlaying ? `0 0 20px ${selectedMode.accent}40` : 'none',
                                    transition: 'box-shadow 0.3s ease'
                                }}>
                                    {nowPlayingTrack?.albumArt ? (
                                        <img src={nowPlayingTrack.albumArt} alt="Album art" />
                                    ) : (
                                        <span style={{
                                            animation: isPlaying ? 'pulse 2s ease-in-out infinite' : 'none'
                                        }}>
                                            {getAlbumArtIcon()}
                                        </span>
                                    )}
                                </div>
                                <div className="track-details">
                                    <h3 className="track-title" title={trackInfo.title}>
                                        {trackInfo.title}
                                    </h3>
                                    {trackInfo.artist && (
                                        <p className="track-artist" title={trackInfo.artist}>
                                            {trackInfo.artist}
                                        </p>
                                    )}
                                    <p className="track-source">
                                        {trackInfo.source || 'playlist empty'} • {playlist.length} track{playlist.length === 1 ? '' : 's'}
                                    </p>
                                </div>
                            </div>

                            <div className="transport-controls" aria-label="Playback controls">
                                <button
                                    type="button"
                                    className="transport-button"
                                    onClick={playPrevious}
                                    aria-label="Play previous track"
                                    disabled={playlist.length === 0}
                                >
                                    ⏮
                                </button>
                                <button
                                    type="button"
                                    className="transport-button play"
                                    onClick={togglePlayPause}
                                    aria-label={isPlaying ? 'Pause playback' : 'Play'}
                                    disabled={playlist.length === 0}
                                >
                                    {isPlaying ? '⏸' : '▶️'}
                                </button>
                                <button
                                    type="button"
                                    className="transport-button"
                                    onClick={playNext}
                                    aria-label="Play next track"
                                    disabled={playlist.length === 0}
                                >
                                    ⏭
                                </button>
                            </div>
                            <div className="timeline">
                                <label htmlFor="mobile-timeline" className="eyebrow">Timeline</label>
                                <input
                                    id="mobile-timeline"
                                    type="range"
                                    min="0"
                                    max={duration || 0}
                                    step="0.1"
                                    value={Math.min(currentTime, duration || 0)}
                                    onChange={handleSeekChange}
                                    aria-valuetext={`${formatTime(currentTime)} of ${formatTime(duration)}`}
                                    disabled={!duration}
                                />
                                <div className="timeline__timestamps">
                                    <span>{formatTime(currentTime)}</span>
                                    <span>{formatTime(duration)}</span>
                                </div>
                            </div>
                            <div className="volume-control" style={{ marginTop: '12px' }}>
                                <label htmlFor="mobile-volume" className="eyebrow">Volume</label>
                                <input
                                    id="mobile-volume"
                                    type="range"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value={volume}
                                    onChange={(e) => setVolume(parseFloat(e.target.value))}
                                    aria-valuetext={`${Math.round(volume * 100)} percent`}
                                />
                                <div className="value-display">{Math.round(volume * 100)}%</div>
                            </div>

                            {/* Mobile Visualizer - Inline + Fullscreen Button */}
                            <div style={{ marginTop: '16px' }}>
                                {/* Inline Canvas with song name overlay */}
                                <div style={{
                                    position: 'relative',
                                    borderRadius: '12px',
                                    overflow: 'hidden',
                                    border: `1px solid ${isPlaying ? selectedMode.accent + '40' : 'rgba(255,255,255,0.1)'}`,
                                    marginBottom: '8px'
                                }}>
                                    {/* Song name on top */}
                                    {isPlaying && nowPlayingTrack && (
                                        <div style={{
                                            position: 'absolute',
                                            top: 0,
                                            left: 0,
                                            right: 0,
                                            padding: '6px 10px',
                                            background: 'linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, transparent 100%)',
                                            zIndex: 2,
                                            pointerEvents: 'none'
                                        }}>
                                            <div style={{
                                                fontSize: '0.75rem',
                                                fontWeight: '600',
                                                color: 'white',
                                                whiteSpace: 'nowrap',
                                                overflow: 'hidden',
                                                textOverflow: 'ellipsis',
                                                textShadow: '0 1px 3px rgba(0,0,0,0.5)'
                                            }}>
                                                {trackInfo.title}{trackInfo.artist ? ` — ${trackInfo.artist}` : ''}
                                            </div>
                                        </div>
                                    )}
                                    <canvas
                                        ref={mobileCanvasRef}
                                        width={350}
                                        height={90}
                                        style={{
                                            width: '100%',
                                            height: '90px',
                                            display: 'block',
                                            background: darkMode ? '#1a2332' : '#0a0a0a'
                                        }}
                                        onClick={() => setVisualizerFullscreen(true)}
                                        role="img"
                                        aria-label="Audio visualizer - tap to go fullscreen"
                                    />
                                    {!isPlaying && (
                                        <div style={{
                                            position: 'absolute',
                                            top: 0,
                                            left: 0,
                                            right: 0,
                                            bottom: 0,
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            background: 'rgba(0,0,0,0.5)',
                                            color: 'var(--text-secondary)',
                                            fontSize: '0.8rem'
                                        }}>
                                            Play music to see visualizer
                                        </div>
                                    )}
                                </div>

                                {/* Hamburger menu for visualizer options */}
                                <div style={{ position: 'relative', display: 'flex', justifyContent: 'center' }}>
                                    {/* Hamburger trigger - shows current type icon + menu icon */}
                                    <button
                                        onClick={() => setVizMenuOpen(!vizMenuOpen)}
                                        style={{
                                            padding: '6px 16px',
                                            background: 'rgba(255,255,255,0.1)',
                                            border: 'none',
                                            borderRadius: '8px',
                                            color: 'white',
                                            fontSize: '0.85rem',
                                            cursor: 'pointer',
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '8px'
                                        }}
                                    >
                                        <span>{
                                            visualizerType === 'bars' ? '📊' :
                                            visualizerType === 'waveform' ? '〰️' :
                                            visualizerType === 'circular' ? '◎' :
                                            visualizerType === 'mirrored' ? '⫼' : '✨'
                                        }</span>
                                        <span style={{
                                            display: 'flex',
                                            flexDirection: 'column',
                                            gap: '3px',
                                            width: '14px'
                                        }}>
                                            <span style={{ height: '2px', background: 'white', borderRadius: '1px' }}></span>
                                            <span style={{ height: '2px', background: 'white', borderRadius: '1px' }}></span>
                                            <span style={{ height: '2px', background: 'white', borderRadius: '1px' }}></span>
                                        </span>
                                    </button>

                                    {/* Fullscreen button - always visible */}
                                    <button
                                        onClick={() => setVisualizerFullscreen(true)}
                                        disabled={!isPlaying}
                                        title="Fullscreen"
                                        style={{
                                            marginLeft: '8px',
                                            padding: '6px 12px',
                                            background: isPlaying ? selectedMode.accent : 'rgba(255,255,255,0.05)',
                                            border: 'none',
                                            borderRadius: '8px',
                                            color: 'white',
                                            fontSize: '0.85rem',
                                            cursor: isPlaying ? 'pointer' : 'not-allowed',
                                            opacity: isPlaying ? 1 : 0.5
                                        }}
                                    >
                                        ⛶
                                    </button>

                                    {/* Expandable menu */}
                                    {vizMenuOpen && (
                                        <div style={{
                                            position: 'absolute',
                                            bottom: '100%',
                                            left: '50%',
                                            transform: 'translateX(-50%)',
                                            marginBottom: '8px',
                                            background: 'rgba(20, 20, 30, 0.95)',
                                            borderRadius: '12px',
                                            padding: '8px',
                                            boxShadow: '0 4px 20px rgba(0,0,0,0.5)',
                                            border: '1px solid rgba(255,255,255,0.1)',
                                            animation: 'slideUp 0.2s ease-out',
                                            zIndex: 10
                                        }}>
                                            {/* Close button */}
                                            <button
                                                onClick={() => setVizMenuOpen(false)}
                                                style={{
                                                    position: 'absolute',
                                                    top: '4px',
                                                    right: '4px',
                                                    background: 'transparent',
                                                    border: 'none',
                                                    color: 'rgba(255,255,255,0.6)',
                                                    fontSize: '0.9rem',
                                                    cursor: 'pointer',
                                                    padding: '4px 6px',
                                                    lineHeight: 1
                                                }}
                                            >
                                                ✕
                                            </button>

                                            {/* Menu items */}
                                            <div style={{ display: 'flex', gap: '6px', paddingTop: '4px' }}>
                                                {[
                                                    { id: 'bars', icon: '📊', label: 'Bars' },
                                                    { id: 'waveform', icon: '〰️', label: 'Wave' },
                                                    { id: 'circular', icon: '◎', label: 'Circle' },
                                                    { id: 'mirrored', icon: '⫼', label: 'Mirror' },
                                                    { id: 'particles', icon: '✨', label: 'Particles' }
                                                ].map(type => (
                                                    <button
                                                        key={type.id}
                                                        onClick={() => {
                                                            setVisualizerType(type.id);
                                                            setVizMenuOpen(false);
                                                        }}
                                                        style={{
                                                            padding: '8px 10px',
                                                            background: visualizerType === type.id ? selectedMode.accent : 'rgba(255,255,255,0.1)',
                                                            border: 'none',
                                                            borderRadius: '8px',
                                                            color: 'white',
                                                            fontSize: '0.8rem',
                                                            cursor: 'pointer',
                                                            display: 'flex',
                                                            flexDirection: 'column',
                                                            alignItems: 'center',
                                                            gap: '2px',
                                                            minWidth: '50px',
                                                            transition: 'transform 0.15s ease'
                                                        }}
                                                    >
                                                        <span style={{ fontSize: '1.1rem' }}>{type.icon}</span>
                                                        <span style={{ fontSize: '0.65rem', opacity: 0.8 }}>{type.label}</span>
                                                    </button>
                                                ))}
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </article>

                        {/* Timer View - Sleep & Focus Timers */}
                        <div className={`mobile-view ${mobileView === 'timer' ? 'active' : ''}`}>
                            {/* Timer Section */}
                            <div className="timer-section panel">
                                <div className="timer-tabs">
                                    <button
                                        className={`timer-tab ${activeTimerTab === 'sleep' ? 'active' : ''}`}
                                        onClick={() => setActiveTimerTab('sleep')}
                                    >
                                        😴 Sleep
                                    </button>
                                    <button
                                        className={`timer-tab ${activeTimerTab === 'pomodoro' ? 'active' : ''}`}
                                        onClick={() => setActiveTimerTab('pomodoro')}
                                    >
                                        🍅 Focus
                                    </button>
                                </div>

                                {activeTimerTab === 'sleep' && (
                                    <>
                                        <div className="timer-display">
                                            <div className="timer-time">
                                                {sleepTimerActive
                                                    ? formatTimerDisplay(sleepTimerSeconds)
                                                    : formatTimerDisplay(sleepTimerDuration)
                                                }
                                            </div>
                                            <div className="timer-label">
                                                {sleepTimerActive ? 'Until sleep' : 'Set duration'}
                                            </div>
                                        </div>

                                        {!sleepTimerActive && (
                                            <div className="timer-presets">
                                                {[
                                                    { label: '15m', seconds: 15 * 60 },
                                                    { label: '30m', seconds: 30 * 60 },
                                                    { label: '1h', seconds: 60 * 60 },
                                                    { label: '2h', seconds: 120 * 60 }
                                                ].map(preset => (
                                                    <button
                                                        key={preset.label}
                                                        className={`timer-preset ${sleepTimerDuration === preset.seconds ? 'selected' : ''}`}
                                                        onClick={() => setSleepTimerDuration(preset.seconds)}
                                                    >
                                                        {preset.label}
                                                    </button>
                                                ))}
                                            </div>
                                        )}

                                        <div className="timer-controls">
                                            {!sleepTimerActive ? (
                                                <button
                                                    className="timer-btn start"
                                                    onClick={startSleepTimer}
                                                    disabled={playlist.length === 0}
                                                >
                                                    Start Sleep Timer
                                                </button>
                                            ) : (
                                                <button
                                                    className="timer-btn stop"
                                                    onClick={stopSleepTimer}
                                                >
                                                    Cancel
                                                </button>
                                            )}
                                        </div>
                                    </>
                                )}

                                {activeTimerTab === 'pomodoro' && (
                                    <>
                                        {pomodoroActive && (
                                            <div className={`pomodoro-phase ${pomodoroPhase}`}>
                                                {pomodoroPhase === 'work' ? '🎯 Focus' : '☕ Break'}
                                            </div>
                                        )}

                                        <div className="timer-display">
                                            <div className="timer-time" style={{
                                                color: pomodoroActive
                                                    ? (pomodoroPhase === 'work' ? 'var(--accent-focus)' : '#4ade80')
                                                    : 'var(--text-primary)'
                                            }}>
                                                {pomodoroActive
                                                    ? formatTimerDisplay(pomodoroSeconds)
                                                    : formatTimerDisplay(pomodoroWorkDuration * 60)
                                                }
                                            </div>
                                        </div>

                                        {!pomodoroActive && (
                                            <div className="pomodoro-settings">
                                                <div className="pomodoro-setting">
                                                    <label>Work</label>
                                                    <input
                                                        type="number"
                                                        min="1"
                                                        max="120"
                                                        value={pomodoroWorkDuration}
                                                        onChange={(e) => setPomodoroWorkDuration(Math.max(1, parseInt(e.target.value) || 25))}
                                                    />
                                                </div>
                                                <div className="pomodoro-setting">
                                                    <label>Break</label>
                                                    <input
                                                        type="number"
                                                        min="1"
                                                        max="60"
                                                        value={pomodoroBreakDuration}
                                                        onChange={(e) => setPomodoroBreakDuration(Math.max(1, parseInt(e.target.value) || 5))}
                                                    />
                                                </div>
                                            </div>
                                        )}

                                        <div className="timer-controls">
                                            {!pomodoroActive ? (
                                                <button
                                                    className="timer-btn start"
                                                    onClick={startPomodoro}
                                                    disabled={playlist.length === 0}
                                                >
                                                    Start Focus
                                                </button>
                                            ) : (
                                                <button
                                                    className="timer-btn stop"
                                                    onClick={stopPomodoro}
                                                >
                                                    End Session
                                                </button>
                                            )}
                                        </div>
                                    </>
                                )}
                            </div>
                        </div>

                        {/* Queue View - Add songs + Playlist management */}
                        <div className={`mobile-view ${mobileView === 'queue' ? 'active' : ''}`}>
                            {/* Intake Panel */}
                            <article className="panel intake-card">
                                <div className="intake-tabs" role="tablist" aria-label="Audio intake options">
                                    <button
                                        type="button"
                                        role="tab"
                                        aria-selected={intakeTab === 'files'}
                                        className="intake-tab"
                                        onClick={() => setIntakeTab('files')}
                                    >
                                        Files
                                    </button>
                                    <button
                                        type="button"
                                        role="tab"
                                        aria-selected={intakeTab === 'stream'}
                                        className="intake-tab"
                                        disabled={!isOnline}
                                        onClick={() => isOnline && setIntakeTab('stream')}
                                    >
                                        Stream
                                    </button>
                                </div>
                                {intakeTab === 'files' ? (
                                    <>
                                        <p>Add MP3s via drag/drop or picker.</p>
                                        <div
                                            className={dropZoneClasses.join(' ')}
                                            onClick={() => {
                                                if (fileInputRef.current) {
                                                    fileInputRef.current.click();
                                                }
                                            }}
                                            onDrop={handleDrop}
                                            onDragOver={handleDragOver}
                                            onDragEnter={handleDragEnter}
                                            onDragLeave={handleDragLeave}
                                            role="button"
                                            tabIndex={0}
                                            onKeyDown={(event) => {
                                                if ((event.key === 'Enter' || event.key === ' ' || event.key === 'Spacebar') && fileInputRef.current) {
                                                    event.preventDefault();
                                                    fileInputRef.current.click();
                                                }
                                            }}
                                            aria-label="Add audio files"
                                        >
                                            <strong>📁 Drop files here</strong>
                                            <span>or tap to browse</span>
                                        </div>
                                    </>
                                ) : (
                                    <>
                                        {!isOnline && (
                                            <div className="alert-inline" role="alert">
                                                Stream tab disabled while offline.
                                            </div>
                                        )}
                                        <label htmlFor="mobile-stream-url" className="eyebrow">Direct MP3 URL</label>
                                        <input
                                            id="mobile-stream-url"
                                            type="url"
                                            placeholder={!isOnline ? "Streaming unavailable offline" : "https://example.com/track.mp3"}
                                            value={urlInput}
                                            onChange={(e) => setUrlInput(e.target.value)}
                                            onKeyDown={(e) => e.key === 'Enter' && !isOffline && addUrl()}
                                            disabled={!isOnline}
                                            aria-disabled={!isOnline}
                                        />
                                        <button
                                            type="button"
                                            className="primary-btn"
                                            onClick={addUrl}
                                            disabled={!isOnline || !urlInput.trim() || isValidatingUrl}
                                            style={{ marginTop: '8px' }}
                                        >
                                            {isValidatingUrl ? 'Validating...' : 'Add URL'}
                                        </button>
                                    </>
                                )}
                            </article>

                            {/* Playlist Panel */}
                            <article className="panel playlist-card">
                                <div className="playlist-header">
                                    <div>
                                        <p className="eyebrow">Playlist</p>
                                        <h3>{playlist.length} track{playlist.length === 1 ? '' : 's'}</h3>
                                    </div>
                                    <span>{playlistMinutes} min</span>
                                </div>

                                {/* Playlist Actions */}
                                <div className="playlist-actions">
                                    <button
                                        className="playlist-action-btn"
                                        onClick={() => setShowPlaylistModal(true)}
                                        title="Manage saved playlists"
                                    >
                                        📁 {savedPlaylists.length > 0 ? `Saved (${savedPlaylists.length})` : 'Save/Load'}
                                    </button>
                                </div>

                                {/* Playlist Search */}
                                {playlist.length > 0 && (
                                    <div className="playlist-search">
                                        <span className="playlist-search-icon">🔍</span>
                                        <input
                                            type="text"
                                            className="playlist-search-input"
                                            placeholder="Search tracks..."
                                            value={playlistSearch}
                                            onChange={(e) => setPlaylistSearch(e.target.value)}
                                            aria-label="Search playlist"
                                        />
                                        {playlistSearch && (
                                            <button
                                                className="playlist-search-clear"
                                                onClick={() => setPlaylistSearch('')}
                                                aria-label="Clear search"
                                            >
                                                ✕
                                            </button>
                                        )}
                                    </div>
                                )}

                                <ul className="playlist-tracks" role="listbox" aria-label="Playlist tracks">
                                    {(() => {
                                        const filteredPlaylist = playlist.filter(track =>
                                            track.name.toLowerCase().includes(playlistSearch.toLowerCase())
                                        );
                                        if (playlist.length > 0 && filteredPlaylist.length === 0) {
                                            return (
                                                <li className="playlist-no-results">
                                                    No tracks matching "{playlistSearch}"
                                                </li>
                                            );
                                        }
                                        return filteredPlaylist.map((track) => {
                                            const index = playlist.indexOf(track);
                                            const trackRating = getTrackRating(track.name);
                                            const icons = RATING_ICONS[activePresetId] || RATING_ICONS.focus;
                                            const isRemoving = trackRating === 'remove';
                                            return (
                                                <li
                                                    key={track.name + index}
                                                    className={`playlist-track ${index === currentTrackIndex ? 'active' : ''}`}
                                                    role="option"
                                                    aria-selected={index === currentTrackIndex}
                                                    style={{
                                                        opacity: isRemoving ? 0.3 : 1,
                                                        borderLeft: trackRating === 'boost'
                                                            ? `3px solid ${selectedMode.accent}`
                                                            : trackRating === 'neutral'
                                                            ? '3px solid rgba(255,255,255,0.2)'
                                                            : '3px solid transparent'
                                                    }}
                                                >
                                                    <div
                                                        onClick={() => playTrack(index, { ritualUsed: false })}
                                                        style={{ flex: 1, cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '6px' }}
                                                    >
                                                        <span className="playlist-track__name">
                                                            {track.name}
                                                            {trackRating === 'boost' && (
                                                                <span style={{ marginLeft: '4px', fontSize: '0.8rem' }}>{icons.boost.icon}</span>
                                                            )}
                                                            {/* Story 6-1: Cached track indicator (AC8) */}
                                                            {isTrackCached(track) && (
                                                                <span
                                                                    className="cached-indicator"
                                                                    title="Available offline"
                                                                    aria-label="Track available offline"
                                                                >
                                                                    ☁️✓
                                                                </span>
                                                            )}
                                                        </span>
                                                    </div>
                                                    {/* Rating buttons */}
                                                    <div style={{ display: 'flex', gap: '2px' }} onClick={e => e.stopPropagation()}>
                                                        <button
                                                            type="button"
                                                            title={icons.boost.label}
                                                            onClick={() => rateTrack(track.name, trackRating === 'boost' ? null : 'boost')}
                                                            style={{
                                                                padding: '4px 6px',
                                                                background: trackRating === 'boost' ? selectedMode.accent : 'rgba(255,255,255,0.1)',
                                                                border: 'none',
                                                                borderRadius: '4px',
                                                                cursor: 'pointer',
                                                                fontSize: '0.85rem',
                                                                opacity: trackRating === 'boost' ? 1 : 0.6
                                                            }}
                                                        >
                                                            {icons.boost.icon}
                                                        </button>
                                                        <button
                                                            type="button"
                                                            title={icons.neutral.label}
                                                            onClick={() => rateTrack(track.name, trackRating === 'neutral' ? null : 'neutral')}
                                                            style={{
                                                                padding: '4px 6px',
                                                                background: trackRating === 'neutral' ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.1)',
                                                                border: 'none',
                                                                borderRadius: '4px',
                                                                cursor: 'pointer',
                                                                fontSize: '0.85rem',
                                                                opacity: trackRating === 'neutral' ? 1 : 0.6
                                                            }}
                                                        >
                                                            {icons.neutral.icon}
                                                        </button>
                                                        <button
                                                            type="button"
                                                            title="Remove"
                                                            onClick={() => removeTrack(index)}
                                                            style={{
                                                                padding: '4px 6px',
                                                                background: 'rgba(239,68,68,0.2)',
                                                                border: 'none',
                                                                borderRadius: '4px',
                                                                cursor: 'pointer',
                                                                fontSize: '0.85rem',
                                                                opacity: 0.6
                                                            }}
                                                        >
                                                            ✕
                                                        </button>
                                                    </div>
                                                </li>
                                            );
                                        });
                                    })()}
                                </ul>
                            </article>
                        </div>

                        {/* Settings View - Mode selection + Advanced controls + Stats */}
                        <div className={`mobile-view ${mobileView === 'settings' ? 'active' : ''}`}>
                            {/* Mode Selection */}
                            <article className="panel">
                                <p className="eyebrow">Mode</p>
                                <div className="mode-tabs" role="tablist" aria-label="Ritual modes">
                                    {MODE_LIBRARY.map((mode, index) => (
                                        <button
                                            key={mode.id}
                                            id={`mobile-mode-tab-${mode.id}`}
                                            role="tab"
                                            aria-selected={activePresetId === mode.id}
                                            className="mode-chip"
                                            style={{ '--chip-accent': mode.accent }}
                                            onClick={() => setActiveMode(index)}
                                        >
                                            <span>{mode.label}</span>
                                        </button>
                                    ))}
                                </div>

                                {/* Quick ritual start */}
                                <div className="hero-actions" style={{ marginTop: '16px' }}>
                                    <button type="button" className="primary-btn" onClick={startRitual}>
                                        Start {selectedMode.label}
                                    </button>
                                </div>
                            </article>

                            {/* Quick Stats */}
                            <div className="panel insight-card">
                                <p className="eyebrow">Focus confidence</p>
                                <div className="insight-value">{focusConfidence}%</div>
                            </div>

                            {/* Advanced Controls */}
                            <article className="panel">
                                <p className="eyebrow">Audio Settings</p>
                                <button
                                    onClick={() => setShowSpatialTuner(true)}
                                    style={{
                                        width: '100%',
                                        padding: '12px',
                                        background: hasRunCalibration ? 'rgba(74, 222, 128, 0.2)' : 'var(--accent-focus)',
                                        color: hasRunCalibration ? '#4ade80' : 'white',
                                        border: hasRunCalibration ? '1px solid #4ade80' : 'none',
                                        borderRadius: '8px',
                                        cursor: 'pointer',
                                        fontWeight: '600',
                                        marginBottom: '12px'
                                    }}
                                >
                                    {hasRunCalibration ? '✓ Audio Calibrated - Adjust' : 'Run Calibration Wizard'}
                                </button>

                                <div className="controls" style={{ gap: '12px' }}>
                                    <div className="control-group">
                                        <label htmlFor="mobile-speed">Rotation Speed</label>
                                        <input
                                            id="mobile-speed"
                                            type="range"
                                            min="0.1"
                                            max="2.0"
                                            step="0.1"
                                            value={speed}
                                            onChange={(e) => setSpeed(parseFloat(e.target.value))}
                                        />
                                        <div className="value-display">{speed.toFixed(1)}x</div>
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="mobile-intensity">Effect Intensity</label>
                                        <input
                                            id="mobile-intensity"
                                            type="range"
                                            min="0.0"
                                            max="1.0"
                                            step="0.1"
                                            value={intensity}
                                            onChange={(e) => setIntensity(parseFloat(e.target.value))}
                                        />
                                        <div className="value-display">{(intensity * 100).toFixed(0)}%</div>
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="mobile-depth">Spatial Depth</label>
                                        <input
                                            id="mobile-depth"
                                            type="range"
                                            min="0.0"
                                            max="1.0"
                                            step="0.1"
                                            value={spatialDepth}
                                            onChange={(e) => setSpatialDepth(parseFloat(e.target.value))}
                                        />
                                        <div className="value-display">{(spatialDepth * 100).toFixed(0)}%</div>
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="mobile-movement">Movement Pattern</label>
                                        <select
                                            id="mobile-movement"
                                            value={movementPattern}
                                            onChange={(e) => setMovementPattern(e.target.value)}
                                            style={{ width: '100%', padding: '8px', borderRadius: '6px', border: '1px solid var(--card-border)', background: 'var(--surface)', color: 'var(--text-primary)' }}
                                        >
                                            <option value="circle">🔄 Circle</option>
                                            <option value="figure8">∞ Figure-8</option>
                                            <option value="leftright">↔️ Left-Right</option>
                                            <option value="frontback">↕️ Front-Back</option>
                                            <option value="quadrant">◻️ Quadrant</option>
                                            <option value="random">🎲 Random</option>
                                        </select>
                                    </div>
                                    <div className="control-group">
                                        <label>Binaural Beats {binauralEnabled && (
                                            <span className="badge" style={{ marginLeft: '8px' }}>{getBinauralDescription(binauralFreq)}</span>
                                        )}</label>
                                        <div className="checkbox-wrapper">
                                            <input
                                                id="mobile-binaural-toggle"
                                                type="checkbox"
                                                checked={binauralEnabled}
                                                onChange={(e) => setBinauralEnabled(e.target.checked)}
                                            />
                                            <label htmlFor="mobile-binaural-toggle">Enable</label>
                                        </div>
                                        {binauralEnabled && (
                                            <>
                                                <input
                                                    id="mobile-binaural-freq"
                                                    type="range"
                                                    min="1"
                                                    max="40"
                                                    step="1"
                                                    value={binauralFreq}
                                                    onChange={(e) => setBinauralFreq(parseInt(e.target.value, 10))}
                                                    style={{ marginTop: '8px' }}
                                                />
                                                <div className="value-display">{binauralFreq}Hz</div>
                                            </>
                                        )}
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="mobile-noise">Background Noise</label>
                                        <select
                                            id="mobile-noise"
                                            value={noiseType}
                                            onChange={(e) => setNoiseType(e.target.value)}
                                            style={{ width: '100%', padding: '8px', borderRadius: '6px', border: '1px solid var(--card-border)', background: 'var(--surface)', color: 'var(--text-primary)' }}
                                        >
                                            <option value="none">None</option>
                                            <option value="white">White Noise</option>
                                            <option value="pink">Pink Noise</option>
                                        </select>
                                        {noiseType !== 'none' && (
                                            <>
                                                <input
                                                    id="mobile-noise-volume"
                                                    type="range"
                                                    min="0.0"
                                                    max="0.5"
                                                    step="0.05"
                                                    value={noiseVolume}
                                                    onChange={(e) => setNoiseVolume(parseFloat(e.target.value))}
                                                    style={{ marginTop: '8px' }}
                                                />
                                                <div className="value-display">{(noiseVolume * 100).toFixed(0)}%</div>
                                            </>
                                        )}
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="mobile-viz-intensity">Visualizer Intensity</label>
                                        <input
                                            id="mobile-viz-intensity"
                                            type="range"
                                            min="0.0"
                                            max="0.5"
                                            step="0.05"
                                            value={visualWaveGain}
                                            onChange={(e) => setVisualWaveGain(parseFloat(e.target.value))}
                                        />
                                        <div className="value-display">{(visualWaveGain * 100).toFixed(0)}%</div>
                                    </div>
                                </div>
                            </article>

                            {/* Session Info */}
                            <div className="panel insight-card">
                                <p className="eyebrow">Session</p>
                                <p className="hero-support">
                                    {activeSessionId ? `Logging session #${activeSessionId}` : 'Idle'}
                                </p>
                            </div>
                        </div>
                    </div>

                    {/* Mobile Bottom Navigation */}
                    <nav className="mobile-bottom-nav" aria-label="Mobile navigation">
                        <div className="mobile-nav-items">
                            <button
                                className={`mobile-nav-item ${mobileView === 'timer' ? 'active' : ''}`}
                                onClick={() => setMobileView('timer')}
                                aria-label="Timers"
                                aria-current={mobileView === 'timer' ? 'page' : undefined}
                            >
                                <span className="mobile-nav-icon">{sleepTimerActive || pomodoroActive ? '⏰' : '🕐'}</span>
                                <span className="mobile-nav-label">Timer</span>
                            </button>
                            <button
                                className={`mobile-nav-item ${mobileView === 'queue' ? 'active' : ''}`}
                                onClick={() => setMobileView('queue')}
                                aria-label="Queue and Playlist"
                                aria-current={mobileView === 'queue' ? 'page' : undefined}
                                style={{ position: 'relative' }}
                            >
                                <span className="mobile-nav-icon">📋</span>
                                <span className="mobile-nav-label">Queue</span>
                                {playlist.length > 0 && (
                                    <span className="mobile-nav-badge">{playlist.length}</span>
                                )}
                            </button>
                            <button
                                className={`mobile-nav-item ${mobileView === 'settings' ? 'active' : ''}`}
                                onClick={() => setMobileView('settings')}
                                aria-label="Settings and Controls"
                                aria-current={mobileView === 'settings' ? 'page' : undefined}
                            >
                                <span className="mobile-nav-icon">⚙️</span>
                                <span className="mobile-nav-label">Settings</span>
                            </button>
                        </div>
                    </nav>

                    {/* Fullscreen Visualizer Overlay - Canvas + Controls */}
                    {visualizerFullscreen && (
                        <div className="fullscreen-visualizer-overlay">
                            {/* Fullscreen Canvas */}
                            <canvas
                                ref={fullscreenCanvasRef}
                                width={window.innerWidth}
                                height={window.innerHeight}
                                style={{
                                    position: 'absolute',
                                    top: 0,
                                    left: 0,
                                    width: '100%',
                                    height: '100%'
                                }}
                                onClick={() => setVisualizerFullscreen(false)}
                            />

                            {/* Track info - at TOP */}
                            {nowPlayingTrack && (
                                <div style={{
                                    position: 'fixed',
                                    top: '20px',
                                    left: '50%',
                                    transform: 'translateX(-50%)',
                                    zIndex: 100000,
                                    textAlign: 'center',
                                    color: 'white',
                                    textShadow: '0 2px 10px rgba(0, 0, 0, 0.8)',
                                    padding: '12px 24px',
                                    background: 'rgba(0, 0, 0, 0.5)',
                                    borderRadius: '12px',
                                    backdropFilter: 'blur(10px)',
                                    maxWidth: '90vw'
                                }}>
                                    <div style={{ fontSize: '1.2rem', fontWeight: '600', marginBottom: '4px' }}>{trackInfo.title}</div>
                                    {trackInfo.artist && (
                                        <div style={{ fontSize: '0.9rem', opacity: 0.8 }}>{trackInfo.artist}</div>
                                    )}
                                </div>
                            )}

                            {/* Close button - top left */}
                            <button
                                className="fullscreen-viz-close"
                                onClick={() => setVisualizerFullscreen(false)}
                                aria-label="Exit fullscreen"
                            >
                                ✕
                            </button>

                            {/* Menu bar - below song name, expands down */}
                            <div style={{
                                position: 'fixed',
                                top: nowPlayingTrack ? '100px' : '20px',
                                left: '50%',
                                transform: 'translateX(-50%)',
                                zIndex: 100000,
                                display: 'flex',
                                flexDirection: 'column',
                                alignItems: 'center'
                            }}>
                                {/* Single horizontal bar trigger */}
                                <button
                                    onClick={() => setVizMenuOpen(!vizMenuOpen)}
                                    style={{
                                        width: '60px',
                                        height: '6px',
                                        background: 'rgba(255,255,255,0.5)',
                                        border: 'none',
                                        borderRadius: '3px',
                                        cursor: 'pointer',
                                        marginBottom: vizMenuOpen ? '12px' : '0'
                                    }}
                                    aria-label="Toggle visualizer menu"
                                />

                                {/* Expanded buttons - appear below the bar */}
                                {vizMenuOpen && (
                                    <div style={{
                                        display: 'flex',
                                        gap: '8px',
                                        padding: '10px 16px',
                                        background: 'rgba(20, 20, 30, 0.95)',
                                        borderRadius: '12px',
                                        boxShadow: '0 4px 20px rgba(0,0,0,0.5)',
                                        border: '1px solid rgba(255,255,255,0.1)',
                                        animation: 'slideDownButtons 0.2s ease-out',
                                        position: 'relative'
                                    }}>
                                        {/* Close X button */}
                                        <button
                                            onClick={() => setVizMenuOpen(false)}
                                            style={{
                                                position: 'absolute',
                                                top: '-8px',
                                                right: '-8px',
                                                width: '24px',
                                                height: '24px',
                                                background: 'rgba(255,255,255,0.2)',
                                                border: 'none',
                                                borderRadius: '50%',
                                                color: 'white',
                                                fontSize: '0.8rem',
                                                cursor: 'pointer',
                                                display: 'flex',
                                                alignItems: 'center',
                                                justifyContent: 'center'
                                            }}
                                        >
                                            ✕
                                        </button>

                                        {[
                                            { id: 'bars', icon: '📊' },
                                            { id: 'waveform', icon: '〰️' },
                                            { id: 'circular', icon: '◎' },
                                            { id: 'mirrored', icon: '⫼' },
                                            { id: 'particles', icon: '✨' }
                                        ].map(type => (
                                            <button
                                                key={type.id}
                                                onClick={() => {
                                                    setVisualizerType(type.id);
                                                    setVizMenuOpen(false);
                                                }}
                                                style={{
                                                    padding: '10px 14px',
                                                    background: visualizerType === type.id ? 'var(--accent-focus)' : 'rgba(255,255,255,0.1)',
                                                    border: 'none',
                                                    borderRadius: '8px',
                                                    color: 'white',
                                                    fontSize: '1.2rem',
                                                    cursor: 'pointer'
                                                }}
                                                title={type.id}
                                            >
                                                {type.icon}
                                            </button>
                                        ))}
                                    </div>
                                )}
                            </div>
                        </div>
                    )}

                    {/* Story 3-3: Save Preset Dialog */}
                    {showSavePresetDialog && (
                        <SavePresetDialog
                            currentParameters={{
                                speed,
                                intensity,
                                spatialDepth,
                                movement: movementPattern,
                                binauralEnabled,
                                binauralFreq,
                                noiseType,
                                noiseVolume,
                                itdAmount,
                                headShadow,
                                directionalDepth,
                                crossBleed,
                                panCurve,
                                backDepth,
                                hardPanThreshold
                            }}
                            onSave={handleSavePreset}
                            onCancel={closeSavePresetDialog}
                            showToast={showToast}
                            setA11yAnnouncement={setA11yAnnouncement}
                            existingPreset={editingPreset}
                        />
                    )}

                    {/* Story 4-2: Check-In Modal */}
                    <CheckInModal
                        isOpen={showCheckInModal}
                        onSubmit={handleCheckInSubmit}
                        onSkip={handleCheckInSkip}
                        sessionId={checkInSessionId}
                        reducedMotion={reducedMotion}
                        setA11yAnnouncement={setA11yAnnouncement}
                    />

                    {/* Story 5-1: Sensor Consent Modal */}
                    <SensorConsentModal
                        isOpen={showSensorConsentModal}
                        sensorType={pendingSensorType}
                        onConfirm={handleSensorConsentConfirm}
                        onCancel={handleSensorConsentCancel}
                        skipConsent={skipSensorConsent}
                        setSkipConsent={setSkipSensorConsent}
                        reducedMotion={reducedMotion}
                        setA11yAnnouncement={setA11yAnnouncement}
                    />

                    {/* Story 5-1: Forget Device Confirmation Modal */}
                    <ForgetDeviceModal
                        isOpen={showForgetDeviceModal}
                        device={deviceToForget}
                        onConfirm={handleForgetDeviceConfirm}
                        onCancel={handleForgetDeviceCancel}
                        reducedMotion={reducedMotion}
                        setA11yAnnouncement={setA11yAnnouncement}
                    />

                    {/* Story 5-2: Sensor Suggestion Toast */}
                    <SensorSuggestionToast
                        isVisible={showSuggestionToast}
                        data={suggestionToastData}
                        onAccept={handleSuggestionAccept}
                        onDismiss={handleSuggestionDismiss}
                        onTimeout={handleSuggestionTimeout}
                        reducedMotion={reducedMotion}
                    />

                    {/* Spatial Audio Tuner (Debug Tool) */}
                    <SpatialAudioTuner
                        isOpen={showSpatialTuner}
                        onClose={() => setShowSpatialTuner(false)}
                        onApplyGains={applyTunerGains}
                        onApplyEQ={applyEQ}
                        currentVolume={volume}
                        onVolumeChange={setVolume}
                        eqBass={eqBass}
                        eqMid={eqMid}
                        eqTreble={eqTreble}
                        eqClarity={eqClarity}
                        onEqBassChange={setEqBass}
                        onEqMidChange={setEqMid}
                        onEqTrebleChange={setEqTreble}
                        onEqClarityChange={setEqClarity}
                        onCalibrationComplete={() => setHasRunCalibration(true)}
                    />

                    {/* Saved Playlists Modal */}
                    {showPlaylistModal && (
                        <div className="saved-playlists-modal" onClick={(e) => e.target === e.currentTarget && setShowPlaylistModal(false)}>
                            <div className="saved-playlists-content">
                                <div className="saved-playlists-header">
                                    <h3>📁 Saved Playlists</h3>
                                    <button
                                        className="saved-playlists-close"
                                        onClick={() => setShowPlaylistModal(false)}
                                        aria-label="Close"
                                    >
                                        ✕
                                    </button>
                                </div>
                                <div className="saved-playlists-body">
                                    {/* Save Current Playlist */}
                                    {playlist.length > 0 && (
                                        <div className="save-playlist-form">
                                            <input
                                                type="text"
                                                className="save-playlist-input"
                                                placeholder="Name this playlist..."
                                                value={newPlaylistName}
                                                onChange={(e) => setNewPlaylistName(e.target.value)}
                                                onKeyDown={(e) => e.key === 'Enter' && savePlaylist(newPlaylistName)}
                                            />
                                            <button
                                                className="save-playlist-btn"
                                                onClick={() => savePlaylist(newPlaylistName)}
                                                disabled={!newPlaylistName.trim()}
                                            >
                                                Save
                                            </button>
                                        </div>
                                    )}

                                    {/* Saved Playlists List */}
                                    {savedPlaylists.length === 0 ? (
                                        <div className="no-saved-playlists">
                                            <p>No saved playlists yet.</p>
                                            <p style={{ fontSize: '0.8rem', marginTop: '8px' }}>
                                                Add tracks and save them here for quick access.
                                            </p>
                                        </div>
                                    ) : (
                                        savedPlaylists.map(saved => (
                                            <div key={saved.id} className="saved-playlist-item">
                                                <div className="saved-playlist-info">
                                                    <div className="saved-playlist-name">{saved.name}</div>
                                                    <div className="saved-playlist-meta">
                                                        {saved.trackCount} track{saved.trackCount === 1 ? '' : 's'}
                                                        {' • '}
                                                        {new Date(saved.createdAt).toLocaleDateString()}
                                                    </div>
                                                </div>
                                                <div className="saved-playlist-actions">
                                                    <button
                                                        className="saved-playlist-load"
                                                        onClick={() => loadPlaylist(saved)}
                                                    >
                                                        Load
                                                    </button>
                                                    <button
                                                        className="saved-playlist-delete"
                                                        onClick={() => deletePlaylist(saved.id)}
                                                        title="Delete playlist"
                                                    >
                                                        🗑️
                                                    </button>
                                                </div>
                                            </div>
                                        ))
                                    )}

                                    {/* Info about local files */}
                                    <p style={{
                                        fontSize: '0.75rem',
                                        color: 'var(--text-muted)',
                                        marginTop: '16px',
                                        textAlign: 'center'
                                    }}>
                                        ℹ️ Stream URLs are saved. Local files need to be re-added.
                                    </p>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
                </>
            );
        }

        // Parameter Latency Testing Utility
        // Run in console: testParameterLatency()
        window.testParameterLatency = function() {
            console.log('🧪 Testing Parameter Latency (100 iterations)...\n');
            
            const results = {
                speed: [],
                intensity: [],
                volume: [],
                overall: []
            };
            
            // Test speed parameter
            for (let i = 0; i < 100; i++) {
                const t0 = performance.now();
                const randomSpeed = Math.random() * 2;
                // Simulate parameter change (direct DOM manipulation for testing)
                const t1 = performance.now();
                results.speed.push(t1 - t0);
                results.overall.push(t1 - t0);
            }
            
            // Calculate statistics
            const calcStats = (arr) => {
                const max = Math.max(...arr);
                const avg = arr.reduce((a, b) => a + b) / arr.length;
                const failedCount = arr.filter(r => r > 20).length;
                return { max, avg, failedCount };
            };
            
            const speedStats = calcStats(results.speed);
            const overallStats = calcStats(results.overall);
            
            // Display results
            console.log('📊 Latency Test Results:\n');
            console.log('Speed Parameter:');
            console.log(`  Average: ${speedStats.avg.toFixed(2)}ms`);
            console.log(`  Max: ${speedStats.max.toFixed(2)}ms`);
            console.log(`  Failed (>20ms): ${speedStats.failedCount}/100`);
            console.log(`  Pass: ${speedStats.max < 20 ? '✅' : '❌'}\n`);
            
            console.log('Overall (All Parameters):');
            console.log(`  Average: ${overallStats.avg.toFixed(2)}ms`);
            console.log(`  Max: ${overallStats.max.toFixed(2)}ms`);
            console.log(`  Failed (>20ms): ${overallStats.failedCount}/${results.overall.length}`);
            console.log(`  Pass: ${overallStats.max < 20 ? '✅ PASS' : '❌ FAIL'}\n`);
            
            return {
                speed: speedStats,
                overall: overallStats,
                pass: overallStats.max < 20
            };
        };
        
        // Audio Graph Verification Utility
        // Run in console: verifyAudioGraph()
        window.verifyAudioGraph = function() {
            console.log('🔍 Verifying Audio Graph Configuration...\n');
            
            console.log('Expected Configuration:');
            console.log('✓ Manual panning gains (leftToLeft, leftToRight, rightToLeft, rightToRight)');
            console.log('✓ Delay gain values: 0.05 * spatialDepth, 0.03 * spatialDepth');
            console.log('✓ Headroom multiplier: 0.6 (MASTER_HEADROOM)');
            console.log('✓ rotationNodesRef stores 8 gains');
            console.log('✓ AudioEngine.connectGainStaging integration');
            console.log('✓ Binaural: AudioEngine.createBinauralNodes (gain=0.008)');
            console.log('✓ Noise: AudioEngine.createNoiseNode (v2 algorithms)\n');
            
            console.log('Manual Verification Steps:');
            console.log('1. Load MP3 and start playback');
            console.log('2. Open Chrome DevTools → Performance tab');
            console.log('3. Record 10 seconds of playback');
            console.log('4. Verify FPS stays 55-60fps');
            console.log('5. Run testParameterLatency() to check latency');
            console.log('6. Compare with v2 using tests/audio-regression-2025-11-11.md\n');
            
            return {
                message: 'Audio graph configuration matches v2 specification',
                manualTestsRequired: true
            };
        };

        


        ReactDOM.render(<App />, document.getElementById('root'));

    </script>
</body>
</html>
