<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8D Audio Player - Live Streaming Edition</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="./audio-engine.js"></script>
    <script src="./session-logging.js"></script>
    <style>
        :root {
            --bg-1: #f4f6ff;
            --bg-2: #dfe7ff;
            --card-bg: rgba(255, 255, 255, 0.95);
            --card-border: rgba(15, 27, 68, 0.08);
            --surface: rgba(255, 255, 255, 0.7);
            --text-primary: #0c1440;
            --text-secondary: rgba(12, 20, 64, 0.7);
            --shadow-soft: 0 30px 60px rgba(15, 21, 56, 0.2);
            --accent-focus: #6d8bff;
            --accent-calm: #4edbc6;
            --accent-energize: #ffb562;
            --accent-default: #6d8bff;
            --chip-accent: var(--accent-default);
            --danger: #f05d7b;
            --positive: #3ad8a7;
            --grid-gap: 24px;
        }

        body.dark-mode {
            --bg-1: #05071c;
            --bg-2: #0c122d;
            --card-bg: rgba(7, 10, 30, 0.95);
            --card-border: rgba(255, 255, 255, 0.08);
            --surface: rgba(255, 255, 255, 0.04);
            --text-primary: #f5f7ff;
            --text-secondary: rgba(245, 247, 255, 0.7);
            --shadow-soft: 0 40px 90px rgba(0, 0, 0, 0.65);
        }

        /* High-contrast mode: WCAG AA compliant (â‰¥4.5:1 normal text, â‰¥3:1 large text) */
        body.high-contrast {
            --bg-1: #ffffff;
            --bg-2: #f0f0f0;
            --card-bg: #ffffff;
            --card-border: #000000;
            --surface: #ffffff;
            --text-primary: #000000;
            --text-secondary: #000000;
            --shadow-soft: 0 2px 8px rgba(0, 0, 0, 0.3);
            --accent-focus: #0000ee;
            --accent-calm: #006060;
            --accent-energize: #cc5500;
            --accent-default: #0000ee;
            --danger: #cc0000;
            --positive: #008800;
        }

        /* High-contrast dark mode combination */
        body.dark-mode.high-contrast {
            --bg-1: #000000;
            --bg-2: #1a1a1a;
            --card-bg: #000000;
            --card-border: #ffffff;
            --surface: #000000;
            --text-primary: #ffffff;
            --text-secondary: #ffffff;
            --shadow-soft: 0 2px 8px rgba(255, 255, 255, 0.3);
            --accent-focus: #6699ff;
            --accent-calm: #00ffff;
            --accent-energize: #ffaa00;
            --accent-default: #6699ff;
            --danger: #ff6666;
            --positive: #00ff00;
        }

        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
            min-height: 100vh;
            background-image:
                radial-gradient(circle at 20% 20%, rgba(109, 139, 255, 0.25), transparent 45%),
                radial-gradient(circle at 80% 0%, rgba(255, 175, 123, 0.22), transparent 40%),
                linear-gradient(135deg, var(--bg-1), var(--bg-2));
            color: var(--text-primary);
            transition: background 0.35s ease, color 0.35s ease;
        }

        button, input, select, textarea {
            font: inherit;
        }

        .screen {
            max-width: 1440px;
            margin: 0 auto;
            padding: 32px clamp(16px, 4vw, 64px) 64px;
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .app-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 16px;
        }

        .app-header h1 {
            font-size: clamp(1.85rem, 3vw, 2.8rem);
            margin: 6px 0 8px;
        }

        .eyebrow {
            text-transform: uppercase;
            letter-spacing: 0.2em;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .header-actions {
            display: flex;
            gap: 12px;
        }

        .header-actions button {
            min-height: 48px;
            border-radius: 999px;
            padding: 0 20px;
            border: 1px solid var(--card-border);
            background: var(--surface);
            color: var(--text-primary);
            cursor: pointer;
            transition: transform 0.2s ease, border 0.2s ease;
        }

        .header-actions button:focus-visible {
            outline: 3px solid rgba(109, 139, 255, 0.7);
            outline-offset: 2px;
        }

        .primary-btn {
            background: linear-gradient(120deg, var(--accent-focus), #9f9bff);
            color: #fff;
            border: none;
            box-shadow: 0 20px 40px rgba(109, 139, 255, 0.35);
        }

        .ghost-btn {
            background: transparent;
            border: 1px dashed var(--card-border);
            color: var(--text-primary);
        }

        /* Design spec Â§3: Three-column grid layout for desktop â‰¥1280px (Ritual/Preset | Playback | Insights) */
        .main-grid {
            display: grid;
            grid-template-columns: minmax(280px, 360px) minmax(420px, 1fr) minmax(260px, 320px);
            gap: var(--grid-gap);
        }

        .column-card {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .panel {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 24px;
            padding: 24px;
            box-shadow: var(--shadow-soft);
        }

        /* Design spec Â§3: Mode tabs (Focus/Calm/Energize) with roving tabindex */
        .mode-tabs {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .mode-chip {
            flex: 1 1 140px;
            min-height: 56px;
            border-radius: 18px;
            border: 1px solid var(--card-border);
            padding: 12px 16px;
            background: var(--surface);
            color: var(--text-primary);
            cursor: pointer;
            text-align: left;
            transition: transform 0.2s ease, border 0.2s ease, box-shadow 0.2s ease;
        }

        .mode-chip[data-selected="true"] {
            border-color: var(--chip-accent);
            box-shadow: 0 10px 30px rgba(109, 139, 255, 0.25);
            background: linear-gradient(135deg, var(--chip-accent), rgba(255,255,255,0.1));
            color: #fff;
        }

        .mode-chip span {
            display: block;
            font-size: 1rem;
            font-weight: 600;
        }

        .mode-chip small {
            font-size: 0.78rem;
            opacity: 0.85;
        }

        /* Story 3-2: Advanced Controls Drawer */
        .advanced-controls {
            background: var(--surface-1);
            border: 2px solid var(--border-subtle);
            border-radius: 12px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .advanced-controls summary {
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            list-style: none;
            user-select: none;
        }

        .advanced-controls summary::-webkit-details-marker {
            display: none;
        }

        .advanced-controls summary::after {
            content: 'â–¼';
            transition: transform 0.2s ease;
            font-size: 0.85rem;
            opacity: 0.6;
        }

        .advanced-controls[open] summary::after {
            transform: rotate(180deg);
        }

        .advanced-controls summary:hover {
            background: var(--surface-2);
            border-radius: 8px;
        }

        .advanced-controls kbd {
            font-size: 0.75rem;
            background: var(--surface-2);
            padding: 0.125rem 0.375rem;
            border-radius: 4px;
            border: 1px solid var(--border-subtle);
            font-family: monospace;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
            margin-top: 1rem;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .checkbox-group {
            flex-direction: row;
            align-items: center;
            gap: 0.5rem;
        }

        .checkbox-group input[type="checkbox"] {
            width: 24px;
            height: 24px;
            cursor: pointer;
        }

        .control-label {
            font-weight: 500;
            color: var(--text-1);
            font-size: 0.95rem;
        }

        .control-input {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .control-input input[type="range"] {
            flex: 1;
            height: 8px;
            border-radius: 4px;
            appearance: none;
            background: var(--surface-3);
            outline: none;
        }

        .control-input input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-focus);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.1s ease;
        }

        .control-input input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .control-input input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-focus);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.1s ease;
        }

        .control-input input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.1);
        }

        .control-input input[type="range"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .control-input input[type="range"]:disabled::-webkit-slider-thumb {
            cursor: not-allowed;
        }

        .control-input input[type="range"]:disabled::-moz-range-thumb {
            cursor: not-allowed;
        }

        .control-input select {
            flex: 1;
            padding: 0.5rem;
            border-radius: 6px;
            background: var(--surface-2);
            border: 2px solid var(--border-subtle);
            color: var(--text-1);
            font-size: 0.9rem;
            cursor: pointer;
        }

        .control-input select:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .control-input output {
            font-variant-numeric: tabular-nums;
            min-width: 3.5rem;
            text-align: right;
            font-weight: 600;
            color: var(--text-2);
            font-size: 0.9rem;
        }

        .freq-band {
            font-size: 0.8rem;
            color: var(--text-3);
            font-weight: 400;
            margin-left: 0.25rem;
        }

        .control-hint {
            font-size: 0.85rem;
            color: var(--text-3);
            font-style: italic;
            line-height: 1.3;
        }

        .sensor-lock-notice {
            background: var(--warning-bg, #fff3cd);
            border: 2px solid var(--warning-border, #ffc107);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .lock-icon {
            font-size: 1.5rem;
        }

        .lock-message {
            flex: 1;
            font-weight: 500;
            color: var(--warning-text, #664d03);
        }

        .unlock-btn {
            padding: 0.5rem 1rem;
            border-radius: 6px;
            background: var(--surface-1);
            border: 2px solid var(--border);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-1);
        }

        .unlock-btn:hover {
            background: var(--accent-focus);
            color: white;
            border-color: var(--accent-focus);
            transform: translateY(-1px);
        }

        .unlock-btn:active {
            transform: translateY(0);
        }

        .hero-card {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .hero-card h2 {
            margin: 0;
            font-size: 1.6rem;
        }

        .hero-message {
            min-height: 48px;
            border-radius: 16px;
            padding: 12px 16px;
            background: var(--surface);
            color: var(--text-primary);
            display: flex;
            align-items: center;
        }

        .hero-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        .hero-actions button {
            flex: 1;
            min-width: 140px;
            min-height: 54px;
        }

        .hero-countdown {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .hero-animation {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            border: 3px solid rgba(109, 139, 255, 0.3);
            position: relative;
        }

        .hero-animation::after {
            content: '';
            position: absolute;
            inset: 8px;
            border-radius: 50%;
            border: 3px solid rgba(109, 139, 255, 0.8);
            animation: breathe424 6s ease-in-out infinite;
        }

        /* 4-2-4 breathing animation: 2s inhale, 1s hold, 2s exhale, 1s hold = 6s cycle */
        @keyframes breathe424 {
            0% {
                transform: scale(0.85);
                opacity: 0.6;
            }
            /* Inhale: 0-33.33% (2s of 6s) */
            33.33% {
                transform: scale(1.15);
                opacity: 1;
            }
            /* Hold inhale: 33.33-50% (1s of 6s) */
            50% {
                transform: scale(1.15);
                opacity: 1;
            }
            /* Exhale: 50-83.33% (2s of 6s) */
            83.33% {
                transform: scale(0.85);
                opacity: 0.6;
            }
            /* Hold exhale: 83.33-100% (1s of 6s) */
            100% {
                transform: scale(0.85);
                opacity: 0.6;
            }
        }

        .hero-countdown__value {
            font-size: 2rem;
            font-weight: 600;
        }

        .preset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
        }

        .preset-card {
            border-radius: 16px;
            border: 1px solid var(--card-border);
            padding: 14px;
            background: var(--surface);
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .hero-support {
            color: var(--text-secondary);
            margin: 0;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 16px;
        }

        .value-display {
            text-align: right;
            font-weight: 600;
            color: var(--accent-focus);
            margin-top: 8px;
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .now-playing-card canvas {
            width: 100%;
            height: 120px;
            border-radius: 16px;
            border: 1px solid var(--card-border);
            background: #050915;
        }

        .status-pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 999px;
            font-size: 0.8rem;
            border: 1px solid var(--card-border);
        }

        .transport-controls {
            display: flex;
            gap: 12px;
            justify-content: space-between;
            align-items: center;
        }

        .transport-button {
            min-width: 64px;
            min-height: 64px;
            border-radius: 20px;
            border: none;
            background: var(--surface);
            color: var(--text-primary);
            font-size: 1.4rem;
            cursor: pointer;
        }

        .transport-button.play {
            flex: 1;
            background: linear-gradient(135deg, var(--accent-focus), #9f9bff);
            color: #fff;
            font-size: 1.6rem;
            box-shadow: 0 20px 40px rgba(109, 139, 255, 0.35);
        }

        .timeline {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .timeline input[type="range"] {
            width: 100%;
            accent-color: var(--accent-focus);
        }

        .timeline-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .intake-tabs {
            display: inline-flex;
            border-radius: 999px;
            border: 1px solid var(--card-border);
            overflow: hidden;
        }

        .intake-tab {
            border: none;
            background: transparent;
            padding: 12px 20px;
            min-height: 48px;
            cursor: pointer;
            color: var(--text-primary);
        }

        .intake-tab[aria-selected="true"] {
            background: linear-gradient(135deg, rgba(109, 139, 255, 0.18), rgba(109, 139, 255, 0));
            color: var(--text-primary);
        }

        .drop-zone {
            margin-top: 16px;
            border: 2px dashed rgba(109, 139, 255, 0.45);
            border-radius: 20px;
            padding: 28px 20px;
            text-align: center;
            background: var(--surface);
            min-height: 160px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            justify-content: center;
            cursor: pointer;
            transition: border 0.2s ease, box-shadow 0.2s ease;
        }

        .drop-zone--attention {
            border-color: var(--danger);
            box-shadow: 0 0 0 3px rgba(240, 93, 123, 0.2);
        }

        .drop-zone--hover {
            border-color: var(--accent-focus);
            box-shadow: 0 0 0 3px rgba(109, 139, 255, 0.25);
        }

        .playlist-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .playlist-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .playlist-button {
            width: 100%;
            border-radius: 18px;
            border: 1px solid var(--card-border);
            padding: 14px 18px;
            background: var(--surface);
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            gap: 12px;
            text-align: left;
            cursor: pointer;
            min-height: 64px;
        }

        .playlist-button[aria-current="true"] {
            border-color: var(--accent-focus);
            box-shadow: 0 0 0 2px rgba(109, 139, 255, 0.25);
        }

        .playlist-meta {
            display: flex;
            gap: 8px;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .badge {
            border-radius: 999px;
            padding: 3px 10px;
            font-size: 0.75rem;
            border: 1px solid var(--card-border);
        }

        .remove-btn {
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 1.2rem;
            min-width: 48px;
            min-height: 48px;
            border-radius: 12px;
            display: grid;
            place-items: center;
        }

        .advanced-controls .control-group {
            background: var(--surface);
            border-radius: 16px;
            padding: 18px;
        }

        .advanced-controls label {
            font-weight: 600;
            font-size: 0.95rem;
        }

        .advanced-controls input[type="range"],
        .advanced-controls select {
            width: 100%;
            margin-top: 8px;
        }

        .pill {
            border-radius: 12px;
            padding: 4px 10px;
            font-size: 0.8rem;
        }

        .insights-grid {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .insight-card,
        .sensor-card {
            border-radius: 20px;
            border: 1px solid var(--card-border);
            background: var(--card-bg);
            padding: 20px;
        }

        .insight-value {
            font-size: 2rem;
            font-weight: 600;
        }

        .sensor-card strong {
            display: block;
            margin-bottom: 8px;
        }

        .session-log-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 12px;
        }

        .session-log-actions button {
            border-radius: 999px;
            border: 1px solid var(--card-border);
            background: var(--surface);
            padding: 10px 16px;
            font-weight: 600;
            color: var(--text-primary);
            cursor: pointer;
            transition: opacity 0.2s ease;
        }

        .session-log-actions button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .alert-inline {
            border-radius: 16px;
            padding: 12px 16px;
            background: rgba(240, 93, 123, 0.12);
            color: var(--danger);
            border: 1px solid rgba(240, 93, 123, 0.35);
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        button:focus-visible,
        .mode-chip:focus-visible,
        .intake-tab:focus-visible,
        .playlist-button:focus-visible {
            outline: 3px solid rgba(109, 139, 255, 0.7);
            outline-offset: 2px;
        }

        /* Design spec Â§3: Responsive grid breakpoints */
        /* Three-column layout â‰¥1280px (default above) */
        /* Two-column layout 768-1279px */
        @media (min-width: 768px) and (max-width: 1279px) {
            .main-grid {
                grid-template-columns: repeat(2, minmax(280px, 1fr));
            }
            .insights-column {
                grid-column: 1 / -1;
            }
        }

        /* Single-column layout â‰¤767px (mobile) */
        @media (max-width: 767px) {
            .app-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .main-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .hero-actions button {
                flex: 1 1 100%;
            }

            .mode-tabs {
                position: sticky;
                top: 0;
                padding: 12px 0;
                background: linear-gradient(180deg, var(--bg-1), rgba(255, 255, 255, 0));
                z-index: 5;
            }

            /* Story 3-2: Mobile responsive */
            .controls-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .advanced-controls summary {
                font-size: 1rem;
            }

            .control-input {
                flex-direction: column;
                align-items: stretch;
            }

            .control-input output {
                text-align: left;
            }

            .sensor-lock-notice {
                flex-direction: column;
                text-align: center;
            }

            .unlock-btn {
                width: 100%;
            }
        }

        @keyframes breathe {
            0% { transform: scale(0.8); opacity: 0.6; }
            50% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0.6; }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .toast {
            pointer-events: none;
        }

        /* Story 3-3: Dialog Overlay Styles */
        .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.2s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .dialog-content {
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        const MODE_LIBRARY = [
            {
                id: 'focus',
                label: 'Focus',
                short: 'Deep work',
                description: 'Steady orbit + beta beats keep intrusive thoughts at bay.',
                heroCopy: 'Steady pulses to clear the mental slate in two breaths.',
                accent: 'var(--accent-focus)',
                preset: {
                    speed: 0.55,
                    intensity: 0.85,
                    spatialDepth: 0.45,
                    movement: 'circle',
                    binaural: { enabled: true, freq: 14 },
                    noise: { type: 'pink', volume: 0.08 }
                },
                highlights: ['Beta 14â€¯Hz pulses', 'Low drift orbit', 'Pink noise cushion']
            },
            {
                id: 'calm',
                label: 'Calm',
                short: 'Breathing companion',
                description: 'Longer arcs, theta beats, and softer noise for co-regulation.',
                heroCopy: 'Elongated orbit with theta support for family wind-downs.',
                accent: 'var(--accent-calm)',
                preset: {
                    speed: 0.35,
                    intensity: 0.6,
                    spatialDepth: 0.6,
                    movement: 'figure8',
                    binaural: { enabled: true, freq: 8 },
                    noise: { type: 'white', volume: 0.05 }
                },
                highlights: ['Theta 8â€¯Hz support', 'Figure-eight drift', 'Gentle white noise']
            },
            {
                id: 'energize',
                label: 'Energize',
                short: 'Quick reset',
                description: 'Fast arcs + brighter stereo swing for playful bursts.',
                heroCopy: 'Hyper-clear panning for a quick dopamine reset.',
                accent: 'var(--accent-energize)',
                preset: {
                    speed: 0.95,
                    intensity: 0.9,
                    spatialDepth: 0.7,
                    movement: 'random',
                    binaural: { enabled: true, freq: 30 },
                    noise: { type: 'pink', volume: 0.12 }
                },
                highlights: ['Gamma 30â€¯Hz spark', 'Randomized orbit', 'Louder pink noise']
            }
        ];

        const HERO_BREATH_DURATION = 20;

        // Story 3-3: Custom Preset Storage Keys
        const CUSTOM_PRESETS_KEY = 'mpe_8d_custom_presets';

        // Supported MIME types for file intake validation
        const SUPPORTED_MIME_TYPES = [
            'audio/mpeg',      // .mp3
            'audio/wav',       // .wav
            'audio/wave',      // .wav (alternate)
            'audio/ogg',       // .ogg
            'audio/x-wav'      // .wav (legacy)
        ];

        // Story 3-2: Parameter range constants
        const PARAM_RANGES = {
            speed: { min: 0, max: 1, step: 0.05 },
            intensity: { min: 0, max: 1, step: 0.05 },
            spatialDepth: { min: 0, max: 1, step: 0.05 },
            binauralFreq: { min: 0, max: 40, step: 1 },
            noiseVolume: { min: 0, max: 0.3, step: 0.01 }
        };

        // Helper: Get binaural frequency band name
        const getBinauralBand = (freq) => {
            if (freq < 4) return 'Delta';
            if (freq < 8) return 'Theta';
            if (freq < 14) return 'Alpha';
            if (freq < 30) return 'Beta';
            return 'Gamma';
        };

        // Helper: Get binaural frequency hint
        const getBinauralHint = (freq) => {
            if (freq < 4) return 'Deep sleep, healing';
            if (freq < 8) return 'Deep relaxation, meditation';
            if (freq < 14) return 'Calm focus, learning';
            if (freq < 30) return 'Active focus, problem-solving';
            return 'Peak alertness, high energy';
        };

        // ============================================================
        // Story 3-3: Custom Preset CRUD Storage Helpers
        // ============================================================
        
        const loadCustomPresets = () => {
            try {
                const saved = localStorage.getItem(CUSTOM_PRESETS_KEY);
                return saved ? JSON.parse(saved) : {};
            } catch (err) {
                console.error('[PresetStorage] Failed to load custom presets:', err);
                return {};
            }
        };

        const saveCustomPreset = (presetData, showToastFn) => {
            try {
                const customPresets = loadCustomPresets();
                const id = `custom-preset-${Date.now()}`;
                
                customPresets[id] = {
                    id,
                    name: presetData.name,
                    description: presetData.description || '',
                    createdAt: Date.now(),
                    lastUsedAt: Date.now(),
                    preset: {
                        speed: presetData.speed,
                        intensity: presetData.intensity,
                        spatialDepth: presetData.spatialDepth,
                        movement: presetData.movement,
                        binaural: { 
                            enabled: presetData.binauralEnabled, 
                            freq: presetData.binauralFreq 
                        },
                        noise: { 
                            type: presetData.noiseType, 
                            volume: presetData.noiseVolume 
                        }
                    },
                    color: presetData.color || '#6366f1',
                    tags: presetData.tags || []
                };
                
                localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(customPresets));
                
                // Add to preset order
                const order = getPresetOrder();
                order.push(id);
                savePresetOrder(order);
                
                console.log(`[PresetStorage] Saved custom preset: ${id} - ${presetData.name}`);
                return id;
            } catch (err) {
                if (err.name === 'QuotaExceededError') {
                    if (showToastFn) showToastFn('Storage full. Please delete old presets.', 'error');
                } else {
                    console.error('[PresetStorage] Failed to save preset:', err);
                    if (showToastFn) showToastFn('Error saving preset.', 'error');
                }
                return null;
            }
        };

        const updateCustomPreset = (id, updates, showToastFn) => {
            try {
                const customPresets = loadCustomPresets();
                if (customPresets[id]) {
                    customPresets[id] = { 
                        ...customPresets[id], 
                        ...updates,
                        lastUsedAt: Date.now()
                    };
                    localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(customPresets));
                    console.log(`[PresetStorage] Updated custom preset: ${id}`);
                    return true;
                }
                console.warn(`[PresetStorage] Preset not found: ${id}`);
                return false;
            } catch (err) {
                console.error('[PresetStorage] Failed to update preset:', err);
                if (showToastFn) showToastFn('Error updating preset.', 'error');
                return false;
            }
        };

        const deleteCustomPreset = (id, showToastFn) => {
            try {
                const customPresets = loadCustomPresets();
                const presetName = customPresets[id]?.name || id;
                
                delete customPresets[id];
                localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(customPresets));
                
                // Remove from order
                const order = getPresetOrder().filter(pid => pid !== id);
                savePresetOrder(order);
                
                console.log(`[PresetStorage] Deleted custom preset: ${id}`);
                
                // Return the deleted preset ID and name for caller to handle track updates
                return { id, name: presetName };
            } catch (err) {
                console.error('[PresetStorage] Failed to delete preset:', err);
                if (showToastFn) showToastFn('Error deleting preset.', 'error');
                return null;
            }
        };

        const getAllPresets = () => {
            const defaults = MODE_LIBRARY.map(mode => ({
                id: mode.id,
                name: mode.label,
                description: mode.description,
                preset: mode.preset,
                color: mode.accent,
                isDefault: true,
                createdAt: 0,
                lastUsedAt: 0
            }));
            
            const custom = Object.values(loadCustomPresets()).map(p => ({
                ...p,
                isDefault: false
            }));
            
            // Apply user-defined order
            const order = getPresetOrder();
            const allPresets = [...defaults, ...custom];
            const ordered = order
                .map(id => allPresets.find(p => p.id === id))
                .filter(Boolean);
            
            // Add any new presets not in order (defensive)
            const orderedIds = new Set(ordered.map(p => p.id));
            const missing = allPresets.filter(p => !orderedIds.has(p.id));
            
            return [...ordered, ...missing];
        };

        const getPresetOrder = () => {
            try {
                const saved = localStorage.getItem('mpe_8d_preset_order');
                if (saved) return JSON.parse(saved);
            } catch (err) {
                console.error('[PresetStorage] Failed to load preset order:', err);
            }
            
            // Default order: defaults first, then custom by creation date
            const defaults = MODE_LIBRARY.map(m => m.id);
            const custom = Object.keys(loadCustomPresets()).sort();
            return [...defaults, ...custom];
        };

        const savePresetOrder = (order) => {
            try {
                localStorage.setItem('mpe_8d_preset_order', JSON.stringify(order));
            } catch (err) {
                console.error('[PresetStorage] Failed to save preset order:', err);
            }
        };

        // Helper to format "last used" timestamp
        const formatLastUsed = (timestamp) => {
            if (!timestamp || timestamp === 0) return 'Never used';
            
            const now = Date.now();
            const diff = now - timestamp;
            const seconds = Math.floor(diff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            
            if (seconds < 60) return 'Just now';
            if (minutes < 60) return `${minutes} minute${minutes === 1 ? '' : 's'} ago`;
            if (hours < 24) return `${hours} hour${hours === 1 ? '' : 's'} ago`;
            if (days < 7) return `${days} day${days === 1 ? '' : 's'} ago`;
            
            const date = new Date(timestamp);
            return date.toLocaleDateString();
        };

        // Spatial Audio Tuner - Visual debugging tool for dialing in 3D audio effect
        const SpatialAudioTuner = ({
            isOpen,
            onClose,
            onApplyGains, // Function to apply gains to audio engine: (leftGain, rightGain, crossGain) => void
            currentVolume = 0.7,
            onVolumeChange
        }) => {
            const [orbPosition, setOrbPosition] = React.useState({ x: 0, y: -80 }); // Start at "front"
            const [isDragging, setIsDragging] = React.useState(false);
            const containerRef = React.useRef(null);

            // Advanced tuning settings
            const [crossBleed, setCrossBleed] = React.useState(0); // 0-0.3: how much bleeds to opposite ear
            const [backDepth, setBackDepth] = React.useState(0.55); // 0.3-1.0: volume when behind
            const [panCurve, setPanCurve] = React.useState(2.0); // 1-4: how aggressively pan separates L/R
            const [hardPanThreshold, setHardPanThreshold] = React.useState(0.1); // 0-0.5: center dead zone
            const [itdAmount, setItdAmount] = React.useState(0.7); // 0-1.5: ITD multiplier (0.7ms max is realistic)
            const [directionalDepth, setDirectionalDepth] = React.useState(0.15); // 0-0.3: extra attenuation for ear facing away
            const [headShadow, setHeadShadow] = React.useState(0.5); // 0-1: how much high-freq is cut when behind/opposite

            // Calibration wizard state
            const [showCalibration, setShowCalibration] = React.useState(false);
            const [calibrationStep, setCalibrationStep] = React.useState(0);
            const [calibrationResults, setCalibrationResults] = React.useState({
                canHearLeftRight: null,      // Can perceive L/R panning
                leftRightIntensity: 2.0,     // How much pan curve they need
                canHearFrontBack: null,      // Can perceive front/back via muffling
                frontBackIntensity: 0.5,     // Head shadow amount
                canHearTiming: null,         // Can perceive ITD
                timingIntensity: 0.7,        // ITD amount
                preferredVolume: 0.5         // Their optimal volume
            });

            // Calculate audio parameters from orb position
            const radius = 80; // Head radius
            const orbRadius = Math.sqrt(orbPosition.x ** 2 + orbPosition.y ** 2);
            const angle = Math.atan2(orbPosition.x, -orbPosition.y) * (180 / Math.PI); // 0=front, 90=right, 180=back, -90=left
            const normalizedAngle = ((angle + 360) % 360); // 0-360

            // Calculate pan position (-1 to 1) based on X position
            const panPosition = Math.max(-1, Math.min(1, orbPosition.x / radius));

            // Calculate if behind (y > 0 means behind the head in our coordinate system)
            const isBehind = orbPosition.y > 0;
            const behindAmount = isBehind ? Math.min(1, orbPosition.y / radius) : 0; // 0-1 how far behind

            // Base depth multiplier for being behind
            const baseDepthMultiplier = isBehind ? backDepth : 1.0;

            // Directional depth: the ear CLOSER to the source gets extra attenuation when sound is behind
            // This simulates the pinna (outer ear) blocking sounds from behind
            // At back-left (pan=-0.76), left ear should be slightly quieter because sound is behind it
            let leftDirectionalAtten = 1.0;
            let rightDirectionalAtten = 1.0;

            if (isBehind) {
                // When behind, attenuate the ear that's on the same side as the sound
                // because that ear is "facing away" from the sound source
                if (panPosition < 0) {
                    // Sound is back-left: left ear faces away, gets extra attenuation
                    leftDirectionalAtten = 1.0 - (directionalDepth * Math.abs(panPosition) * behindAmount);
                } else if (panPosition > 0) {
                    // Sound is back-right: right ear faces away, gets extra attenuation
                    rightDirectionalAtten = 1.0 - (directionalDepth * Math.abs(panPosition) * behindAmount);
                }
            }

            // Calculate gain values (what the audio engine should use)
            const leftGain = Math.max(0, (1 - panPosition) * 0.5 * baseDepthMultiplier * leftDirectionalAtten);
            const rightGain = Math.max(0, (1 + panPosition) * 0.5 * baseDepthMultiplier * rightDirectionalAtten);

            // Hard pan calculation with adjustable curve and threshold
            let hardLeftGain, hardRightGain, actualCrossBleed;
            if (panPosition > hardPanThreshold) {
                // Sound is on the right
                const rightAmount = Math.min(1, (panPosition - hardPanThreshold) / (1 - hardPanThreshold));
                const curved = Math.pow(rightAmount, 1 / panCurve); // Apply pan curve
                hardLeftGain = Math.max(0, 1 - curved);
                hardRightGain = 1;
                actualCrossBleed = crossBleed * (1 - curved);
            } else if (panPosition < -hardPanThreshold) {
                // Sound is on the left
                const leftAmount = Math.min(1, (-panPosition - hardPanThreshold) / (1 - hardPanThreshold));
                const curved = Math.pow(leftAmount, 1 / panCurve);
                hardLeftGain = 1;
                hardRightGain = Math.max(0, 1 - curved);
                actualCrossBleed = crossBleed * (1 - curved);
            } else {
                // Center zone
                hardLeftGain = 0.5;
                hardRightGain = 0.5;
                actualCrossBleed = crossBleed;
            }
            // Apply depth and directional attenuation
            hardLeftGain *= baseDepthMultiplier * leftDirectionalAtten;
            hardRightGain *= baseDepthMultiplier * rightDirectionalAtten;

            // Calculate ITD (Inter-aural Time Difference)
            // Sound reaches closer ear first. Max ITD ~0.7ms when sound is directly to one side
            // Negative pan = sound on left = delay right ear
            // Positive pan = sound on right = delay left ear
            const maxItdMs = 0.7 * itdAmount; // ms
            const itdLeftDelay = panPosition > 0 ? Math.abs(panPosition) * maxItdMs / 1000 : 0; // seconds
            const itdRightDelay = panPosition < 0 ? Math.abs(panPosition) * maxItdMs / 1000 : 0; // seconds

            // Calculate low-pass filter frequencies for "head shadow" effect
            // When sound is behind or on opposite side, high frequencies are blocked
            // Full open = 20000Hz, max muffled = 2000Hz
            const minFreq = 2000; // Muffled sound
            const maxFreq = 20000; // Clear sound

            // Left ear filter: darker when sound is on the RIGHT or BEHIND-LEFT
            // Right ear filter: darker when sound is on the LEFT or BEHIND-RIGHT
            let leftFilterFreq = maxFreq;
            let rightFilterFreq = maxFreq;

            if (headShadow > 0) {
                // Head shadow from opposite side (sound on right = left ear darker)
                const leftShadowFromPan = panPosition > 0 ? panPosition : 0; // 0-1 when sound on right
                const rightShadowFromPan = panPosition < 0 ? -panPosition : 0; // 0-1 when sound on left

                // Additional shadow when behind
                const behindShadow = isBehind ? behindAmount * 0.5 : 0;

                const leftShadowAmount = Math.min(1, (leftShadowFromPan + behindShadow) * headShadow);
                const rightShadowAmount = Math.min(1, (rightShadowFromPan + behindShadow) * headShadow);

                // Exponential mapping for more natural rolloff
                leftFilterFreq = maxFreq * Math.pow(minFreq / maxFreq, leftShadowAmount);
                rightFilterFreq = maxFreq * Math.pow(minFreq / maxFreq, rightShadowAmount);
            }

            // Apply gains to audio whenever orb position or settings change
            React.useEffect(() => {
                if (isOpen && onApplyGains) {
                    // Use hard pan values with cross bleed, ITD, and filter frequencies
                    onApplyGains(hardLeftGain, hardRightGain, Math.max(0.001, actualCrossBleed), itdLeftDelay, itdRightDelay, leftFilterFreq, rightFilterFreq);
                }
            }, [orbPosition, isOpen, onApplyGains, hardLeftGain, hardRightGain, actualCrossBleed, itdLeftDelay, itdRightDelay, leftFilterFreq, rightFilterFreq, crossBleed, backDepth, panCurve, hardPanThreshold, itdAmount, directionalDepth, headShadow]);

            const handleMouseDown = (e) => {
                setIsDragging(true);
                updateOrbPosition(e);
            };

            const handleMouseMove = (e) => {
                if (!isDragging) return;
                updateOrbPosition(e);
            };

            const handleMouseUp = () => {
                setIsDragging(false);
            };

            const updateOrbPosition = (e) => {
                if (!containerRef.current) return;
                const rect = containerRef.current.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;

                let x = e.clientX - rect.left - centerX;
                let y = e.clientY - rect.top - centerY;

                // Constrain to circle
                const dist = Math.sqrt(x * x + y * y);
                if (dist > radius) {
                    x = (x / dist) * radius;
                    y = (y / dist) * radius;
                }

                setOrbPosition({ x, y });
            };

            const getPositionLabel = () => {
                if (normalizedAngle >= 315 || normalizedAngle < 45) return 'FRONT';
                if (normalizedAngle >= 45 && normalizedAngle < 135) return 'RIGHT';
                if (normalizedAngle >= 135 && normalizedAngle < 225) return 'BACK';
                return 'LEFT';
            };

            if (!isOpen) return null;

            return (
                <div style={{
                    position: 'fixed',
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    background: 'rgba(0,0,0,0.85)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    zIndex: 10000
                }} onClick={onClose}>
                    <div style={{
                        background: 'var(--bg-2)',
                        borderRadius: '16px',
                        padding: '24px',
                        maxWidth: '500px',
                        width: '90%'
                    }} onClick={e => e.stopPropagation()}>
                        <h3 style={{ margin: '0 0 8px', color: 'var(--accent)' }}>ðŸŽ¯ Spatial Audio Tuner</h3>
                        <p style={{ margin: '0 0 12px', fontSize: '0.875rem', color: 'var(--text-secondary)' }}>
                            Drag the orb around the head to position the sound. Use this to find settings that work for your hearing.
                        </p>

                        {/* Volume Recommendation Panel */}
                        {(() => {
                            const volumePercent = Math.round(currentVolume * 100);
                            const isOptimal = volumePercent >= 40 && volumePercent <= 60;
                            const isTooLoud = volumePercent > 75;
                            const isTooQuiet = volumePercent < 25;
                            const statusColor = isOptimal ? '#4ade80' : (isTooLoud ? '#f87171' : (isTooQuiet ? '#fbbf24' : '#fbbf24'));
                            const statusText = isOptimal ? 'âœ“ Optimal for spatial perception' :
                                              (isTooLoud ? 'âš  Too loud - spatial cues may be drowned out' :
                                              (isTooQuiet ? 'âš  Too quiet - may miss subtle effects' : '~ Adjust for best spatial effect'));

                            return (
                                <div style={{
                                    background: 'rgba(0,0,0,0.4)',
                                    borderRadius: '8px',
                                    padding: '12px',
                                    marginBottom: '16px',
                                    border: `1px solid ${statusColor}40`
                                }}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '8px' }}>
                                        <span style={{ fontSize: '1.2rem' }}>ðŸ”Š</span>
                                        <span style={{ fontWeight: 'bold', color: 'var(--text-primary)', fontSize: '0.875rem' }}>
                                            Volume: {volumePercent}%
                                        </span>
                                        <span style={{
                                            fontSize: '0.75rem',
                                            color: statusColor,
                                            marginLeft: 'auto'
                                        }}>
                                            {statusText}
                                        </span>
                                    </div>

                                    {onVolumeChange && (
                                        <div>
                                            <input
                                                type="range"
                                                min="0"
                                                max="1"
                                                step="0.01"
                                                value={currentVolume}
                                                onChange={(e) => onVolumeChange(parseFloat(e.target.value))}
                                                style={{
                                                    width: '100%',
                                                    accentColor: statusColor,
                                                    height: '8px'
                                                }}
                                            />
                                            <div style={{
                                                display: 'flex',
                                                justifyContent: 'space-between',
                                                fontSize: '0.65rem',
                                                color: 'var(--text-secondary)',
                                                marginTop: '4px'
                                            }}>
                                                <span>Too Quiet</span>
                                                <span style={{ color: '#4ade80' }}>â–² Sweet Spot (40-60%)</span>
                                                <span>Too Loud</span>
                                            </div>
                                        </div>
                                    )}

                                    <div style={{
                                        fontSize: '0.7rem',
                                        color: 'var(--text-secondary)',
                                        marginTop: '8px',
                                        padding: '6px',
                                        background: 'rgba(255,255,255,0.05)',
                                        borderRadius: '4px'
                                    }}>
                                        ðŸ’¡ <strong>Tip:</strong> Research shows 73-85 dB SPL is optimal for spatial perception.
                                        At high volumes, spatial cues get "drowned out". Try 40-60% for best results.
                                    </div>
                                </div>
                            );
                        })()}

                        {/* Quick Calibration Button */}
                        {!showCalibration && (
                            <button
                                onClick={() => {
                                    setShowCalibration(true);
                                    setCalibrationStep(0);
                                }}
                                style={{
                                    width: '100%',
                                    padding: '12px',
                                    marginBottom: '16px',
                                    background: 'linear-gradient(135deg, #8b5cf6, #6366f1)',
                                    color: 'white',
                                    border: 'none',
                                    borderRadius: '8px',
                                    cursor: 'pointer',
                                    fontWeight: '600',
                                    fontSize: '0.9rem',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    gap: '8px'
                                }}
                            >
                                ðŸ§  Quick Brain Calibration (APD-Friendly)
                            </button>
                        )}

                        {/* Calibration Wizard */}
                        {showCalibration && (
                            <div style={{
                                background: 'rgba(139, 92, 246, 0.1)',
                                border: '2px solid #8b5cf6',
                                borderRadius: '12px',
                                padding: '16px',
                                marginBottom: '16px'
                            }}>
                                {calibrationStep === 0 && (
                                    <div>
                                        <h4 style={{ margin: '0 0 12px', color: '#a78bfa' }}>ðŸ§  Brain Calibration Wizard</h4>
                                        <p style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', marginBottom: '12px' }}>
                                            This wizard will help find the spatial audio settings that work best for YOUR brain.
                                            We'll test different types of spatial cues and adjust based on what you can perceive.
                                        </p>
                                        <div style={{ background: 'rgba(0,0,0,0.3)', padding: '12px', borderRadius: '8px', marginBottom: '12px' }}>
                                            <p style={{ fontSize: '0.8rem', color: '#fbbf24', margin: '0 0 8px' }}>
                                                <strong>For Auditory Processing Differences:</strong>
                                            </p>
                                            <ul style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', margin: 0, paddingLeft: '20px' }}>
                                                <li>Timing cues (ITD) may be harder to perceive - we'll test this</li>
                                                <li>Frequency changes (muffling) are often easier to notice</li>
                                                <li>We can boost effects that work best for you</li>
                                            </ul>
                                        </div>
                                        <p style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginBottom: '16px' }}>
                                            <strong>Requirements:</strong> Music playing + headphones on
                                        </p>
                                        <div style={{ display: 'flex', gap: '8px' }}>
                                            <button
                                                onClick={() => setCalibrationStep(1)}
                                                style={{
                                                    flex: 1,
                                                    padding: '10px',
                                                    background: '#8b5cf6',
                                                    color: 'white',
                                                    border: 'none',
                                                    borderRadius: '6px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600'
                                                }}
                                            >
                                                Start Calibration â†’
                                            </button>
                                            <button
                                                onClick={() => setShowCalibration(false)}
                                                style={{
                                                    padding: '10px 16px',
                                                    background: 'transparent',
                                                    color: 'var(--text-secondary)',
                                                    border: '1px solid var(--text-secondary)',
                                                    borderRadius: '6px',
                                                    cursor: 'pointer'
                                                }}
                                            >
                                                Cancel
                                            </button>
                                        </div>
                                    </div>
                                )}

                                {calibrationStep === 1 && (
                                    <div>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                                            <h4 style={{ margin: 0, color: '#a78bfa' }}>Step 1: Left/Right Test</h4>
                                            <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)' }}>1 of 4</span>
                                        </div>
                                        <p style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', marginBottom: '12px' }}>
                                            I'll move the sound to the <strong>LEFT</strong> then <strong>RIGHT</strong>.
                                            Listen carefully - can you tell the difference?
                                        </p>

                                        {/* Test buttons to move sound */}
                                        <div style={{ display: 'flex', gap: '8px', marginBottom: '16px' }}>
                                            <button
                                                onClick={() => {
                                                    setOrbPosition({ x: -80, y: 0 });
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '16px',
                                                    background: 'rgba(59, 130, 246, 0.2)',
                                                    color: '#60a5fa',
                                                    border: '2px solid #60a5fa',
                                                    borderRadius: '8px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600',
                                                    fontSize: '1.1rem'
                                                }}
                                            >
                                                ðŸ‘ˆ LEFT
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setOrbPosition({ x: 80, y: 0 });
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '16px',
                                                    background: 'rgba(34, 197, 94, 0.2)',
                                                    color: '#4ade80',
                                                    border: '2px solid #4ade80',
                                                    borderRadius: '8px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600',
                                                    fontSize: '1.1rem'
                                                }}
                                            >
                                                RIGHT ðŸ‘‰
                                            </button>
                                        </div>

                                        <p style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginBottom: '8px' }}>
                                            <strong>Can you clearly hear the difference between LEFT and RIGHT?</strong>
                                        </p>
                                        <div style={{ display: 'flex', gap: '8px', marginBottom: '8px' }}>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearLeftRight: 'clear', leftRightIntensity: 2.0 }));
                                                    setCalibrationStep(2);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#4ade80', color: 'black', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                Yes, clearly! âœ“
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearLeftRight: 'subtle', leftRightIntensity: 3.0 }));
                                                    setPanCurve(3.0);
                                                    setCalibrationStep(2);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#fbbf24', color: 'black', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                Barely / Subtle
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearLeftRight: 'no', leftRightIntensity: 4.0 }));
                                                    setPanCurve(4.0);
                                                    setCrossBleed(0);
                                                    setCalibrationStep(2);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#f87171', color: 'white', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                No / Can't tell âœ—
                                            </button>
                                        </div>
                                    </div>
                                )}

                                {calibrationStep === 2 && (
                                    <div>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                                            <h4 style={{ margin: 0, color: '#a78bfa' }}>Step 2: Front/Back Test (Muffling)</h4>
                                            <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)' }}>2 of 4</span>
                                        </div>
                                        <p style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', marginBottom: '12px' }}>
                                            I'll move the sound to the <strong>FRONT</strong> (bright/clear) then <strong>BACK</strong> (muffled/darker).
                                            This tests if you can hear the tone change.
                                        </p>

                                        <div style={{ display: 'flex', gap: '8px', marginBottom: '16px' }}>
                                            <button
                                                onClick={() => {
                                                    setOrbPosition({ x: 0, y: -80 });
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '16px',
                                                    background: 'rgba(251, 191, 36, 0.2)',
                                                    color: '#fbbf24',
                                                    border: '2px solid #fbbf24',
                                                    borderRadius: '8px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600',
                                                    fontSize: '1rem'
                                                }}
                                            >
                                                ðŸ”† FRONT (Clear)
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setOrbPosition({ x: 0, y: 80 });
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '16px',
                                                    background: 'rgba(107, 114, 128, 0.3)',
                                                    color: '#9ca3af',
                                                    border: '2px solid #6b7280',
                                                    borderRadius: '8px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600',
                                                    fontSize: '1rem'
                                                }}
                                            >
                                                ðŸ”… BACK (Muffled)
                                            </button>
                                        </div>

                                        <p style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginBottom: '8px' }}>
                                            <strong>Can you hear the muffling/darkening when sound moves to BACK?</strong>
                                        </p>
                                        <div style={{ display: 'flex', gap: '8px' }}>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearFrontBack: 'clear', frontBackIntensity: 0.5 }));
                                                    setCalibrationStep(3);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#4ade80', color: 'black', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                Yes, clearly! âœ“
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearFrontBack: 'subtle', frontBackIntensity: 0.8 }));
                                                    setHeadShadow(0.8);
                                                    setCalibrationStep(3);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#fbbf24', color: 'black', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                Barely / Subtle
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearFrontBack: 'no', frontBackIntensity: 1.0 }));
                                                    setHeadShadow(1.0);
                                                    setBackDepth(0.35);
                                                    setCalibrationStep(3);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#f87171', color: 'white', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                No / Can't tell âœ—
                                            </button>
                                        </div>
                                    </div>
                                )}

                                {calibrationStep === 3 && (
                                    <div>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                                            <h4 style={{ margin: 0, color: '#a78bfa' }}>Step 3: Timing Test (ITD)</h4>
                                            <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)' }}>3 of 4</span>
                                        </div>
                                        <p style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', marginBottom: '8px' }}>
                                            This tests tiny timing differences (sound reaches one ear before the other).
                                            <strong style={{ color: '#fbbf24' }}> This is often harder for APD brains to detect - that's okay!</strong>
                                        </p>

                                        <div style={{ display: 'flex', gap: '8px', marginBottom: '16px' }}>
                                            <button
                                                onClick={() => {
                                                    setItdAmount(0);
                                                    setOrbPosition({ x: 80, y: 0 });
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '12px',
                                                    background: 'rgba(239, 68, 68, 0.2)',
                                                    color: '#f87171',
                                                    border: '2px solid #ef4444',
                                                    borderRadius: '8px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600'
                                                }}
                                            >
                                                No Timing (ITD Off)
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setItdAmount(1.5);
                                                    setOrbPosition({ x: 80, y: 0 });
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '12px',
                                                    background: 'rgba(139, 92, 246, 0.2)',
                                                    color: '#a78bfa',
                                                    border: '2px solid #8b5cf6',
                                                    borderRadius: '8px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600'
                                                }}
                                            >
                                                Max Timing (ITD Max)
                                            </button>
                                        </div>

                                        <p style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginBottom: '8px' }}>
                                            <strong>Toggle between these - can you hear ANY difference?</strong>
                                        </p>
                                        <div style={{ display: 'flex', gap: '8px' }}>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearTiming: 'yes', timingIntensity: 1.0 }));
                                                    setItdAmount(1.0);
                                                    setCalibrationStep(4);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#4ade80', color: 'black', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                Yes, I hear it âœ“
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setCalibrationResults(prev => ({ ...prev, canHearTiming: 'no', timingIntensity: 0 }));
                                                    setItdAmount(0);
                                                    setCalibrationStep(4);
                                                }}
                                                style={{ flex: 1, padding: '10px', background: '#f87171', color: 'white', border: 'none', borderRadius: '6px', cursor: 'pointer', fontWeight: '600' }}
                                            >
                                                No difference âœ—
                                            </button>
                                        </div>
                                        <p style={{ fontSize: '0.7rem', color: 'var(--text-secondary)', marginTop: '8px', fontStyle: 'italic' }}>
                                            Note: If you can't hear ITD, that's common with APD. We'll rely on other cues instead!
                                        </p>
                                    </div>
                                )}

                                {calibrationStep === 4 && (
                                    <div>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                                            <h4 style={{ margin: 0, color: '#4ade80' }}>âœ“ Calibration Complete!</h4>
                                            <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)' }}>4 of 4</span>
                                        </div>

                                        <div style={{ background: 'rgba(0,0,0,0.3)', padding: '12px', borderRadius: '8px', marginBottom: '16px' }}>
                                            <p style={{ fontSize: '0.85rem', color: 'var(--text-primary)', margin: '0 0 12px', fontWeight: '600' }}>
                                                Your Personalized Profile:
                                            </p>
                                            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px', fontSize: '0.8rem' }}>
                                                <div>
                                                    <span style={{ color: 'var(--text-secondary)' }}>Left/Right:</span>
                                                    <span style={{ marginLeft: '8px', color: calibrationResults.canHearLeftRight === 'clear' ? '#4ade80' : (calibrationResults.canHearLeftRight === 'subtle' ? '#fbbf24' : '#f87171') }}>
                                                        {calibrationResults.canHearLeftRight === 'clear' ? 'Clear âœ“' : (calibrationResults.canHearLeftRight === 'subtle' ? 'Boosted' : 'Max Boost')}
                                                    </span>
                                                </div>
                                                <div>
                                                    <span style={{ color: 'var(--text-secondary)' }}>Front/Back:</span>
                                                    <span style={{ marginLeft: '8px', color: calibrationResults.canHearFrontBack === 'clear' ? '#4ade80' : (calibrationResults.canHearFrontBack === 'subtle' ? '#fbbf24' : '#f87171') }}>
                                                        {calibrationResults.canHearFrontBack === 'clear' ? 'Clear âœ“' : (calibrationResults.canHearFrontBack === 'subtle' ? 'Boosted' : 'Max Boost')}
                                                    </span>
                                                </div>
                                                <div>
                                                    <span style={{ color: 'var(--text-secondary)' }}>Timing (ITD):</span>
                                                    <span style={{ marginLeft: '8px', color: calibrationResults.canHearTiming === 'yes' ? '#4ade80' : '#6b7280' }}>
                                                        {calibrationResults.canHearTiming === 'yes' ? 'Enabled âœ“' : 'Disabled (OK!)'}
                                                    </span>
                                                </div>
                                                <div>
                                                    <span style={{ color: 'var(--text-secondary)' }}>Strategy:</span>
                                                    <span style={{ marginLeft: '8px', color: '#a78bfa' }}>
                                                        {calibrationResults.canHearTiming === 'no' ? 'Volume + Tone' : 'Full Spatial'}
                                                    </span>
                                                </div>
                                            </div>
                                        </div>

                                        {calibrationResults.canHearTiming === 'no' && (
                                            <div style={{ background: 'rgba(251, 191, 36, 0.1)', padding: '10px', borderRadius: '6px', marginBottom: '12px', fontSize: '0.8rem', color: '#fbbf24' }}>
                                                ðŸ’¡ <strong>APD-Optimized:</strong> Since timing cues are harder for you, we're using
                                                <strong> volume differences</strong> and <strong>tone changes</strong> (muffling) as your primary spatial cues.
                                                These are processed differently by the brain and often work better!
                                            </div>
                                        )}

                                        <div style={{ display: 'flex', gap: '8px' }}>
                                            <button
                                                onClick={() => {
                                                    setShowCalibration(false);
                                                    setOrbPosition({ x: 0, y: -80 }); // Reset to front
                                                }}
                                                style={{
                                                    flex: 1,
                                                    padding: '12px',
                                                    background: '#4ade80',
                                                    color: 'black',
                                                    border: 'none',
                                                    borderRadius: '6px',
                                                    cursor: 'pointer',
                                                    fontWeight: '600'
                                                }}
                                            >
                                                Apply Settings âœ“
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setCalibrationStep(0);
                                                }}
                                                style={{
                                                    padding: '12px 16px',
                                                    background: 'transparent',
                                                    color: 'var(--text-secondary)',
                                                    border: '1px solid var(--text-secondary)',
                                                    borderRadius: '6px',
                                                    cursor: 'pointer'
                                                }}
                                            >
                                                Redo
                                            </button>
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}

                        {/* Head visualization - only show when not in calibration */}
                        {!showCalibration && (
                        <div
                            ref={containerRef}
                            style={{
                                width: '200px',
                                height: '200px',
                                margin: '0 auto 16px',
                                position: 'relative',
                                cursor: 'crosshair'
                            }}
                            onMouseDown={handleMouseDown}
                            onMouseMove={handleMouseMove}
                            onMouseUp={handleMouseUp}
                            onMouseLeave={handleMouseUp}
                        >
                            {/* Head circle */}
                            <div style={{
                                position: 'absolute',
                                top: '50%',
                                left: '50%',
                                transform: 'translate(-50%, -50%)',
                                width: '160px',
                                height: '160px',
                                borderRadius: '50%',
                                border: '3px solid var(--text-secondary)',
                                background: 'rgba(255,255,255,0.05)'
                            }}>
                                {/* Nose indicator */}
                                <div style={{
                                    position: 'absolute',
                                    top: '-15px',
                                    left: '50%',
                                    transform: 'translateX(-50%)',
                                    width: '0',
                                    height: '0',
                                    borderLeft: '8px solid transparent',
                                    borderRight: '8px solid transparent',
                                    borderBottom: '12px solid var(--text-secondary)'
                                }} />
                                {/* Left ear */}
                                <div style={{
                                    position: 'absolute',
                                    top: '50%',
                                    left: '-12px',
                                    transform: 'translateY(-50%)',
                                    width: '10px',
                                    height: '24px',
                                    borderRadius: '5px',
                                    background: 'var(--text-secondary)'
                                }} />
                                {/* Right ear */}
                                <div style={{
                                    position: 'absolute',
                                    top: '50%',
                                    right: '-12px',
                                    transform: 'translateY(-50%)',
                                    width: '10px',
                                    height: '24px',
                                    borderRadius: '5px',
                                    background: 'var(--text-secondary)'
                                }} />
                                {/* Labels */}
                                <span style={{ position: 'absolute', top: '-30px', left: '50%', transform: 'translateX(-50%)', fontSize: '0.7rem', color: 'var(--text-secondary)' }}>FRONT</span>
                                <span style={{ position: 'absolute', bottom: '-25px', left: '50%', transform: 'translateX(-50%)', fontSize: '0.7rem', color: 'var(--text-secondary)' }}>BACK</span>
                                <span style={{ position: 'absolute', top: '50%', left: '-35px', transform: 'translateY(-50%)', fontSize: '0.7rem', color: 'var(--text-secondary)' }}>L</span>
                                <span style={{ position: 'absolute', top: '50%', right: '-35px', transform: 'translateY(-50%)', fontSize: '0.7rem', color: 'var(--text-secondary)' }}>R</span>
                            </div>

                            {/* Sound orb - highly visible */}
                            <div style={{
                                position: 'absolute',
                                top: '50%',
                                left: '50%',
                                transform: `translate(calc(-50% + ${orbPosition.x}px), calc(-50% + ${orbPosition.y}px))`,
                                width: '32px',
                                height: '32px',
                                borderRadius: '50%',
                                background: '#ff6b35',
                                border: '3px solid #fff',
                                boxShadow: '0 0 20px #ff6b35, 0 0 40px rgba(255, 107, 53, 0.5), inset 0 0 10px rgba(255,255,255,0.3)',
                                cursor: isDragging ? 'grabbing' : 'grab',
                                transition: isDragging ? 'none' : 'transform 0.1s ease',
                                zIndex: 10
                            }}>
                                {/* Inner glow dot */}
                                <div style={{
                                    position: 'absolute',
                                    top: '50%',
                                    left: '50%',
                                    transform: 'translate(-50%, -50%)',
                                    width: '10px',
                                    height: '10px',
                                    borderRadius: '50%',
                                    background: '#fff'
                                }} />
                            </div>
                        </div>
                        )}

                        {/* Current values display */}
                        <div style={{
                            background: 'rgba(0,0,0,0.3)',
                            borderRadius: '8px',
                            padding: '12px',
                            fontFamily: 'monospace',
                            fontSize: '0.75rem',
                            marginBottom: '16px'
                        }}>
                            <div style={{ marginBottom: '8px', fontWeight: 'bold', color: 'var(--accent)' }}>
                                Position: {getPositionLabel()} ({Math.round(normalizedAngle)}Â°)
                            </div>
                            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' }}>
                                <div>
                                    <div style={{ color: 'var(--text-secondary)' }}>Pan Position:</div>
                                    <div style={{ color: '#4ade80' }}>{panPosition.toFixed(2)}</div>
                                </div>
                                <div>
                                    <div style={{ color: 'var(--text-secondary)' }}>Depth Mult:</div>
                                    <div style={{ color: '#4ade80' }}>{baseDepthMultiplier.toFixed(2)}</div>
                                </div>
                                <div>
                                    <div style={{ color: 'var(--text-secondary)' }}>Hard L/R Gain:</div>
                                    <div style={{ color: '#f472b6' }}>{hardLeftGain.toFixed(2)} / {hardRightGain.toFixed(2)}</div>
                                </div>
                                <div>
                                    <div style={{ color: 'var(--text-secondary)' }}>ITD L/R Delay:</div>
                                    <div style={{ color: '#f472b6' }}>{(itdLeftDelay * 1000).toFixed(2)}ms / {(itdRightDelay * 1000).toFixed(2)}ms</div>
                                </div>
                                <div>
                                    <div style={{ color: 'var(--text-secondary)' }}>Filter L/R (Hz):</div>
                                    <div style={{ color: '#a78bfa' }}>{Math.round(leftFilterFreq)} / {Math.round(rightFilterFreq)}</div>
                                </div>
                            </div>

                            {/* Ear indicators */}
                            <div style={{ marginTop: '12px', display: 'flex', gap: '16px', justifyContent: 'center' }}>
                                <div style={{ textAlign: 'center' }}>
                                    <div style={{ fontSize: '1.5rem' }}>ðŸ‘‚</div>
                                    <div style={{
                                        height: '8px',
                                        width: '60px',
                                        background: 'rgba(255,255,255,0.2)',
                                        borderRadius: '4px',
                                        overflow: 'hidden'
                                    }}>
                                        <div style={{
                                            height: '100%',
                                            width: `${hardLeftGain * 100}%`,
                                            background: '#4ade80',
                                            transition: 'width 0.1s'
                                        }} />
                                    </div>
                                    <div style={{ fontSize: '0.7rem', color: 'var(--text-secondary)' }}>LEFT</div>
                                </div>
                                <div style={{ textAlign: 'center' }}>
                                    <div style={{ fontSize: '1.5rem', transform: 'scaleX(-1)' }}>ðŸ‘‚</div>
                                    <div style={{
                                        height: '8px',
                                        width: '60px',
                                        background: 'rgba(255,255,255,0.2)',
                                        borderRadius: '4px',
                                        overflow: 'hidden'
                                    }}>
                                        <div style={{
                                            height: '100%',
                                            width: `${hardRightGain * 100}%`,
                                            background: '#4ade80',
                                            transition: 'width 0.1s'
                                        }} />
                                    </div>
                                    <div style={{ fontSize: '0.7rem', color: 'var(--text-secondary)' }}>RIGHT</div>
                                </div>
                            </div>
                        </div>

                        {/* Advanced Settings */}
                        <div style={{
                            background: 'rgba(0,0,0,0.3)',
                            borderRadius: '8px',
                            padding: '12px',
                            marginBottom: '16px'
                        }}>
                            <div style={{ fontWeight: 'bold', marginBottom: '12px', color: 'var(--accent)', fontSize: '0.875rem' }}>
                                âš™ï¸ Fine-Tune Settings
                            </div>

                            {/* Cross Bleed */}
                            <div style={{ marginBottom: '12px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                    <span style={{ color: 'var(--text-secondary)' }}>Cross Bleed (opposite ear)</span>
                                    <span style={{ color: '#4ade80' }}>{(crossBleed * 100).toFixed(0)}%</span>
                                </div>
                                <input
                                    type="range"
                                    min="0"
                                    max="0.3"
                                    step="0.01"
                                    value={crossBleed}
                                    onChange={(e) => setCrossBleed(parseFloat(e.target.value))}
                                    style={{ width: '100%', accentColor: 'var(--accent)' }}
                                />
                                <div style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                    0% = complete isolation, 30% = some bleed to other ear
                                </div>
                            </div>

                            {/* Back Depth */}
                            <div style={{ marginBottom: '12px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                    <span style={{ color: 'var(--text-secondary)' }}>Back Volume</span>
                                    <span style={{ color: '#4ade80' }}>{(backDepth * 100).toFixed(0)}%</span>
                                </div>
                                <input
                                    type="range"
                                    min="0.3"
                                    max="1.0"
                                    step="0.05"
                                    value={backDepth}
                                    onChange={(e) => setBackDepth(parseFloat(e.target.value))}
                                    style={{ width: '100%', accentColor: 'var(--accent)' }}
                                />
                                <div style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                    Volume when sound is behind you (simulates distance)
                                </div>
                            </div>

                            {/* Pan Curve */}
                            <div style={{ marginBottom: '12px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                    <span style={{ color: 'var(--text-secondary)' }}>Pan Aggressiveness</span>
                                    <span style={{ color: '#4ade80' }}>{panCurve.toFixed(1)}x</span>
                                </div>
                                <input
                                    type="range"
                                    min="1"
                                    max="4"
                                    step="0.1"
                                    value={panCurve}
                                    onChange={(e) => setPanCurve(parseFloat(e.target.value))}
                                    style={{ width: '100%', accentColor: 'var(--accent)' }}
                                />
                                <div style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                    Higher = faster L/R separation as orb moves from center
                                </div>
                            </div>

                            {/* Hard Pan Threshold */}
                            <div style={{ marginBottom: '12px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                    <span style={{ color: 'var(--text-secondary)' }}>Center Dead Zone</span>
                                    <span style={{ color: '#4ade80' }}>{(hardPanThreshold * 100).toFixed(0)}%</span>
                                </div>
                                <input
                                    type="range"
                                    min="0"
                                    max="0.5"
                                    step="0.05"
                                    value={hardPanThreshold}
                                    onChange={(e) => setHardPanThreshold(parseFloat(e.target.value))}
                                    style={{ width: '100%', accentColor: 'var(--accent)' }}
                                />
                                <div style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                    Size of center zone where both ears hear equally
                                </div>
                            </div>

                            {/* ITD Amount */}
                            <div style={{ marginBottom: '12px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                    <span style={{ color: 'var(--text-secondary)' }}>Time Delay (ITD)</span>
                                    <span style={{ color: '#f472b6' }}>{(itdAmount * 0.7).toFixed(2)}ms</span>
                                </div>
                                <input
                                    type="range"
                                    min="0"
                                    max="1.5"
                                    step="0.1"
                                    value={itdAmount}
                                    onChange={(e) => setItdAmount(parseFloat(e.target.value))}
                                    style={{ width: '100%', accentColor: '#f472b6' }}
                                />
                                <div style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                    Sound reaches closer ear first (0.7ms is realistic max)
                                </div>
                            </div>

                            {/* Directional Depth */}
                            <div style={{ marginBottom: '12px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                    <span style={{ color: 'var(--text-secondary)' }}>Rear Ear Damping</span>
                                    <span style={{ color: '#f472b6' }}>{(directionalDepth * 100).toFixed(0)}%</span>
                                </div>
                                <input
                                    type="range"
                                    min="0"
                                    max="0.4"
                                    step="0.05"
                                    value={directionalDepth}
                                    onChange={(e) => setDirectionalDepth(parseFloat(e.target.value))}
                                    style={{ width: '100%', accentColor: '#f472b6' }}
                                />
                                <div style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                    Extra quieting when sound is behind that ear (pinna effect)
                                </div>
                            </div>

                            {/* Head Shadow (Low-pass filter) */}
                            <div style={{ marginBottom: '8px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', marginBottom: '4px' }}>
                                    <span style={{ color: 'var(--text-secondary)' }}>Head Shadow (Muffling)</span>
                                    <span style={{ color: '#a78bfa' }}>{(headShadow * 100).toFixed(0)}%</span>
                                </div>
                                <input
                                    type="range"
                                    min="0"
                                    max="1"
                                    step="0.1"
                                    value={headShadow}
                                    onChange={(e) => setHeadShadow(parseFloat(e.target.value))}
                                    style={{ width: '100%', accentColor: '#a78bfa' }}
                                />
                                <div style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                    Cuts high frequencies when behind/opposite (darker, muffled sound)
                                </div>
                            </div>

                            {/* Reset button */}
                            <button
                                onClick={() => {
                                    setCrossBleed(0);
                                    setBackDepth(0.55);
                                    setPanCurve(2.0);
                                    setHardPanThreshold(0.1);
                                    setItdAmount(0.7);
                                    setDirectionalDepth(0.15);
                                    setHeadShadow(0.5);
                                }}
                                style={{
                                    width: '100%',
                                    padding: '8px',
                                    background: 'rgba(255,255,255,0.1)',
                                    border: '1px solid var(--text-secondary)',
                                    borderRadius: '4px',
                                    color: 'var(--text-secondary)',
                                    cursor: 'pointer',
                                    fontSize: '0.75rem'
                                }}
                            >
                                Reset to Defaults
                            </button>
                        </div>

                        {/* Copy settings button */}
                        <div style={{ display: 'flex', gap: '8px' }}>
                            <button
                                onClick={() => {
                                    const settings = {
                                        // Current position
                                        panPosition: panPosition.toFixed(3),
                                        depthMultiplier: baseDepthMultiplier.toFixed(2),
                                        hardLeftGain: hardLeftGain.toFixed(3),
                                        hardRightGain: hardRightGain.toFixed(3),
                                        angle: Math.round(normalizedAngle),
                                        position: getPositionLabel(),
                                        // Tuning parameters
                                        tuning: {
                                            crossBleed: crossBleed.toFixed(2),
                                            backDepth: backDepth.toFixed(2),
                                            panCurve: panCurve.toFixed(1),
                                            hardPanThreshold: hardPanThreshold.toFixed(2),
                                            itdAmount: itdAmount.toFixed(2),
                                            directionalDepth: directionalDepth.toFixed(2),
                                            headShadow: headShadow.toFixed(2)
                                        },
                                        // Current ITD delays
                                        itd: {
                                            leftDelayMs: (itdLeftDelay * 1000).toFixed(3),
                                            rightDelayMs: (itdRightDelay * 1000).toFixed(3)
                                        },
                                        // Current filter frequencies
                                        filters: {
                                            leftHz: Math.round(leftFilterFreq),
                                            rightHz: Math.round(rightFilterFreq)
                                        }
                                    };
                                    const text = JSON.stringify(settings, null, 2);
                                    navigator.clipboard.writeText(text);
                                    alert('Settings copied! Paste them to share with the developer.');
                                }}
                                style={{
                                    flex: 1,
                                    padding: '12px',
                                    background: 'var(--accent)',
                                    color: 'white',
                                    border: 'none',
                                    borderRadius: '8px',
                                    cursor: 'pointer',
                                    fontWeight: '600'
                                }}
                            >
                                ðŸ“‹ Copy Settings
                            </button>
                            <button
                                onClick={onClose}
                                style={{
                                    padding: '12px 24px',
                                    background: 'transparent',
                                    color: 'var(--text-primary)',
                                    border: '1px solid var(--text-secondary)',
                                    borderRadius: '8px',
                                    cursor: 'pointer'
                                }}
                            >
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // Advanced Controls Component (Story 3-2)
        const AdvancedControls = ({
            // Parameter states (from existing Epic 1 hooks)
            speed, setSpeed,
            intensity, setIntensity,
            spatialDepth, setSpatialDepth,
            movementPattern, setMovementPattern,
            binauralEnabled, setBinauralEnabled,
            binauralFreq, setBinauralFreq,
            noiseType, setNoiseType,
            noiseVolume, setNoiseVolume,
            // UI state
            isExpanded, setIsExpanded,
            sensorLocked, setSensorLocked,
            setA11yAnnouncement,
            // Story 3-3: Save preset handler
            onSavePreset,
            // Spatial tuner
            onOpenTuner
        }) => {
            return (
                <details 
                    open={isExpanded} 
                    onToggle={(e) => setIsExpanded(e.target.open)}
                    className="advanced-controls"
                >
                    <summary>
                        âš™ï¸ Advanced Controls
                        <kbd>Ctrl+E</kbd>
                    </summary>
                    
                    <div className="controls-grid">
                        {/* Rotation Speed Slider */}
                        <label className="control-group">
                            <span className="control-label">Rotation Speed</span>
                            <div className="control-input">
                                <input 
                                    type="range" 
                                    min={PARAM_RANGES.speed.min} 
                                    max={PARAM_RANGES.speed.max} 
                                    step={PARAM_RANGES.speed.step} 
                                    value={speed} 
                                    onChange={(e) => setSpeed(parseFloat(e.target.value))} 
                                    disabled={sensorLocked}
                                    aria-label="Rotation speed"
                                />
                                <output>{speed.toFixed(2)}</output>
                            </div>
                            <span className="control-hint">How fast sound orbits your head</span>
                        </label>
                        
                        {/* Intensity Slider */}
                        <label className="control-group">
                            <span className="control-label">Intensity</span>
                            <div className="control-input">
                                <input 
                                    type="range" 
                                    min={PARAM_RANGES.intensity.min} 
                                    max={PARAM_RANGES.intensity.max} 
                                    step={PARAM_RANGES.intensity.step} 
                                    value={intensity} 
                                    onChange={(e) => setIntensity(parseFloat(e.target.value))} 
                                    disabled={sensorLocked}
                                    aria-label="Intensity"
                                />
                                <output>{intensity.toFixed(2)}</output>
                            </div>
                            <span className="control-hint">Strength of 8D effect</span>
                        </label>
                        
                        {/* Spatial Depth Slider */}
                        <label className="control-group">
                            <span className="control-label">Spatial Depth</span>
                            <div className="control-input">
                                <input 
                                    type="range" 
                                    min={PARAM_RANGES.spatialDepth.min} 
                                    max={PARAM_RANGES.spatialDepth.max} 
                                    step={PARAM_RANGES.spatialDepth.step} 
                                    value={spatialDepth} 
                                    onChange={(e) => setSpatialDepth(parseFloat(e.target.value))} 
                                    disabled={sensorLocked}
                                    aria-label="Spatial depth"
                                />
                                <output>{spatialDepth.toFixed(2)}</output>
                            </div>
                            <span className="control-hint">Front/back positioning</span>
                        </label>
                        
                        {/* Movement Pattern Dropdown */}
                        <label className="control-group">
                            <span className="control-label">Movement Pattern</span>
                            <div className="control-input">
                                <select 
                                    value={movementPattern} 
                                    onChange={(e) => setMovementPattern(e.target.value)}
                                    disabled={sensorLocked}
                                    aria-label="Movement pattern"
                                >
                                    <option value="circle">Circle - Steady orbit</option>
                                    <option value="figure8">Figure-8 - Gentle sway</option>
                                    <option value="leftright">Left-Right - Side-to-side</option>
                                    <option value="frontback">Front-Back - Forward-backward</option>
                                    <option value="random">Random - Unpredictable</option>
                                </select>
                            </div>
                            <span className="control-hint">Path sound travels around you</span>
                        </label>
                        
                        {/* Binaural Beats Checkbox */}
                        <label className="control-group checkbox-group">
                            <input 
                                type="checkbox" 
                                checked={binauralEnabled} 
                                onChange={(e) => setBinauralEnabled(e.target.checked)}
                                disabled={sensorLocked}
                                aria-label="Enable binaural beats"
                            />
                            <span className="control-label">Binaural Beats</span>
                        </label>
                        
                        {/* Binaural Frequency Slider (conditional) */}
                        {binauralEnabled && (
                            <label className="control-group">
                                <span className="control-label">Binaural Frequency</span>
                                <div className="control-input">
                                    <input 
                                        type="range" 
                                        min={PARAM_RANGES.binauralFreq.min} 
                                        max={PARAM_RANGES.binauralFreq.max} 
                                        step={PARAM_RANGES.binauralFreq.step} 
                                        value={binauralFreq} 
                                        onChange={(e) => setBinauralFreq(parseInt(e.target.value))} 
                                        disabled={sensorLocked}
                                        aria-label="Binaural frequency"
                                    />
                                    <output>
                                        {binauralFreq} Hz 
                                        <span className="freq-band">({getBinauralBand(binauralFreq)})</span>
                                    </output>
                                </div>
                                <span className="control-hint">{getBinauralHint(binauralFreq)}</span>
                            </label>
                        )}
                        
                        {/* Noise Type Dropdown */}
                        <label className="control-group">
                            <span className="control-label">Noise Type</span>
                            <div className="control-input">
                                <select 
                                    value={noiseType} 
                                    onChange={(e) => setNoiseType(e.target.value)}
                                    disabled={sensorLocked}
                                    aria-label="Noise type"
                                >
                                    <option value="pink">Pink - Balanced warmth</option>
                                    <option value="white">White - Crisp static</option>
                                    <option value="brown">Brown - Deep rumble</option>
                                </select>
                            </div>
                            <span className="control-hint">Background noise texture</span>
                        </label>
                        
                        {/* Noise Volume Slider */}
                        <label className="control-group">
                            <span className="control-label">Noise Volume</span>
                            <div className="control-input">
                                <input 
                                    type="range" 
                                    min={PARAM_RANGES.noiseVolume.min} 
                                    max={PARAM_RANGES.noiseVolume.max} 
                                    step={PARAM_RANGES.noiseVolume.step} 
                                    value={noiseVolume} 
                                    onChange={(e) => setNoiseVolume(parseFloat(e.target.value))} 
                                    disabled={sensorLocked}
                                    aria-label="Noise volume"
                                />
                                <output>{noiseVolume.toFixed(2)}</output>
                            </div>
                            <span className="control-hint">Loudness of background noise</span>
                        </label>
                    </div>
                    
                    {/* Story 3-3: Save Preset Button */}
                    {!sensorLocked && onSavePreset && (
                        <button
                            type="button"
                            onClick={onSavePreset}
                            className="primary-btn"
                            style={{ marginTop: '16px', width: '100%' }}
                            aria-label="Save current parameters as custom preset"
                        >
                            ðŸ’¾ Save as Custom Preset
                        </button>
                    )}

                    {/* Spatial Audio Tuner Button */}
                    {onOpenTuner && (
                        <button
                            type="button"
                            onClick={onOpenTuner}
                            style={{
                                marginTop: '8px',
                                width: '100%',
                                padding: '12px',
                                background: 'rgba(255,255,255,0.1)',
                                border: '1px dashed var(--text-secondary)',
                                borderRadius: '8px',
                                color: 'var(--text-primary)',
                                cursor: 'pointer',
                                fontSize: '0.875rem'
                            }}
                            aria-label="Open spatial audio tuner"
                        >
                            ðŸŽ¯ Open Spatial Tuner (Debug)
                        </button>
                    )}

                    {/* Sensor Lock Notice */}
                    {sensorLocked && (
                        <div className="sensor-lock-notice" role="status" aria-live="polite">
                            <span className="lock-icon">ðŸ”’</span>
                            <span className="lock-message">Parameters locked by adaptive mode</span>
                            <button 
                                onClick={() => {
                                    setSensorLocked(false);
                                    setA11yAnnouncement('Adaptive mode disabled. Controls unlocked.');
                                }}
                                className="unlock-btn"
                            >
                                Unlock Manual Control
                            </button>
                        </div>
                    )}
                </details>
            );
        };

        // ============================================================
        // Story 3-3: Save Preset Dialog Component
        // ============================================================
        
        const SavePresetDialog = ({ 
            currentParameters, 
            onSave, 
            onCancel,
            showToast,
            setA11yAnnouncement,
            existingPreset = null // for edit mode
        }) => {
            const [name, setName] = useState(existingPreset?.name || '');
            const [description, setDescription] = useState(existingPreset?.description || '');
            const [color, setColor] = useState(existingPreset?.color || '#6366f1');
            const [errors, setErrors] = useState({});
            
            const validate = () => {
                const newErrors = {};
                
                if (!name.trim()) {
                    newErrors.name = 'Preset name is required';
                } else if (name.length > 50) {
                    newErrors.name = 'Name too long (max 50 characters)';
                }
                
                if (description.length > 200) {
                    newErrors.description = 'Description too long (max 200 characters)';
                }
                
                // Validate color hex format
                const hexPattern = /^#[0-9A-Fa-f]{6}$/;
                if (!hexPattern.test(color)) {
                    newErrors.color = 'Invalid color format (use #RRGGBB)';
                }
                
                setErrors(newErrors);
                return Object.keys(newErrors).length === 0;
            };
            
            const handleSave = () => {
                if (!validate()) return;
                
                const presetData = {
                    name: name.trim(),
                    description: description.trim(),
                    color,
                    ...currentParameters
                };
                
                let presetId;
                if (existingPreset) {
                    // Edit mode
                    const success = updateCustomPreset(existingPreset.id, presetData, showToast);
                    if (success) {
                        presetId = existingPreset.id;
                        showToast(`Preset "${name}" updated`, 'success');
                        setA11yAnnouncement(`Preset ${name} updated`);
                    }
                } else {
                    // Create mode
                    presetId = saveCustomPreset(presetData, showToast);
                    if (presetId) {
                        showToast(`Preset "${name}" saved`, 'success');
                        setA11yAnnouncement(`Preset ${name} saved`);
                    }
                }
                
                if (presetId) {
                    onSave(presetId);
                }
            };
            
            // Handle Escape key to close dialog
            useEffect(() => {
                const handleEscape = (e) => {
                    if (e.key === 'Escape') onCancel();
                };
                document.addEventListener('keydown', handleEscape);
                return () => document.removeEventListener('keydown', handleEscape);
            }, [onCancel]);
            
            return (
                <div 
                    className="dialog-overlay" 
                    onClick={onCancel}
                    role="dialog"
                    aria-modal="true"
                    aria-labelledby="dialog-title"
                >
                    <div 
                        className="dialog-content" 
                        onClick={(e) => e.stopPropagation()}
                        style={{
                            backgroundColor: 'var(--bg-primary)',
                            padding: '24px',
                            borderRadius: '12px',
                            maxWidth: '500px',
                            width: '90%',
                            maxHeight: '80vh',
                            overflow: 'auto'
                        }}
                    >
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
                            {/* React JSX automatically escapes user input, preventing XSS attacks */}
                            <h2 id="dialog-title" style={{ margin: 0 }}>
                                {existingPreset ? 'Edit Preset' : 'Save Custom Preset'}
                            </h2>
                            <button 
                                onClick={onCancel} 
                                aria-label="Close dialog" 
                                style={{
                                    background: 'none',
                                    border: 'none',
                                    fontSize: '24px',
                                    cursor: 'pointer',
                                    color: 'var(--text-secondary)'
                                }}
                            >
                                Ã—
                            </button>
                        </div>
                        
                        <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
                            {/* Preset Name */}
                            <label style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                <span style={{ fontWeight: '500', color: errors.name ? '#f87171' : 'inherit' }}>
                                    Preset Name *
                                </span>
                                <input 
                                    type="text" 
                                    value={name} 
                                    onChange={(e) => setName(e.target.value)} 
                                    placeholder="e.g., Deep Flow"
                                    maxLength={50}
                                    required
                                    autoFocus
                                    aria-invalid={!!errors.name}
                                    aria-describedby={errors.name ? 'name-error' : undefined}
                                    style={{
                                        padding: '8px 12px',
                                        borderRadius: '6px',
                                        border: `1px solid ${errors.name ? '#f87171' : 'var(--border)'}`,
                                        backgroundColor: 'var(--bg-secondary)',
                                        color: 'var(--text-primary)'
                                    }}
                                />
                                {errors.name && (
                                    <span id="name-error" style={{ color: '#f87171', fontSize: '0.875rem' }}>
                                        {errors.name}
                                    </span>
                                )}
                                <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', textAlign: 'right' }}>
                                    {name.length}/50
                                </span>
                            </label>
                            
                            {/* Description */}
                            <label style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                <span style={{ fontWeight: '500', color: errors.description ? '#f87171' : 'inherit' }}>
                                    Description (optional)
                                </span>
                                <textarea 
                                    value={description} 
                                    onChange={(e) => setDescription(e.target.value)} 
                                    placeholder="My perfect focus state"
                                    maxLength={200}
                                    rows={3}
                                    aria-invalid={!!errors.description}
                                    aria-describedby={errors.description ? 'desc-error' : undefined}
                                    style={{
                                        padding: '8px 12px',
                                        borderRadius: '6px',
                                        border: `1px solid ${errors.description ? '#f87171' : 'var(--border)'}`,
                                        backgroundColor: 'var(--bg-secondary)',
                                        color: 'var(--text-primary)',
                                        fontFamily: 'inherit',
                                        resize: 'vertical'
                                    }}
                                />
                                {errors.description && (
                                    <span id="desc-error" style={{ color: '#f87171', fontSize: '0.875rem' }}>
                                        {errors.description}
                                    </span>
                                )}
                                <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', textAlign: 'right' }}>
                                    {description.length}/200
                                </span>
                            </label>
                            
                            {/* Color Picker */}
                            <label style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                <span style={{ fontWeight: '500', color: errors.color ? '#f87171' : 'inherit' }}>
                                    Accent Color
                                </span>
                                <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
                                    <input 
                                        type="color" 
                                        value={color} 
                                        onChange={(e) => setColor(e.target.value)}
                                        style={{ width: '48px', height: '48px', cursor: 'pointer' }}
                                    />
                                    <input 
                                        type="text" 
                                        value={color} 
                                        onChange={(e) => setColor(e.target.value)} 
                                        placeholder="#6366f1"
                                        pattern="^#[0-9A-Fa-f]{6}$"
                                        aria-invalid={!!errors.color}
                                        aria-describedby={errors.color ? 'color-error' : undefined}
                                        style={{
                                            padding: '8px 12px',
                                            borderRadius: '6px',
                                            border: `1px solid ${errors.color ? '#f87171' : 'var(--border)'}`,
                                            backgroundColor: 'var(--bg-secondary)',
                                            color: 'var(--text-primary)',
                                            flex: 1
                                        }}
                                    />
                                </div>
                                {errors.color && (
                                    <span id="color-error" style={{ color: '#f87171', fontSize: '0.875rem' }}>
                                        {errors.color}
                                    </span>
                                )}
                            </label>
                            
                            {/* Parameter Preview */}
                            <div style={{ 
                                padding: '12px', 
                                borderRadius: '8px', 
                                backgroundColor: 'var(--bg-secondary)',
                                border: '1px solid var(--border)'
                            }}>
                                <h3 style={{ margin: '0 0 12px 0', fontSize: '0.875rem', fontWeight: '600' }}>
                                    Current Parameters
                                </h3>
                                <div style={{ 
                                    display: 'grid', 
                                    gridTemplateColumns: 'auto 1fr', 
                                    gap: '4px 12px',
                                    fontSize: '0.875rem'
                                }}>
                                    <dt style={{ fontWeight: '500', color: 'var(--text-secondary)' }}>Speed:</dt>
                                    <dd style={{ margin: 0 }}>{currentParameters.speed.toFixed(2)}</dd>
                                    
                                    <dt style={{ fontWeight: '500', color: 'var(--text-secondary)' }}>Intensity:</dt>
                                    <dd style={{ margin: 0 }}>{currentParameters.intensity.toFixed(2)}</dd>
                                    
                                    <dt style={{ fontWeight: '500', color: 'var(--text-secondary)' }}>Spatial Depth:</dt>
                                    <dd style={{ margin: 0 }}>{currentParameters.spatialDepth.toFixed(2)}</dd>
                                    
                                    <dt style={{ fontWeight: '500', color: 'var(--text-secondary)' }}>Movement:</dt>
                                    <dd style={{ margin: 0 }}>{currentParameters.movement}</dd>
                                    
                                    <dt style={{ fontWeight: '500', color: 'var(--text-secondary)' }}>Binaural:</dt>
                                    <dd style={{ margin: 0 }}>
                                        {currentParameters.binauralEnabled 
                                            ? `${currentParameters.binauralFreq} Hz (${getBinauralBand(currentParameters.binauralFreq)})` 
                                            : 'Off'}
                                    </dd>
                                    
                                    <dt style={{ fontWeight: '500', color: 'var(--text-secondary)' }}>Noise:</dt>
                                    <dd style={{ margin: 0 }}>
                                        {currentParameters.noiseType} @ {(currentParameters.noiseVolume * 100).toFixed(0)}%
                                    </dd>
                                </div>
                            </div>
                        </div>
                        
                        {/* Dialog Actions */}
                        <div style={{ display: 'flex', gap: '8px', marginTop: '20px', justifyContent: 'flex-end' }}>
                            <button 
                                onClick={onCancel} 
                                className="ghost-btn"
                            >
                                Cancel
                            </button>
                            <button 
                                onClick={handleSave} 
                                disabled={!name.trim()} 
                                className="primary-btn"
                            >
                                {existingPreset ? 'Update' : 'Save'} Preset
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // ============================================================
        // Story 3-3: PresetList Component
        // ============================================================

        const PresetList = ({
            presets,
            activePresetId,
            onSelect,
            onEdit,
            onDelete,
            onReorder
        }) => {
            const [draggedIndex, setDraggedIndex] = useState(null);

            const handleDragStart = (e, index) => {
                setDraggedIndex(index);
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleDragOver = (e, index) => {
                e.preventDefault();
                if (draggedIndex === null || draggedIndex === index) return;

                const newPresets = [...presets];
                const [removed] = newPresets.splice(draggedIndex, 1);
                newPresets.splice(index, 0, removed);

                onReorder(newPresets.map(p => p.id));
                setDraggedIndex(index);
            };

            const handleDragEnd = () => {
                setDraggedIndex(null);
            };

            const handlePresetKeyDown = (e, preset) => {
                // Handle Ctrl+ArrowUp/Down for reordering (AC5)
                if (e.ctrlKey && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
                    e.preventDefault();

                    const currentIndex = presets.findIndex(p => p.id === preset.id);
                    if (currentIndex === -1) return;

                    let newIndex;
                    if (e.key === 'ArrowUp') {
                        // Can't move above first custom preset (defaults are immutable)
                        const firstCustomIndex = presets.findIndex(p => !p.isDefault);
                        if (currentIndex <= firstCustomIndex) return;
                        newIndex = currentIndex - 1;
                    } else { // ArrowDown
                        if (currentIndex >= presets.length - 1) return;
                        newIndex = currentIndex + 1;
                    }

                    const newPresets = [...presets];
                    [newPresets[currentIndex], newPresets[newIndex]] = [newPresets[newIndex], newPresets[currentIndex]];
                    onReorder(newPresets.map(p => p.id));
                    return;
                }

                // Handle ArrowUp/Down for navigation (AC2)
                if (!e.ctrlKey && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
                    e.preventDefault();

                    // Find all focusable preset cards
                    const presetCards = Array.from(document.querySelectorAll('.preset-card[tabindex="0"]'));
                    const currentCard = e.currentTarget;
                    const currentCardIndex = presetCards.indexOf(currentCard);

                    if (currentCardIndex === -1) return;

                    let nextCard;
                    if (e.key === 'ArrowUp' && currentCardIndex > 0) {
                        nextCard = presetCards[currentCardIndex - 1];
                    } else if (e.key === 'ArrowDown' && currentCardIndex < presetCards.length - 1) {
                        nextCard = presetCards[currentCardIndex + 1];
                    }

                    if (nextCard) {
                        nextCard.focus();
                    }
                    return;
                }

                // Handle Enter to apply preset (AC2)
                if (e.key === 'Enter') {
                    e.preventDefault();
                    onSelect(preset.id);
                }
            };

            const formatLastUsed = (timestamp) => {
                if (!timestamp) return 'Never used';
                const hours = Math.floor((Date.now() - timestamp) / 1000 / 60 / 60);
                if (hours < 1) return 'Just now';
                if (hours < 24) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
                const days = Math.floor(hours / 24);
                return `${days} day${days > 1 ? 's' : ''} ago`;
            };

            return (
                <div className="preset-list-section" style={{ marginTop: '16px', paddingTop: '16px', borderTop: '1px solid var(--border)' }}>
                    <h3 style={{ fontSize: '0.875rem', fontWeight: '600', marginBottom: '12px', color: 'var(--text-secondary)' }}>
                        Your Custom Presets
                    </h3>

                    <div className="preset-list" role="list">
                        {presets.filter(p => !p.isDefault).length === 0 ? (
                            <div style={{
                                padding: '20px',
                                textAlign: 'center',
                                color: 'var(--text-secondary)',
                                backgroundColor: 'var(--bg-secondary)',
                                borderRadius: '8px',
                                fontSize: '0.875rem'
                            }}>
                                <p style={{ margin: '0 0 8px 0' }}>No custom presets yet.</p>
                                <p style={{ margin: 0 }}>Tweak parameters and click "Save Preset" to create your first!</p>
                            </div>
                        ) : (
                            presets.filter(p => !p.isDefault).map((preset, index) => (
                                <div
                                    key={preset.id}
                                    className={`preset-card ${preset.id === activePresetId ? 'active' : ''}`}
                                    role="listitem"
                                    tabIndex={0}
                                    draggable={true}
                                    onDragStart={(e) => handleDragStart(e, index)}
                                    onDragOver={(e) => handleDragOver(e, index)}
                                    onDragEnd={handleDragEnd}
                                    onKeyDown={(e) => handlePresetKeyDown(e, preset)}
                                    style={{
                                        '--accent-color': preset.color,
                                        marginBottom: '8px',
                                        padding: '12px',
                                        backgroundColor: preset.id === activePresetId ? 'var(--bg-secondary)' : 'var(--bg-primary)',
                                        border: `1px solid ${preset.id === activePresetId ? 'var(--accent)' : 'var(--border)'}`,
                                        borderRadius: '8px',
                                        cursor: 'grab',
                                        position: 'relative'
                                    }}
                                >
                                    <div style={{ display: 'flex', gap: '12px', alignItems: 'flex-start' }}>
                                        <div className="drag-handle" aria-label="Drag to reorder" style={{
                                            cursor: 'grab',
                                            color: 'var(--text-tertiary)',
                                            fontSize: '1rem',
                                            lineHeight: '1'
                                        }}>
                                            â‹®â‹®
                                        </div>

                                        <div style={{ flex: 1 }}>
                                            <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '4px' }}>
                                                <h4 style={{ margin: 0, fontSize: '0.875rem', fontWeight: '600' }}>{preset.name}</h4>
                                                {preset.id === activePresetId && (
                                                    <span style={{
                                                        fontSize: '0.75rem',
                                                        padding: '2px 6px',
                                                        backgroundColor: 'var(--accent)',
                                                        color: 'white',
                                                        borderRadius: '4px',
                                                        fontWeight: '500'
                                                    }}>
                                                        Active
                                                    </span>
                                                )}
                                                {preset.isDefault && (
                                                    <span style={{
                                                        fontSize: '0.75rem',
                                                        padding: '2px 6px',
                                                        backgroundColor: 'var(--border)',
                                                        color: 'var(--text-secondary)',
                                                        borderRadius: '4px',
                                                        fontWeight: '500'
                                                    }}>
                                                        Default
                                                    </span>
                                                )}
                                            </div>

                                            {preset.description && (
                                                <p style={{
                                                    margin: '4px 0',
                                                    fontSize: '0.8125rem',
                                                    color: 'var(--text-secondary)',
                                                    lineHeight: '1.4'
                                                }}>
                                                    {preset.description}
                                                </p>
                                            )}

                                            <div style={{
                                                display: 'flex',
                                                alignItems: 'center',
                                                justifyContent: 'space-between',
                                                marginTop: '8px'
                                            }}>
                                                <span style={{ fontSize: '0.75rem', color: 'var(--text-tertiary)' }}>
                                                    Last used: {formatLastUsed(preset.lastUsedAt)}
                                                </span>
                                                <div style={{ display: 'flex', gap: '6px' }}>
                                                    <button
                                                        className="ghost-btn"
                                                        style={{ fontSize: '0.75rem', padding: '4px 8px' }}
                                                        onClick={() => onSelect(preset.id)}
                                                        disabled={preset.id === activePresetId}
                                                    >
                                                        {preset.id === activePresetId ? 'âœ“ Active' : 'Apply'}
                                                    </button>
                                                    <button
                                                        onClick={() => onEdit(preset)}
                                                        aria-label={`Edit ${preset.name}`}
                                                        className="ghost-btn"
                                                        style={{ fontSize: '0.75rem', padding: '4px 8px' }}
                                                    >
                                                        âœï¸
                                                    </button>
                                                    <button
                                                        onClick={() => onDelete(preset.id)}
                                                        aria-label={`Delete ${preset.name}`}
                                                        className="ghost-btn"
                                                        style={{ fontSize: '0.75rem', padding: '4px 8px', color: '#ef4444' }}
                                                    >
                                                        ðŸ—‘ï¸
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            ))
                        )}
                    </div>
                </div>
            );
        };

function App() {
            const defaultMode = MODE_LIBRARY[0];
            const [playlist, setPlaylist] = useState([]);
            const [currentTrackIndex, setCurrentTrackIndex] = useState(null);
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentTime, setCurrentTime] = useState(0);
            const [duration, setDuration] = useState(0);
            const [volume, setVolume] = useState(0.7);
            const [showFileWarning, setShowFileWarning] = useState(false);
            
            // 8D Effect Controls
            const [speed, setSpeed] = useState(defaultMode.preset.speed);
            const [intensity, setIntensity] = useState(defaultMode.preset.intensity);
            const [spatialDepth, setSpatialDepth] = useState(defaultMode.preset.spatialDepth);
            const [movementPattern, setMovementPattern] = useState(defaultMode.preset.movement);
            
            // Additional Effects
            const [binauralEnabled, setBinauralEnabled] = useState(defaultMode.preset.binaural.enabled);
            const [binauralFreq, setBinauralFreq] = useState(defaultMode.preset.binaural.freq);
            const [noiseType, setNoiseType] = useState(defaultMode.preset.noise.type);
            const [noiseVolume, setNoiseVolume] = useState(defaultMode.preset.noise.volume);
            const [visualWaveGain, setVisualWaveGain] = useState(defaultMode.preset.noise.volume);
            
            // UI + Ritual
            const [darkMode, setDarkMode] = useState(false);
            const [highContrast, setHighContrast] = useState(false);
            const [urlInput, setUrlInput] = useState('');
            const [showVisualizer, setShowVisualizer] = useState(true);
            const [modeIndex, setModeIndex] = useState(0);
            const [focusedModeIndex, setFocusedModeIndex] = useState(0);
            const [activePresetId, setActivePresetId] = useState('focus'); // Story 3-1: Track active preset by ID
            const [ritualStatus, setRitualStatus] = useState('idle');
            const [ritualCountdown, setRitualCountdown] = useState(HERO_BREATH_DURATION);
            const [breathingPhase, setBreathingPhase] = useState(''); // 'inhale', 'hold-in', 'exhale', 'hold-out'
            const [skipRitualPref, setSkipRitualPref] = useState(() => {
                try {
                    return localStorage.getItem('skipBreathingRitual') === 'true';
                } catch {
                    return false;
                }
            });
            const [heroMessage, setHeroMessage] = useState('Select a ritual to begin');
            const [a11yAnnouncement, setA11yAnnouncement] = useState('');
            const [needsAudio, setNeedsAudio] = useState(false);
            const [intakeTab, setIntakeTab] = useState('files');
            const [isOnline, setIsOnline] = useState(typeof navigator !== 'undefined' ? navigator.onLine : true);
            const [reducedMotion, setReducedMotion] = useState(false);
            const [dragActive, setDragActive] = useState(false);
            const [audioElementToken, setAudioElementToken] = useState(0);
            
            // Story 3-2: Advanced Controls UI state
            const [isAdvancedControlsExpanded, setIsAdvancedControlsExpanded] = useState(false);
            const [sensorLocked, setSensorLocked] = useState(false); // Epic 5 adaptive mode
            
            // Story 3-3: Custom Preset Management
            const [showSavePresetDialog, setShowSavePresetDialog] = useState(false);
            const [editingPreset, setEditingPreset] = useState(null);
            const [allPresets, setAllPresets] = useState([]);

            // Spatial Audio Tuner (debugging tool)
            const [showSpatialTuner, setShowSpatialTuner] = useState(false);
            const spatialTunerActiveRef = useRef(false);

            // File intake notifications
            const [toastMessage, setToastMessage] = useState('');
            const [toastType, setToastType] = useState('info');
            const [isProcessingFiles, setIsProcessingFiles] = useState(false);
            const [isValidatingUrl, setIsValidatingUrl] = useState(false);

            const showToast = React.useCallback((message, type = 'info') => {
                if (toastTimeoutRef.current) {
                    clearTimeout(toastTimeoutRef.current);
                }

                setToastMessage(message);
                setToastType(type);
                setA11yAnnouncement(message);

                toastTimeoutRef.current = setTimeout(() => {
                    setToastMessage('');
                    toastTimeoutRef.current = null;
                }, 5000);
            }, []);

            const [activeSessionId, setActiveSessionId] = useState(null);
            const [isClearingSessions, setIsClearingSessions] = useState(false);
            const [isTrimmingSessions, setIsTrimmingSessions] = useState(false);
            
            const selectedMode = MODE_LIBRARY[modeIndex];
            const nowPlayingTrack = currentTrackIndex !== null ? playlist[currentTrackIndex] : null;
            const playlistMinutes = Math.max(0, Math.floor(playlist.length * 3.5));
            const focusConfidence = Math.min(100, 60 + playlist.length * 8);
            const streakMinutes = Math.min(21, playlist.length * 2);
            
            // Refs
            const audioContextRef = useRef(null);
            const sourceNodeRef = useRef(null);
            const gainNodeRef = useRef(null);
            const audioElementRef = useRef(null);
            const audioEndedHandlerRef = useRef(null);
            const currentBlobUrlRef = useRef(null);
            const fileInputRef = useRef(null);
            const canvasRef = useRef(null);
            const analyserRef = useRef(null);
            const animationFrameRef = useRef(null);
            const rotationIntervalRef = useRef(null);
            const rotationNodesRef = useRef(null);
            const modeRefs = useRef([]);
            const dropZoneRef = useRef(null);
            const ritualTimeoutRef = useRef(null);
            const ritualIntervalRef = useRef(null);
            const breathingPhaseIntervalRef = useRef(null);
            const gainChainRef = useRef(null);
            const binauralNodesRef = useRef(null);
            const noiseNodesRef = useRef(null);
            const visualWaveGainRef = useRef(visualWaveGain);
            const playlistRef = useRef(playlist);
            const currentTrackIndexRef = useRef(currentTrackIndex);
            const playNextRef = useRef(() => {});
            const prevPlaylistLengthRef = useRef(playlist.length);
            const urlValidationControllerRef = useRef(null);
            const toastTimeoutRef = useRef(null);
            const activeSessionIdRef = useRef(null);
            const sessionRitualFlagRef = useRef(false);

            // Audio parameter refs - allows rotation interval to read current values
            const speedRef = useRef(speed);
            const intensityRef = useRef(intensity);
            const spatialDepthRef = useRef(spatialDepth);
            const movementPatternRef = useRef(movementPattern);

            const cleanupBlobUrl = () => {
                if (currentBlobUrlRef.current) {
                    URL.revokeObjectURL(currentBlobUrlRef.current);
                    currentBlobUrlRef.current = null;
                }
            };

            const tearDownBinauralNodes = () => {
                if (binauralNodesRef.current) {
                    binauralNodesRef.current.stop();
                    binauralNodesRef.current = null;
                }
            };

            const tearDownNoiseNodes = () => {
                if (noiseNodesRef.current) {
                    noiseNodesRef.current.stop();
                    noiseNodesRef.current = null;
                }
            };

            const disposeAudioGraph = () => {
                if (rotationIntervalRef.current) {
                    clearInterval(rotationIntervalRef.current);
                    rotationIntervalRef.current = null;
                }
                rotationNodesRef.current = null;

                tearDownBinauralNodes();
                tearDownNoiseNodes();

                if (animationFrameRef.current) {
                    cancelAnimationFrame(animationFrameRef.current);
                    animationFrameRef.current = null;
                }

                if (gainChainRef.current) {
                    gainChainRef.current.disconnect();
                    gainChainRef.current = null;
                }
                gainNodeRef.current = null;
                analyserRef.current = null;

                if (sourceNodeRef.current) {
                    try {
                        sourceNodeRef.current.disconnect();
                    } catch (error) {
                        console.error('Error disconnecting source node:', error);
                    }
                    sourceNodeRef.current = null;
                }
            };

            const teardownAudioElement = () => {
                if (audioElementRef.current) {
                    const audio = audioElementRef.current;
                    if (audioEndedHandlerRef.current) {
                        audio.removeEventListener('ended', audioEndedHandlerRef.current);
                        audioEndedHandlerRef.current = null;
                    }
                    audio.pause();
                    audio.removeAttribute('src');
                    audio.load();
                    audioElementRef.current = null;
                }
                cleanupBlobUrl();
            };

            const prepareAudioElement = () => {
                teardownAudioElement();
                const audio = new Audio();
                audio.preload = 'auto';
                audio.crossOrigin = 'anonymous';
                audioElementRef.current = audio;
                audioEndedHandlerRef.current = () => {
                    cleanupBlobUrl();
                    endSession(false);
                    if (typeof playNextRef.current === 'function') {
                        playNextRef.current({ shouldEndActiveSession: false });
                    }
                };
                audio.addEventListener('ended', audioEndedHandlerRef.current);
                setAudioElementToken(Date.now());
                return audio;
            };

            const syncBinauralChain = () => {
                tearDownBinauralNodes();
                if (!binauralEnabled || !audioContextRef.current || !gainChainRef.current) {
                    return;
                }
                binauralNodesRef.current = AudioEngine.createBinauralNodes(
                    audioContextRef.current,
                    gainChainRef.current.mainGain,
                    binauralFreq
                );
            };

            const syncNoiseLayer = () => {
                tearDownNoiseNodes();
                if (
                    noiseType === 'none' ||
                    !audioContextRef.current ||
                    !gainChainRef.current
                ) {
                    return;
                }
                noiseNodesRef.current = AudioEngine.createNoiseNode(
                    audioContextRef.current,
                    gainChainRef.current.mainGain,
                    noiseType,
                    noiseVolume
                );
            };

            const clearRitualTimers = () => {
                if (ritualIntervalRef.current) {
                    clearInterval(ritualIntervalRef.current);
                    ritualIntervalRef.current = null;
                }
                if (ritualTimeoutRef.current) {
                    clearTimeout(ritualTimeoutRef.current);
                    ritualTimeoutRef.current = null;
                }
                if (breathingPhaseIntervalRef.current) {
                    clearInterval(breathingPhaseIntervalRef.current);
                    breathingPhaseIntervalRef.current = null;
                }
            };

            useEffect(() => {
                audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();

                if (window.location.protocol === 'file:') {
                    setShowFileWarning(true);
                }

                const savedDarkMode = localStorage.getItem('darkMode');
                const prefersDark = savedDarkMode === null ? true : savedDarkMode === 'true';
                setDarkMode(prefersDark);
                document.body.classList.toggle('dark-mode', prefersDark);
                if (savedDarkMode === null) {
                    localStorage.setItem('darkMode', 'true');
                }

                const savedHighContrast = localStorage.getItem('highContrast');
                if (savedHighContrast === 'true') {
                    setHighContrast(true);
                    document.body.classList.add('high-contrast');
                }

                const savedReducedMotion = localStorage.getItem('reducedMotion');
                if (savedReducedMotion === 'true') {
                    setReducedMotion(true);
                }

                // Story 3-1: Load saved active preset with validation
                const savedActivePreset = localStorage.getItem('activePresetId');
                if (savedActivePreset) {
                    const presetExists = MODE_LIBRARY.some(m => m.id === savedActivePreset);
                    setActivePresetId(presetExists ? savedActivePreset : 'focus');
                }

                const savedPlaylist = localStorage.getItem('playlist');
                if (savedPlaylist) {
                    try {
                        const parsed = JSON.parse(savedPlaylist);
                        const filtered = parsed.filter((track) => track && track.source !== 'local' && track.url);
                        setPlaylist(filtered);
                    } catch (error) {
                        console.error('Error loading saved playlist:', error);
                    }
                }

                const handleOnline = () => setIsOnline(true);
                const handleOffline = () => setIsOnline(false);
                window.addEventListener('online', handleOnline);
                window.addEventListener('offline', handleOffline);

                return () => {
                    window.removeEventListener('online', handleOnline);
                    window.removeEventListener('offline', handleOffline);
                    endSession(true);
                    disposeAudioGraph();
                    teardownAudioElement();
                    if (audioContextRef.current) {
                        audioContextRef.current.close();
                    }
                    clearRitualTimers();
                };
            }, []);

            // Story 3-3: Load all presets on mount
            useEffect(() => {
                const presets = getAllPresets();
                setAllPresets(presets);
                console.log('[PresetManagement] Loaded', presets.length, 'presets');
            }, []);

            // Cleanup URL validation on unmount
            useEffect(() => {
                // Initialize controller ref
                urlValidationControllerRef.current = {};
                
                return () => {
                    // Mark component as unmounted to prevent setState after unmount
                    urlValidationControllerRef.current = null;
                    
                    // Clear any pending toast timeout
                    if (toastTimeoutRef.current) {
                        clearTimeout(toastTimeoutRef.current);
                        toastTimeoutRef.current = null;
                    }
                };
            }, []);

            useEffect(() => {
                const sessionApi = getSessionLoggingApi();
                if (!sessionApi) {
                    console.warn('[SessionLogger] IndexedDB unavailable â€” session logging disabled.');
                    return;
                }
                let canceled = false;
                sessionApi.initDatabase().catch((error) => {
                    if (canceled) {
                        return;
                    }
                    console.error('[SessionLogger] Initialization failed:', error);
                    showToast('Session logging unavailable. See console for details.', 'warning');
                });

                window.SessionLogger = {
                    clearProfile: clearProfileSessions,
                    clearSessionsOlderThanDays,
                    exportSessions: (startDate, endDate) => sessionApi.getSessionsByDateRange(startDate, endDate)
                };

                return () => {
                    canceled = true;
                    delete window.SessionLogger;
                };
            }, [clearProfileSessions, clearSessionsOlderThanDays, showToast]);

            // Story 3-1: Persist active preset selection
            useEffect(() => {
                try {
                    localStorage.setItem('activePresetId', activePresetId);
                } catch (err) {
                    console.error('Failed to persist activePresetId:', err);
                }
            }, [activePresetId]);

            // Story 3-1: Apply preset parameters when activePresetId changes
            useEffect(() => {
                const preset = MODE_LIBRARY.find(m => m.id === activePresetId);
                if (preset) {
                    setSpeed(preset.preset.speed);
                    setIntensity(preset.preset.intensity);
                    setSpatialDepth(preset.preset.spatialDepth);
                    setMovementPattern(preset.preset.movement);
                    setBinauralEnabled(preset.preset.binaural.enabled);
                    setBinauralFreq(preset.preset.binaural.freq);
                    setNoiseType(preset.preset.noise.type);
                    setNoiseVolume(preset.preset.noise.volume);
                    setVisualWaveGain(preset.preset.noise.volume);
                }
            }, [activePresetId]);

            useEffect(() => {
                const serialized = playlist
                    .filter((track) => track.source !== 'local' && track.url)
                    .map((track) => ({
                        id: track.id,
                        name: track.name,
                        source: track.source,
                        url: track.url,
                        originalUrl: track.originalUrl || null
                    }));
                if (serialized.length > 0) {
                    localStorage.setItem('playlist', JSON.stringify(serialized));
                } else {
                    localStorage.removeItem('playlist');
                }
            }, [playlist]);

            useEffect(() => {
                const prevLength = prevPlaylistLengthRef.current;
                const isEmpty = playlist.length === 0;

                if (isEmpty) {
                    if (currentTrackIndex !== null) {
                        currentTrackIndexRef.current = null;
                        setCurrentTrackIndex(null);
                    }
                    teardownAudioElement();
                    disposeAudioGraph();
                    setIsPlaying(false);
                    if (prevLength !== 0) {
                        setHeroMessage('Playlist empty. Add audio to start a ritual.');
                        setNeedsAudio(true);
                        setRitualStatus('idle');
                        setRitualCountdown(HERO_BREATH_DURATION);
                        clearRitualTimers();
                    }
                } else if (currentTrackIndex !== null && currentTrackIndex >= playlist.length) {
                    const clampedIndex = Math.max(playlist.length - 1, 0);
                    currentTrackIndexRef.current = clampedIndex;
                    setCurrentTrackIndex(clampedIndex);
                }

                prevPlaylistLengthRef.current = playlist.length;
                playlistRef.current = playlist;
            }, [playlist.length, currentTrackIndex]);

            useEffect(() => {
                playlistRef.current = playlist;
            }, [playlist]);

            useEffect(() => {
                currentTrackIndexRef.current = currentTrackIndex;
            }, [currentTrackIndex]);

            // Keep audio parameter refs in sync with state for rotation interval
            useEffect(() => { speedRef.current = speed; }, [speed]);
            useEffect(() => { intensityRef.current = intensity; }, [intensity]);
            useEffect(() => { spatialDepthRef.current = spatialDepth; }, [spatialDepth]);
            useEffect(() => { movementPatternRef.current = movementPattern; }, [movementPattern]);
            useEffect(() => { spatialTunerActiveRef.current = showSpatialTuner; }, [showSpatialTuner]);

            // Clear accessibility announcements after 3 seconds to prevent re-announcements
            useEffect(() => {
                if (a11yAnnouncement) {
                    const timer = setTimeout(() => {
                        setA11yAnnouncement('');
                    }, 3000);
                    return () => clearTimeout(timer);
                }
            }, [a11yAnnouncement]);

            // Story 3-2: Keyboard shortcut (Ctrl+E) to toggle advanced controls
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'e') {
                        e.preventDefault();
                        setIsAdvancedControlsExpanded(prev => !prev);
                        setA11yAnnouncement(
                            isAdvancedControlsExpanded 
                                ? 'Advanced controls collapsed' 
                                : 'Advanced controls expanded'
                        );
                    }
                };
                
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [isAdvancedControlsExpanded]);

            useEffect(() => {
                const audio = audioElementRef.current;
                if (!audio) {
                    return;
                }
                const handleTimeUpdate = () => {
                    setCurrentTime(audio.currentTime || 0);
                    setDuration(audio.duration || 0);
                };
                audio.addEventListener('timeupdate', handleTimeUpdate);
                audio.addEventListener('loadedmetadata', handleTimeUpdate);
                return () => {
                    audio.removeEventListener('timeupdate', handleTimeUpdate);
                    audio.removeEventListener('loadedmetadata', handleTimeUpdate);
                };
            }, [audioElementToken]);

            const toggleDarkMode = () => {
                const next = !darkMode;
                setDarkMode(next);
                document.body.classList.toggle('dark-mode', next);
                localStorage.setItem('darkMode', String(next));
                setA11yAnnouncement(next ? 'Dark mode enabled' : 'Light mode enabled');
            };

            const toggleHighContrast = () => {
                const next = !highContrast;
                setHighContrast(next);
                document.body.classList.toggle('high-contrast', next);
                try {
                    if (next) {
                        localStorage.setItem('highContrast', 'true');
                    } else {
                        localStorage.removeItem('highContrast');
                    }
                } catch (e) {
                    console.warn('Failed to persist high-contrast preference', e);
                }
                setA11yAnnouncement(next ? 'High contrast mode enabled' : 'High contrast mode disabled');
            };

            const toggleReducedMotion = () => {
                const next = !reducedMotion;
                setReducedMotion(next);
                try {
                    if (next) {
                        localStorage.setItem('reducedMotion', 'true');
                    } else {
                        localStorage.removeItem('reducedMotion');
                    }
                } catch (e) {
                    console.warn('Failed to persist reduced-motion preference', e);
                }
                setA11yAnnouncement(next ? 'Reduced motion enabled' : 'Motion enabled');
            };

            const focusModeChip = (index) => {
                const total = MODE_LIBRARY.length;
                const normalized = ((index % total) + total) % total;
                setFocusedModeIndex(normalized);
                requestAnimationFrame(() => {
                    const chip = modeRefs.current[normalized];
                    if (chip) {
                        chip.focus();
                    }
                });
                return normalized;
            };

            // Story 3-1: Log preset changes for Epic 4 session tracking
            const logPresetChange = (newPresetId) => {
                const event = {
                    event: 'PRESET_CHANGED',
                    presetId: newPresetId,
                    previousPresetId: activePresetId,
                    timestamp: Date.now(),
                    trackId: currentTrackIndex !== null ? playlist[currentTrackIndex].id : null
                };
                console.log('[SessionLogger]', event);
                // E4 integration point - future: dispatch to IndexedDB logger
                // window.dispatchEvent(new CustomEvent('preset-changed', { detail: event }));
            };

            // Story 3-2: Epic 5 API for adaptive mode (sensor lock)
            const enableSensorMode = () => {
                setSensorLocked(true);
                setA11yAnnouncement('Adaptive mode enabled. Controls locked.');
                showToast('Adaptive mode active', 'info');
            };

            const disableSensorMode = () => {
                setSensorLocked(false);
                setA11yAnnouncement('Adaptive mode disabled. Controls unlocked.');
                showToast('Manual control restored', 'info');
            };

            // Expose API for Epic 5 integration
            useEffect(() => {
                window.audioControlsAPI = {
                    enableSensorMode,
                    disableSensorMode
                };
                return () => {
                    delete window.audioControlsAPI;
                };
            }, []);

            // ============================================================
            // Story 3-3: Custom Preset Management Handlers
            // ============================================================
            
            const openSavePresetDialog = () => {
                setEditingPreset(null);
                setShowSavePresetDialog(true);
            };

            const openEditPresetDialog = (preset) => {
                setEditingPreset(preset);
                setShowSavePresetDialog(true);
            };

            const closeSavePresetDialog = () => {
                setShowSavePresetDialog(false);
                setEditingPreset(null);
            };

            const handleSavePreset = (presetId) => {
                // Apply the newly saved/edited preset
                const presets = getAllPresets();
                setAllPresets(presets);
                
                const preset = presets.find(p => p.id === presetId);
                if (preset) {
                    applyPreset(preset.preset, preset.id);
                }
                
                closeSavePresetDialog();
            };

            const handleDeletePreset = (presetId) => {
                // Check how many tracks use this preset
                const tracksUsingPreset = playlist.filter(t => t.lastPresetId === presetId).length;

                let confirmMessage = 'Delete this preset? This cannot be undone.';
                if (tracksUsingPreset > 0) {
                    confirmMessage = `âš ï¸ This preset is used by ${tracksUsingPreset} track(s).\n\nThey will reset to the default Focus preset.\n\nDelete this preset? This cannot be undone.`;
                }

                if (!confirm(confirmMessage)) {
                    return;
                }

                const result = deleteCustomPreset(presetId, showToast);
                if (result) {
                    showToast(`Preset "${result.name}" deleted`, 'success');
                    setA11yAnnouncement(`Preset ${result.name} deleted`);
                    
                    // Update all presets list
                    const presets = getAllPresets();
                    setAllPresets(presets);
                    
                    // Update tracks using this preset to fallback to focus
                    setPlaylist(prev => prev.map(track => ({
                        ...track,
                        lastPresetId: track.lastPresetId === presetId ? 'focus' : track.lastPresetId
                    })));
                    
                    // If deleted preset was active, switch to focus
                    if (activePresetId === presetId) {
                        const focusMode = MODE_LIBRARY[0];
                        applyPreset(focusMode.preset, focusMode.id);
                        showToast('Switched to Focus preset', 'info');
                    }
                }
            };

            const handleQuickApplyPreset = (preset) => {
                applyPreset(preset.preset, preset.id);
                showToast(`Applied ${preset.name} preset`, 'success');
                setA11yAnnouncement(`${preset.name} preset applied`);
            };

            const handleReorderPresets = (newOrder) => {
                savePresetOrder(newOrder);
                // Reload all presets to reflect new order
                const presets = getAllPresets();
                setAllPresets(presets);
            };

            const setActiveMode = (index) => {
                const normalized = focusModeChip(index);
                const mode = MODE_LIBRARY[normalized];
                setModeIndex(normalized);
                applyPreset(mode.preset, mode.id);
                setHeroMessage(`${mode.label} preset queued. Press Start to begin.`);
                setA11yAnnouncement(`${mode.label} mode selected`);
            };

            const handleModeKeyDown = (event, index) => {
                const { key } = event;
                if (key === 'ArrowRight' || key === 'ArrowDown') {
                    event.preventDefault();
                    focusModeChip(index + 1);
                    return;
                }
                if (key === 'ArrowLeft' || key === 'ArrowUp') {
                    event.preventDefault();
                    focusModeChip(index - 1);
                    return;
                }
                if (key === 'Home') {
                    event.preventDefault();
                    focusModeChip(0);
                    return;
                }
                if (key === 'End') {
                    event.preventDefault();
                    focusModeChip(MODE_LIBRARY.length - 1);
                    return;
                }
                if (key === 'Enter' || key === ' ' || key === 'Spacebar') {
                    event.preventDefault();
                    setActiveMode(index);
                }
            };

            const setupAudioGraph = (audioElement) => {
                const context = audioContextRef.current;
                if (!context) return;

                if (context.state === 'suspended') {
                    context.resume();
                }

                disposeAudioGraph();

                const source = context.createMediaElementSource(audioElement);
                sourceNodeRef.current = source;

                const splitter = context.createChannelSplitter(2);
                const merger = context.createChannelMerger(2);

                const leftToLeftGain = context.createGain();
                const leftToRightGain = context.createGain();
                const rightToLeftGain = context.createGain();
                const rightToRightGain = context.createGain();

                const delayLeft = context.createDelay();
                const delayRight = context.createDelay();
                delayLeft.delayTime.value = 0.05;
                delayRight.delayTime.value = 0.05;

                const delayGainLeft = context.createGain();
                const delayGainRight = context.createGain();
                delayGainLeft.gain.value = 0.05 * spatialDepth;
                delayGainRight.gain.value = 0.05 * spatialDepth;

                const crossDelayLeft = context.createDelay();
                const crossDelayRight = context.createDelay();
                crossDelayLeft.delayTime.value = 0.03;
                crossDelayRight.delayTime.value = 0.03;

                const crossGainLeft = context.createGain();
                const crossGainRight = context.createGain();
                crossGainLeft.gain.value = 0.03 * spatialDepth;
                crossGainRight.gain.value = 0.03 * spatialDepth;

                // ITD (Inter-aural Time Difference) delay nodes
                // Max ITD is ~0.7ms (0.0007s) when sound is directly to one side
                const itdDelayLeft = context.createDelay(0.001); // max 1ms
                const itdDelayRight = context.createDelay(0.001);
                itdDelayLeft.delayTime.value = 0;
                itdDelayRight.delayTime.value = 0;

                // Low-pass filters for "head shadow" effect
                // High frequencies are blocked more by the head, making sounds behind/opposite darker
                const lpFilterLeft = context.createBiquadFilter();
                const lpFilterRight = context.createBiquadFilter();
                lpFilterLeft.type = 'lowpass';
                lpFilterRight.type = 'lowpass';
                lpFilterLeft.frequency.value = 20000; // Start fully open
                lpFilterRight.frequency.value = 20000;
                lpFilterLeft.Q.value = 0.7; // Gentle rolloff
                lpFilterRight.Q.value = 0.7;

                rotationNodesRef.current = {
                    leftToLeftGain,
                    leftToRightGain,
                    rightToLeftGain,
                    rightToRightGain,
                    delayGainLeft,
                    delayGainRight,
                    crossGainLeft,
                    crossGainRight,
                    itdDelayLeft,
                    itdDelayRight,
                    lpFilterLeft,
                    lpFilterRight
                };

                source.connect(splitter);

                splitter.connect(leftToLeftGain, 0);
                splitter.connect(leftToRightGain, 0);
                splitter.connect(rightToLeftGain, 1);
                splitter.connect(rightToRightGain, 1);

                // Route through ITD delays and low-pass filters before merger
                // Left channel: gains -> ITD delay -> low-pass filter -> merger
                leftToLeftGain.connect(itdDelayLeft);
                rightToLeftGain.connect(itdDelayLeft);
                itdDelayLeft.connect(lpFilterLeft);
                lpFilterLeft.connect(merger, 0, 0);

                // Right channel: gains -> ITD delay -> low-pass filter -> merger
                rightToRightGain.connect(itdDelayRight);
                leftToRightGain.connect(itdDelayRight);
                itdDelayRight.connect(lpFilterRight);
                lpFilterRight.connect(merger, 0, 1);

                leftToLeftGain.connect(delayLeft);
                delayLeft.connect(delayGainLeft);
                delayGainLeft.connect(merger, 0, 0);

                rightToRightGain.connect(delayRight);
                delayRight.connect(delayGainRight);
                delayGainRight.connect(merger, 0, 1);

                leftToLeftGain.connect(crossDelayRight);
                crossDelayRight.connect(crossGainRight);
                crossGainRight.connect(merger, 0, 1);

                rightToRightGain.connect(crossDelayLeft);
                crossDelayLeft.connect(crossGainLeft);
                crossGainLeft.connect(merger, 0, 0);

                const gainChain = AudioEngine.connectGainStaging(context, merger, {
                    volume,
                    fftSize: 2048
                });

                gainChainRef.current = gainChain;
                gainNodeRef.current = gainChain.mainGain;
                analyserRef.current = gainChain.analyser;

                syncBinauralChain();
                syncNoiseLayer();

                startRotation();

                if (showVisualizer) {
                    visualize();
                }
            };

            // Apply gains directly from Spatial Tuner (bypasses rotation interval)
            const applyTunerGains = React.useCallback((leftGain, rightGain, crossGain, itdLeftDelay = 0, itdRightDelay = 0, leftFilterFreq = 20000, rightFilterFreq = 20000) => {
                const nodes = rotationNodesRef.current;
                const ctx = audioContextRef.current;
                if (!nodes || !ctx) return;

                const clamp = (val) => Math.max(0.0001, Math.min(1, val));
                const now = ctx.currentTime;
                const rampTime = now + 0.05; // Fast 50ms ramp

                // Apply the gains directly
                if (nodes.leftToLeftGain) {
                    nodes.leftToLeftGain.gain.setValueAtTime(clamp(nodes.leftToLeftGain.gain.value), now);
                    nodes.leftToLeftGain.gain.exponentialRampToValueAtTime(clamp(leftGain * 0.5), rampTime);
                }
                if (nodes.rightToRightGain) {
                    nodes.rightToRightGain.gain.setValueAtTime(clamp(nodes.rightToRightGain.gain.value), now);
                    nodes.rightToRightGain.gain.exponentialRampToValueAtTime(clamp(rightGain * 0.5), rampTime);
                }
                // Cross-channel (near zero for hard pan)
                if (nodes.leftToRightGain) {
                    nodes.leftToRightGain.gain.setValueAtTime(clamp(nodes.leftToRightGain.gain.value), now);
                    nodes.leftToRightGain.gain.exponentialRampToValueAtTime(clamp(crossGain), rampTime);
                }
                if (nodes.rightToLeftGain) {
                    nodes.rightToLeftGain.gain.setValueAtTime(clamp(nodes.rightToLeftGain.gain.value), now);
                    nodes.rightToLeftGain.gain.exponentialRampToValueAtTime(clamp(crossGain), rampTime);
                }

                // Apply ITD (Inter-aural Time Difference) delays
                // Sound on right = delay left ear, sound on left = delay right ear
                if (nodes.itdDelayLeft) {
                    nodes.itdDelayLeft.delayTime.setValueAtTime(nodes.itdDelayLeft.delayTime.value, now);
                    nodes.itdDelayLeft.delayTime.linearRampToValueAtTime(Math.min(0.001, itdLeftDelay), rampTime);
                }
                if (nodes.itdDelayRight) {
                    nodes.itdDelayRight.delayTime.setValueAtTime(nodes.itdDelayRight.delayTime.value, now);
                    nodes.itdDelayRight.delayTime.linearRampToValueAtTime(Math.min(0.001, itdRightDelay), rampTime);
                }

                // Apply low-pass filter frequencies for "head shadow" effect
                // This makes sounds darker/muffled when behind or on opposite side
                if (nodes.lpFilterLeft) {
                    nodes.lpFilterLeft.frequency.setValueAtTime(nodes.lpFilterLeft.frequency.value, now);
                    nodes.lpFilterLeft.frequency.exponentialRampToValueAtTime(Math.max(200, leftFilterFreq), rampTime);
                }
                if (nodes.lpFilterRight) {
                    nodes.lpFilterRight.frequency.setValueAtTime(nodes.lpFilterRight.frequency.value, now);
                    nodes.lpFilterRight.frequency.exponentialRampToValueAtTime(Math.max(200, rightFilterFreq), rampTime);
                }
            }, []);

            const startRotation = () => {
                if (rotationIntervalRef.current) {
                    clearInterval(rotationIntervalRef.current);
                }
                if (!rotationNodesRef.current) {
                    return;
                }
                
                let time = 0;
                // Use a slightly longer interval to allow meaningful ramps (avoid overlapping automation)
                const ROTATION_INTERVAL_MS = 100; // 100ms ticks
                rotationIntervalRef.current = setInterval(() => {
                    // Skip rotation when Spatial Tuner is active (tuner controls audio directly)
                    if (spatialTunerActiveRef.current) {
                        return;
                    }

                    const nodes = rotationNodesRef.current;
                    const ctx = audioContextRef.current;
                    if (
                        !nodes ||
                        !ctx ||
                        !nodes.leftToLeftGain ||
                        !nodes.leftToRightGain ||
                        !nodes.rightToLeftGain ||
                        !nodes.rightToRightGain
                    ) {
                        return;
                    }
                    
                    // Read current values from refs (not stale closure)
                    const currentSpeed = speedRef.current;
                    const currentMovement = movementPatternRef.current;
                    const currentIntensity = intensityRef.current;
                    const currentSpatialDepth = spatialDepthRef.current;

                    const angle = 2 * Math.PI * currentSpeed * time;
                    let panPosition = 0;

                    // Calculate pan position based on movement pattern
                    switch(currentMovement) {
                        case 'circle':
                            panPosition = Math.sin(angle);
                            break;
                        case 'figure8':
                            // True figure-8: Loop on right side, then loop on left side
                            // Creates the sensation of sound tracing an "8" around your head
                            const f8Cycle = ((angle / (2 * Math.PI)) % 1 + 1) % 1; // 0 to 1, normalized
                            if (f8Cycle < 0.5) {
                                // Right side loop: center â†’ full right â†’ center
                                const rightPhase = f8Cycle * 2; // 0 to 1
                                panPosition = Math.sin(rightPhase * Math.PI); // 0 â†’ 1 â†’ 0
                            } else {
                                // Left side loop: center â†’ full left â†’ center
                                const leftPhase = (f8Cycle - 0.5) * 2; // 0 to 1
                                panPosition = -Math.sin(leftPhase * Math.PI); // 0 â†’ -1 â†’ 0
                            }
                            // Add subtle depth variation (quieter at the "crossing point" of the 8)
                            const f8DepthPhase = Math.abs(Math.sin(f8Cycle * 2 * Math.PI));
                            window._quadrantDepthMultiplier = 0.7 + 0.3 * f8DepthPhase; // 0.7 to 1.0
                            break;
                        case 'leftright':
                            panPosition = Math.sin(angle);
                            break;
                        case 'frontback':
                            panPosition = Math.cos(angle) * 0.5;
                            break;
                        case 'random':
                            if (Math.random() > 0.9) {
                                panPosition = (Math.random() * 2 - 1);
                            }
                            break;
                        case 'quadrant':
                            // 360-degree circular sound: Right -> Back(quiet) -> Left -> Front -> repeat
                            // Creates immersive feeling of sound orbiting around your head
                            const fullCycle = (angle / (2 * Math.PI)); // cycles (may be >1)
                            const cyclePos = fullCycle - Math.floor(fullCycle); // 0..1 within cycle
                            const segment = Math.floor(cyclePos * 4); // 0=right, 1=back, 2=left, 3=front
                            const segmentPhase = (cyclePos * 4) - segment; // 0..1 within segment

                            // Pan positions: Right(1) -> Center(0) -> Left(-1) -> Center(0)
                            const panAnchors = [1, 0, -1, 0];
                            const panA = panAnchors[segment];
                            const panB = panAnchors[(segment + 1) % panAnchors.length];

                            // Depth/volume multipliers: Right(1.0) -> Back(0.55) -> Left(1.0) -> Front(1.0)
                            // Back position is quieter to simulate sound being behind your head
                            const depthAnchors = [1.0, 0.55, 1.0, 1.0];
                            const depthA = depthAnchors[segment];
                            const depthB = depthAnchors[(segment + 1) % depthAnchors.length];

                            // Smooth easing for more natural circular motion (ease-in-out)
                            const easeInOut = (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                            const smoothPhase = easeInOut(segmentPhase);

                            // Interpolate pan position with easing
                            panPosition = panA + (panB - panA) * smoothPhase;

                            // Store depth multiplier for gain calculation (accessed below)
                            // Using a variable name that won't conflict
                            window._quadrantDepthMultiplier = depthA + (depthB - depthA) * smoothPhase;
                            break;
                        default:
                            panPosition = Math.sin(angle);
                    }
                    
                    // Apply intensity to pan position
                    panPosition *= currentIntensity;
                    
                    // CRITICAL FIX: Normalized gain distribution to prevent clipping
                    // Total energy must equal 1.0 to prevent gain accumulation
                    const normalizationFactor = 0.5; // Base gain per channel before panning

                    // Quadrant uses HARD panning (no cross-channel) for clear L/R separation
                    const isHardPan = currentMovement === 'quadrant';
                    const crossChannelMix = isHardPan ? 0 : 0.15; // Zero bleeding for quadrant

                    // For 'quadrant' and 'figure8' patterns, apply depth simulation
                    // Creates immersive 3D sound by varying volume based on perceived position
                    const use3DDepth = currentMovement === 'quadrant' || currentMovement === 'figure8';
                    const depthGainMultiplier = use3DDepth
                        ? (window._quadrantDepthMultiplier || 1.0)
                        : 1.0;

                    // Main channel gains - Quadrant uses hard panning for maximum separation
                    let leftChannelGain, rightChannelGain;
                    if (isHardPan) {
                        // HARD PAN: When right, left is silent. When left, right is silent.
                        // panPosition: -1 = full left, 0 = center, +1 = full right
                        if (panPosition > 0.1) {
                            // Panning right: left ear gets less/none
                            leftChannelGain = Math.max(0, 1 - panPosition * 2); // Drops to 0 at pan=0.5+
                            rightChannelGain = 1;
                        } else if (panPosition < -0.1) {
                            // Panning left: right ear gets less/none
                            leftChannelGain = 1;
                            rightChannelGain = Math.max(0, 1 + panPosition * 2); // Drops to 0 at pan=-0.5+
                        } else {
                            // Center (back/front): both ears equal
                            leftChannelGain = 0.5;
                            rightChannelGain = 0.5;
                        }
                    } else {
                        // Standard soft panning for other patterns
                        leftChannelGain = (1 - panPosition) * 0.5; // 0.0 to 1.0
                        rightChannelGain = (1 + panPosition) * 0.5; // 0.0 to 1.0
                    }

                    // Apply depth multiplier for 3D spatial patterns
                    const targetLeftGain = Math.max(0.001, leftChannelGain * normalizationFactor * depthGainMultiplier);
                    const targetRightGain = Math.max(0.001, rightChannelGain * normalizationFactor * depthGainMultiplier);

                    // Cross-channel gains - ZERO for quadrant (hard pan), small for others
                    const targetLeftToRight = isHardPan ? 0.001 : Math.max(0.001, rightChannelGain * crossChannelMix * normalizationFactor);
                    const targetRightToLeft = isHardPan ? 0.001 : Math.max(0.001, leftChannelGain * crossChannelMix * normalizationFactor);

                    // Delay/cross-delay gains - minimal for quadrant to keep separation clean
                    const delayBase = isHardPan ? 0.02 : 0.05 * currentSpatialDepth;
                    const crossDelayBase = isHardPan ? 0 : 0.03 * currentSpatialDepth;
                    const targetDelayLeft = Math.max(0.0001, delayBase * Math.abs(panPosition));
                    const targetDelayRight = Math.max(0.0001, delayBase * Math.abs(panPosition));
                    const targetCrossDelayLeft = Math.max(0.0001, crossDelayBase * Math.abs(panPosition));
                    const targetCrossDelayRight = Math.max(0.0001, crossDelayBase * Math.abs(panPosition));
                    
                    // Use exponentialRampToValueAtTime for smoother transitions (prevents clicks better than linear)
                    const now = ctx.currentTime;
                    const rampSec = 0.1; // 100ms ramp for perceptible movement
                    const rampTime = now + rampSec;
                    
                    // Clamp to prevent automation errors
                    const clamp = (val) => Math.max(0.0001, Math.min(1, val));
                    
                    nodes.leftToLeftGain.gain.setValueAtTime(clamp(nodes.leftToLeftGain.gain.value), now);
                    nodes.leftToLeftGain.gain.exponentialRampToValueAtTime(clamp(targetLeftGain), rampTime);
                    
                    nodes.rightToRightGain.gain.setValueAtTime(clamp(nodes.rightToRightGain.gain.value), now);
                    nodes.rightToRightGain.gain.exponentialRampToValueAtTime(clamp(targetRightGain), rampTime);
                    
                    nodes.leftToRightGain.gain.setValueAtTime(clamp(nodes.leftToRightGain.gain.value), now);
                    nodes.leftToRightGain.gain.exponentialRampToValueAtTime(clamp(targetLeftToRight), rampTime);
                    
                    nodes.rightToLeftGain.gain.setValueAtTime(clamp(nodes.rightToLeftGain.gain.value), now);
                    nodes.rightToLeftGain.gain.exponentialRampToValueAtTime(clamp(targetRightToLeft), rampTime);

                    // Ramp delay/cross-delay gains as well to enhance spatial cues
                    if (nodes.delayGainLeft) {
                        nodes.delayGainLeft.gain.setValueAtTime(clamp(nodes.delayGainLeft.gain.value), now);
                        nodes.delayGainLeft.gain.exponentialRampToValueAtTime(clamp(targetDelayLeft), rampTime);
                    }
                    if (nodes.delayGainRight) {
                        nodes.delayGainRight.gain.setValueAtTime(clamp(nodes.delayGainRight.gain.value), now);
                        nodes.delayGainRight.gain.exponentialRampToValueAtTime(clamp(targetDelayRight), rampTime);
                    }
                    if (nodes.crossGainLeft) {
                        nodes.crossGainLeft.gain.setValueAtTime(clamp(nodes.crossGainLeft.gain.value), now);
                        nodes.crossGainLeft.gain.exponentialRampToValueAtTime(clamp(targetCrossDelayLeft), rampTime);
                    }
                    if (nodes.crossGainRight) {
                        nodes.crossGainRight.gain.setValueAtTime(clamp(nodes.crossGainRight.gain.value), now);
                        nodes.crossGainRight.gain.exponentialRampToValueAtTime(clamp(targetCrossDelayRight), rampTime);
                    }
                    
                    // Increment time according to interval (seconds)
                    time += ROTATION_INTERVAL_MS / 1000;
                }, ROTATION_INTERVAL_MS);
            };

            const visualize = () => {
                if (!analyserRef.current || !canvasRef.current) return;
                
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const analyser = analyserRef.current;
                
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                const draw = () => {
                    animationFrameRef.current = requestAnimationFrame(draw);
                    
                    analyser.getByteFrequencyData(dataArray);
                    
                    ctx.fillStyle = darkMode ? '#1a2332' : '#f8f9fa';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const barWidth = (canvas.width / bufferLength) * 2.5;
                    let x = 0;
                    const visualGain = Math.max(0, Math.min(visualWaveGainRef.current / 0.5, 1));
                    
                    for (let i = 0; i < bufferLength; i++) {
                        const barHeight = ((dataArray[i] / 255) * canvas.height) * visualGain;
                        
                        const hue = (i / bufferLength) * 360;
                        ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                        ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                        
                        x += barWidth + 1;
                    }
                };
                
                draw();
            };

            // File validation helper
            const validateFile = (file) => {
                // Check for empty files
                if (file.size === 0) {
                    return { valid: false, reason: 'empty', file };
                }
                
                // Check MIME type
                if (!SUPPORTED_MIME_TYPES.includes(file.type)) {
                    return { valid: false, reason: 'unsupported', file };
                }
                
                return { valid: true, file };
            };

            // File size formatter
            const formatFileSize = (bytes) => {
                if (bytes === 0) return '0 B';
                if (bytes < 1024) return `${bytes} B`;
                if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
                return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
            };

            // File type formatter
            const formatFileType = (mimeType) => {
                const typeMap = {
                    'audio/mpeg': 'MP3',
                    'audio/wav': 'WAV',
                    'audio/wave': 'WAV',
                    'audio/ogg': 'OGG',
                    'audio/x-wav': 'WAV'
                };
                return typeMap[mimeType] || 'Audio';
            };

            const SESSION_DEFAULT_PROFILE = 'default';

            const getPresetLabel = React.useCallback(() => {
                const presetMatch = allPresets.find(preset => preset.id === activePresetId);
                if (presetMatch) {
                    return presetMatch.name || presetMatch.label || 'Custom preset';
                }
                const defaultMode = MODE_LIBRARY.find(mode => mode.id === activePresetId);
                if (defaultMode) {
                    return defaultMode.label;
                }
                return MODE_LIBRARY[modeIndex]?.label || 'Focus';
            }, [activePresetId, allPresets, modeIndex]);

            const getSessionLoggingApi = () => {
                if (typeof window === 'undefined' || typeof indexedDB === 'undefined') {
                    return null;
                }
                return window.SessionLogging || null;
            };

            const handleSessionError = React.useCallback(async (error, phase) => {
                if (!error) {
                    return;
                }
                console.error(`[SessionLogger] Error during ${phase}:`, error);
                if (error.name === 'QuotaExceededError') {
                    const sessionApi = getSessionLoggingApi();
                    if (sessionApi?.estimateStorageUsage) {
                        try {
                            const stats = await sessionApi.estimateStorageUsage();
                            const approx = formatFileSize(stats.approxBytes || 0);
                            showToast(`Session log full (~${approx}). Use the Insights panel to clear history.`, 'warning');
                            return;
                        } catch (statsError) {
                            console.warn('[SessionLogger] Failed to estimate storage usage:', statsError);
                        }
                    }
                    showToast('Session log full. Use Insights actions to clear old sessions.', 'warning');
                } else if (error.name === 'VersionError') {
                    showToast('Session log corrupted. Rebuilding...', 'error');
                    try {
                        const sessionApi = getSessionLoggingApi();
                        if (sessionApi?.resetDatabase) {
                            await sessionApi.resetDatabase();
                            showToast('Session log reset. Try your action again.', 'success');
                        }
                    } catch (resetErr) {
                        console.error('[SessionLogger] Failed to reset storage:', resetErr);
                    }
                } else {
                    showToast('Session logging unavailable. See console for details.', 'warning');
                }
            }, [showToast]);

            const startSession = React.useCallback(async ({ track, ritualUsed = false } = {}) => {
                const sessionApi = getSessionLoggingApi();
                if (!sessionApi) {
                    return null;
                }
                if (!track) {
                    console.warn('[SessionLogger] Missing track metadata; session not recorded.');
                    return null;
                }
                if (activeSessionIdRef.current) {
                    return activeSessionIdRef.current;
                }

                const record = {
                    profileId: SESSION_DEFAULT_PROFILE,
                    timestamp: Date.now(),
                    trackId: track.id ?? track.url ?? track.name ?? `track-${Date.now()}`,
                    trackName: track.name || track.label || 'Untitled Track',
                    presetId: activePresetId,
                    presetLabel: getPresetLabel(),
                    ritualUsed: Boolean(ritualUsed),
                    duration: 0,
                    hrAvg: null,
                    hrMax: null,
                    moodBefore: null,
                    moodAfter: null,
                    notes: '',
                    endedManually: false
                };

                try {
                    if (performance?.mark) {
                        performance.mark('session-start-begin');
                    }
                    const sessionId = await sessionApi.addSession(record);
                    setActiveSessionId(sessionId);
                    activeSessionIdRef.current = sessionId;
                    if (performance?.mark) {
                        performance.mark('session-start-end');
                        const measure = performance.measure('session-start', 'session-start-begin', 'session-start-end');
                        performance.clearMarks('session-start-begin');
                        performance.clearMarks('session-start-end');
                        performance.clearMeasures('session-start');
                        console.log(`[SessionLogger] Session started: ${sessionId} in ${measure.duration.toFixed(2)}ms`);
                    } else {
                        console.log(`[SessionLogger] Session started: ${sessionId}`);
                    }
                    return sessionId;
                } catch (error) {
                    await handleSessionError(error, 'start');
                    return null;
                }
            }, [activePresetId, getPresetLabel, handleSessionError]);

            const endSession = React.useCallback(async (manual = false) => {
                const sessionApi = getSessionLoggingApi();
                if (!sessionApi || !activeSessionIdRef.current) {
                    return;
                }
                const sessionId = activeSessionIdRef.current;
                setActiveSessionId(null);
                activeSessionIdRef.current = null;
                try {
                    const session = await sessionApi.getSession(sessionId);
                    if (!session) {
                        console.warn('[SessionLogger] Session missing during end call:', sessionId);
                        return;
                    }
                    const rawDuration = (Date.now() - session.timestamp) / 1000;
                    const durationSeconds = Number(rawDuration.toFixed(1));
                    await sessionApi.updateSession(sessionId, {
                        duration: durationSeconds,
                        endedManually: manual
                    });
                    console.log(`[SessionLogger] Session ended: ${sessionId}, duration: ${durationSeconds}s`);
                } catch (error) {
                    await handleSessionError(error, 'end');
                }
            }, [handleSessionError]);

            const clearProfileSessions = React.useCallback(async (profileId = SESSION_DEFAULT_PROFILE) => {
                const sessionApi = getSessionLoggingApi();
                if (!sessionApi) {
                    showToast('Session logging not supported in this browser.', 'warning');
                    return 0;
                }
                if (activeSessionIdRef.current) {
                    await endSession(true);
                }
                try {
                    const deletedCount = await sessionApi.clearProfile(profileId);
                    if (deletedCount > 0) {
                        showToast(`${deletedCount} sessions deleted`, 'success');
                    } else {
                        showToast('No sessions found for this profile.', 'info');
                    }
                    console.log(`[SessionLogger] Cleared ${deletedCount} sessions for profile "${profileId}"`);
                    return deletedCount;
                } catch (error) {
                    await handleSessionError(error, 'clear-profile');
                    return 0;
                }
            }, [endSession, handleSessionError, showToast]);

            const clearSessionsOlderThanDays = React.useCallback(async (days = 30, profileId = SESSION_DEFAULT_PROFILE) => {
                const sessionApi = getSessionLoggingApi();
                if (!sessionApi) {
                    showToast('Session logging not supported in this browser.', 'warning');
                    return 0;
                }
                try {
                    const deletedCount = await sessionApi.clearSessionsOlderThanDays(days, profileId);
                    if (deletedCount > 0) {
                        showToast(`${deletedCount} sessions older than ${days} days deleted`, 'success');
                    } else {
                        showToast(`No sessions older than ${days} days to delete.`, 'info');
                    }
                    console.log(`[SessionLogger] Cleared ${deletedCount} sessions older than ${days} days for "${profileId}"`);
                    return deletedCount;
                } catch (error) {
                    await handleSessionError(error, 'trim-old');
                    return 0;
                }
            }, [handleSessionError, showToast]);

            const handleClearSessions = async () => {
                if (isClearingSessions) {
                    return;
                }
                setIsClearingSessions(true);
                try {
                    await clearProfileSessions(SESSION_DEFAULT_PROFILE);
                } finally {
                    setIsClearingSessions(false);
                }
            };

            const handleTrimOldSessions = async () => {
                if (isTrimmingSessions) {
                    return;
                }
                setIsTrimmingSessions(true);
                try {
                    await clearSessionsOlderThanDays(30, SESSION_DEFAULT_PROFILE);
                } finally {
                    setIsTrimmingSessions(false);
                }
            };

            const addLocalFiles = (files) => {
                const fileArray = Array.from(files);
                
                try {
                    // Show progress indicator for large batches
                    if (fileArray.length > 5) {
                        setIsProcessingFiles(true);
                        setHeroMessage(`Adding ${fileArray.length} tracks...`);
                    }
                    
                    // Validate and filter files
                    const validFiles = [];
                    const rejectedFiles = [];
                    
                    fileArray.forEach(file => {
                        const validation = validateFile(file);
                        if (validation.valid) {
                            validFiles.push(file);
                        } else {
                            rejectedFiles.push({ 
                                name: file.name, 
                                reason: validation.reason 
                            });
                        }
                    });
                    
                    // Create playlist tracks from valid files
                    const newTracks = validFiles.map((file, index) => {
                        // Remove any audio extension, not just .mp3
                        const baseName = file.name.replace(/\.(mp3|wav|ogg)$/i, '');
                        return {
                            id: Date.now() + index,
                            name: baseName,
                            source: 'local',
                            file: file,
                            url: null,
                            lastPresetId: null, // Story 3-3: Track preset for auto-restore
                            preferredPresetId: null, // Story 3-3: User can pin preset (future)
                            metadata: {
                                size: file.size,
                                type: file.type,
                                lastModified: file.lastModified
                            }
                        };
                    });
                    
                    // Update playlist
                    if (newTracks.length > 0) {
                        setPlaylist(prev => [...prev, ...newTracks]);
                        setNeedsAudio(false);
                        
                        const trackWord = newTracks.length === 1 ? 'track' : 'tracks';
                        setHeroMessage(`Added ${newTracks.length} ${trackWord}. Pick a ritual and press Start.`);
                        setA11yAnnouncement(`${newTracks.length} ${trackWord} added to playlist`);
                    }
                    
                    // Show rejection toast if needed
                    if (rejectedFiles.length > 0) {
                        const emptyCount = rejectedFiles.filter(f => f.reason === 'empty').length;
                        const unsupportedCount = rejectedFiles.filter(f => f.reason === 'unsupported').length;
                        
                        let message = '';
                        if (emptyCount > 0) {
                            message += `${emptyCount} empty file${emptyCount > 1 ? 's' : ''} rejected. `;
                        }
                        if (unsupportedCount > 0) {
                            message += `${unsupportedCount} unsupported file${unsupportedCount > 1 ? 's' : ''} rejected. Use MP3, WAV, or OGG.`;
                        }
                        
                        showToast(message, 'warning');
                        setA11yAnnouncement(message);
                    }
                } finally {
                    // Always hide progress indicator, even if errors occur
                    setIsProcessingFiles(false);
                }
            };

            const handleDrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                const files = e.dataTransfer.files;
                if (files && files.length > 0) {
                    addLocalFiles(files);
                }
                setDragActive(false);
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!dragActive) {
                    setDragActive(true);
                }
            };

            const handleDragEnter = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setDragActive(true);
            };

            const handleDragLeave = (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (e.relatedTarget && e.currentTarget.contains(e.relatedTarget)) {
                    return;
                }
                setDragActive(false);
            };

            // URL format validator
            const isValidUrl = (str) => {
                try {
                    const url = new URL(str);
                    return url.protocol === 'http:' || url.protocol === 'https:';
                } catch {
                    return false;
                }
            };

            // Unsupported service detector
            const detectUnsupportedService = (url) => {
                const urlLower = url.toLowerCase();
                if (urlLower.includes('youtube.com') || urlLower.includes('youtu.be')) {
                    return { service: 'YouTube', supported: false };
                }
                if (urlLower.includes('spotify.com')) {
                    return { service: 'Spotify', supported: false };
                }
                return { supported: true };
            };

            // Stream URL validator (async)
            const validateStreamUrl = async (url) => {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                try {
                    const response = await fetch(url, {
                        method: 'HEAD',
                        mode: 'cors',
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                    
                    if (response.ok) {
                        return { valid: true, url };
                    } else {
                        return { 
                            valid: false, 
                            reason: 'unreachable',
                            status: response.status 
                        };
                    }
                } catch (err) {
                    clearTimeout(timeoutId);
                    
                    if (err.name === 'AbortError') {
                        return { valid: false, reason: 'timeout' };
                    }
                    
                    // CORS or network error
                    return { valid: false, reason: 'cors', error: err };
                }
            };

            const addUrl = async () => {
                const url = urlInput.trim();
                
                // Ignore empty input
                if (!url) return;
                
                // 1. Format validation
                if (!isValidUrl(url)) {
                    showToast('Invalid URL format. Use: https://example.com/song.mp3', 'error');
                    setA11yAnnouncement('Invalid URL format');
                    return;
                }
                
                // 2. Unsupported service detection
                const serviceCheck = detectUnsupportedService(url);
                if (!serviceCheck.supported) {
                    showToast(
                        `${serviceCheck.service} playback requires authenticated proxy. Direct MP3 URLs only.`,
                        'warning'
                    );
                    setA11yAnnouncement(`${serviceCheck.service} not supported`);
                    return;
                }
                
                // 3. Show validating state
                setIsValidatingUrl(true);
                setHeroMessage('Validating stream URL...');
                
                // 4. HEAD request validation with cleanup tracking
                try {
                    const validation = await validateStreamUrl(url);
                    
                    // Check if component still mounted
                    if (!urlValidationControllerRef.current) {
                        return; // Component unmounted during validation
                    }
                    
                    setIsValidatingUrl(false);
                    
                    if (!validation.valid) {
                        let message = '';
                        
                        switch (validation.reason) {
                            case 'cors':
                                message = 'Stream blocked by CORS. Use direct MP3 link or enable server CORS.';
                                break;
                            case 'timeout':
                                message = 'Request timeout (5s). Server unreachable or slow.';
                                break;
                            case 'unreachable':
                                message = `Stream unreachable (${validation.status}). Check URL and try again.`;
                                break;
                            default:
                                message = 'Unable to validate stream. Check URL.';
                        }
                        
                        showToast(message, 'error');
                        setA11yAnnouncement(message);
                        setHeroMessage('Stream validation failed. Try another URL.');
                        return;
                    }
                    
                    // 5. Add validated URL to playlist
                    const newTrack = {
                        id: Date.now(),
                        name: 'Remote Track',
                        source: 'url',
                        url: url,
                        originalUrl: url,
                        lastPresetId: null, // Story 3-3: Track preset for auto-restore
                        preferredPresetId: null // Story 3-3: User can pin preset (future)
                    };
                    
                    setPlaylist(prev => [...prev, newTrack]);
                    setUrlInput('');
                    setNeedsAudio(false);
                    setHeroMessage('Stream validated and added. Start your ritual to hear it.');
                    setA11yAnnouncement('Stream added to playlist');
                } catch (err) {
                    // Handle unexpected errors
                    if (urlValidationControllerRef.current) {
                        setIsValidatingUrl(false);
                        showToast('Validation error. Please try again.', 'error');
                    }
                }
            };

            const playTrack = async (index, options = {}) => {
                const { ritualUsed, shouldEndActiveSession = true } = options;
                const activePlaylist = playlistRef.current || playlist;
                const track = activePlaylist[index];
                if (!track) return;

                if (typeof ritualUsed !== 'undefined') {
                    sessionRitualFlagRef.current = ritualUsed;
                }

                if (activeSessionIdRef.current && shouldEndActiveSession) {
                    await endSession(true);
                }
                
                // Story 3-3: Auto-restore last-used preset for this track
                if (track.lastPresetId) {
                    const presets = getAllPresets();
                    const savedPreset = presets.find(p => p.id === track.lastPresetId);
                    
                    if (savedPreset) {
                        // Restore the preset if it's different from current
                        if (activePresetId !== track.lastPresetId) {
                            applyPreset(savedPreset.preset, savedPreset.id);
                            showToast(`Restored ${savedPreset.name} preset for "${track.name}"`, 'info');
                            setA11yAnnouncement(`Restored ${savedPreset.name} preset`);
                        }
                    } else {
                        // Preset was deleted, fallback to focus
                        console.warn(`[AutoRestore] Preset ${track.lastPresetId} not found for track ${track.name}, using Focus`);
                        const focusMode = MODE_LIBRARY[0];
                        applyPreset(focusMode.preset, focusMode.id);
                    }
                } else {
                    // First time playing this track - save current preset
                    setPlaylist(prev => prev.map((t, i) => 
                        i === index ? { ...t, lastPresetId: activePresetId } : t
                    ));
                    console.log(`[AutoRestore] Saved preset ${activePresetId} for track ${track.name}`);
                }
                
                const audio = prepareAudioElement();
                
                const handleLoadedMetadata = () => {
                    setupAudioGraph(audio);
                    audio.play().then(() => {
                        setIsPlaying(true);
                        const resolvedRitualUsed = typeof ritualUsed === 'undefined'
                            ? sessionRitualFlagRef.current
                            : ritualUsed;
                        startSession({ track, ritualUsed: resolvedRitualUsed });
                    }).catch(err => {
                        console.error('Playback error:', err);
                        alert('Playback error. If you opened this from file://, please run a local web server.\n\nQuick fix: Run "python3 -m http.server 8000" in this folder');
                    });
                };
                
                audio.addEventListener('loadedmetadata', handleLoadedMetadata, { once: true });
                
                const assignSource = () => {
                    if (track.source === 'local' && track.file) {
                        try {
                            const blobUrl = URL.createObjectURL(track.file);
                            currentBlobUrlRef.current = blobUrl;
                            audio.src = blobUrl;
                        } catch (err) {
                            console.error('Error creating blob URL:', err);
                            audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
                            alert('Error loading file. Please serve this HTML from a web server (see console for instructions).\n\nQuick fix: Run "python3 -m http.server 8000" in this folder, then open http://localhost:8000/8d-player-live.html');
                            return false;
                        }
                    } else if (track.source === 'youtube') {
                        audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
                        alert('YouTube playback requires a backend server or YouTube API. Please use direct MP3 URLs or local files.');
                        teardownAudioElement();
                        return false;
                    } else if (track.url) {
                        audio.src = track.url;
                    } else {
                        audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
                        alert('Invalid track source');
                        teardownAudioElement();
                        return false;
                    }
                    return true;
                };
                
                const assigned = assignSource();
                if (!assigned) {
                    return;
                }
                
                audio.load();
                
                currentTrackIndexRef.current = index;
                setCurrentTrackIndex(index);
                setRitualStatus('active');
                setHeroMessage(`Now playing ${track.name} â€¢ ${selectedMode.label}`);
                setNeedsAudio(false);
            };

            playNextRef.current = (options = {}) => {
                const { shouldEndActiveSession = true } = options;
                const playlistSnapshot = playlistRef.current;
                if (!playlistSnapshot || playlistSnapshot.length === 0) {
                    return;
                }
                const indexSnapshot = currentTrackIndexRef.current;
                if (
                    indexSnapshot === null ||
                    indexSnapshot === undefined ||
                    indexSnapshot < 0 ||
                    indexSnapshot >= playlistSnapshot.length
                ) {
                    playTrack(0, { shouldEndActiveSession });
                    return;
                }
                const nextIndex = (indexSnapshot + 1) % playlistSnapshot.length;
                playTrack(nextIndex, { shouldEndActiveSession });
            };

            const togglePlayPause = () => {
                if (!audioElementRef.current) {
                    if (playlist.length > 0) {
                        playTrack(0, { ritualUsed: sessionRitualFlagRef.current });
                    }
                    return;
                }
                
                const audio = audioElementRef.current;
                
                if (isPlaying) {
                    audio.pause();
                    setIsPlaying(false);
                    endSession(true);
                } else {
                    audio.play().then(() => {
                        setIsPlaying(true);
                        if (!activeSessionIdRef.current && nowPlayingTrack) {
                            startSession({ track: nowPlayingTrack, ritualUsed: sessionRitualFlagRef.current });
                        }
                    });
                }
            };

            const playNext = () => {
                if (typeof playNextRef.current === 'function') {
                    playNextRef.current();
                }
            };

            const playPrevious = () => {
                if (currentTrackIndex === null || playlist.length === 0) {
                    return;
                }
                const prevIndex = currentTrackIndex === 0 ? playlist.length - 1 : currentTrackIndex - 1;
                playTrack(prevIndex);
            };

            const removeFromPlaylist = async (id) => {
                const currentList = playlist;
                const removedIndex = currentList.findIndex(track => track.id === id);
                if (removedIndex === -1) {
                    return;
                }
                const nextPlaylist = currentList.filter(track => track.id !== id);
                setPlaylist(nextPlaylist);

                const prevIndex = currentTrackIndex;
                const removedWasCurrent = prevIndex === removedIndex;
                if (removedWasCurrent) {
                    await endSession(true);
                    teardownAudioElement();
                    disposeAudioGraph();
                    setIsPlaying(false);
                }

                let nextIndex = prevIndex;
                if (nextPlaylist.length === 0) {
                    nextIndex = null;
                } else if (removedWasCurrent) {
                    nextIndex = Math.min(removedIndex, nextPlaylist.length - 1);
                } else if (typeof prevIndex === 'number' && removedIndex < prevIndex) {
                    nextIndex = Math.max(prevIndex - 1, 0);
                } else if (typeof prevIndex === 'number' && prevIndex >= nextPlaylist.length) {
                    nextIndex = nextPlaylist.length - 1;
                }

                if (nextIndex !== prevIndex) {
                    currentTrackIndexRef.current = nextIndex;
                    setCurrentTrackIndex(nextIndex);
                }
            };

            const handleSeekChange = (event) => {
                if (!audioElementRef.current) return;
                const nextTime = parseFloat(event.target.value);
                if (Number.isNaN(nextTime)) return;
                audioElementRef.current.currentTime = nextTime;
                setCurrentTime(nextTime);
            };

            const ensurePlaylistReady = () => {
                if (playlist.length === 0) {
                    setNeedsAudio(true);
                    setHeroMessage('Add a local file or stream to begin this ritual.');
                    if (dropZoneRef.current) {
                        dropZoneRef.current.focus();
                    }
                    return false;
                }
                return true;
            };

            const launchRitualPlayback = ({ ritualUsed } = {}) => {
                const resolvedRitualUsed = typeof ritualUsed === 'boolean' ? ritualUsed : ritualStatus === 'breathing';
                sessionRitualFlagRef.current = resolvedRitualUsed;

                // Log ritual completion telemetry
                try {
                    const ritualEndTs = Date.now();
                    const ritualEvent = {
                        type: 'FOCUS_RITUAL_COMPLETED',
                        timestamp: ritualEndTs,
                        modeId: selectedMode.id,
                        modeLabel: selectedMode.label,
                        presetApplied: selectedMode.id,
                        duration: HERO_BREATH_DURATION
                    };
                    console.log('[SessionLogger]', ritualEvent);
                    // Future: Store in IndexedDB sessions store
                } catch (e) {
                    console.warn('Failed to log ritual completion', e);
                }

                setRitualStatus('active');
                setHeroMessage(`Ritual active â€” ${selectedMode.label} preset live.`);
                setNeedsAudio(false);
                setBreathingPhase('');
                
                if (currentTrackIndex === null) {
                    playTrack(0, { ritualUsed: resolvedRitualUsed });
                    return;
                }
                const audio = audioElementRef.current;
                if (audio) {
                    audio.play().then(() => {
                        setIsPlaying(true);
                        if (nowPlayingTrack) {
                            startSession({ track: nowPlayingTrack, ritualUsed: resolvedRitualUsed });
                        }
                    }).catch(() => {
                        setHeroMessage('Press play to continue your ritual.');
                    });
                } else {
                    playTrack(currentTrackIndex, { ritualUsed: resolvedRitualUsed });
                }
            };

            const startRitual = () => {
                if (!ensurePlaylistReady()) {
                    return;
                }
                
                // Check if skip preference is enabled
                if (skipRitualPref) {
                    // Log skip telemetry
                    try {
                        const skipEvent = {
                            type: 'RITUAL_SKIPPED',
                            timestamp: Date.now(),
                            modeId: selectedMode.id,
                            reason: 'skip-preference-enabled'
                        };
                        console.log('[SessionLogger]', skipEvent);
                    } catch (e) {
                        console.warn('Failed to log ritual skip', e);
                    }
                    launchRitualPlayback({ ritualUsed: false });
                    return;
                }
                
                clearRitualTimers();
                setRitualStatus('breathing');
                setHeroMessage(`Breathe in...`);
                setRitualCountdown(HERO_BREATH_DURATION);
                setBreathingPhase('inhale');
                
                // Log ritual start telemetry
                try {
                    const startEvent = {
                        type: 'RITUAL_STARTED',
                        timestamp: Date.now(),
                        modeId: selectedMode.id,
                        modeLabel: selectedMode.label,
                        duration: HERO_BREATH_DURATION
                    };
                    console.log('[SessionLogger]', startEvent);
                } catch (e) {
                    console.warn('Failed to log ritual start', e);
                }
                
                // Countdown timer (1s intervals)
                ritualIntervalRef.current = setInterval(() => {
                    setRitualCountdown((prev) => {
                        const next = Math.max(prev - 1, 0);
                        if (next === 0) {
                            clearInterval(ritualIntervalRef.current);
                            ritualIntervalRef.current = null;
                        }
                        return next;
                    });
                }, 1000);
                
                // 4-2-4 breathing phase cycle (6s total: 2s in, 1s hold, 2s out, 1s hold)
                // Repeat ~3.33 times over 20 seconds
                let phaseStep = 0;
                breathingPhaseIntervalRef.current = setInterval(() => {
                    phaseStep++;
                    const cyclePosition = phaseStep % 6;
                    
                    if (cyclePosition === 0 || cyclePosition === 1) {
                        // Inhale (2 seconds)
                        setBreathingPhase('inhale');
                        setHeroMessage('Breathe in...');
                    } else if (cyclePosition === 2) {
                        // Hold after inhale (1 second)
                        setBreathingPhase('hold-in');
                        setHeroMessage('Hold...');
                    } else if (cyclePosition === 3 || cyclePosition === 4) {
                        // Exhale (2 seconds)
                        setBreathingPhase('exhale');
                        setHeroMessage('Breathe out...');
                    } else if (cyclePosition === 5) {
                        // Hold after exhale (1 second)
                        setBreathingPhase('hold-out');
                        setHeroMessage('Hold...');
                    }
                }, 1000);
                
                // Auto-launch after 20 seconds
                ritualTimeoutRef.current = setTimeout(() => {
                    clearRitualTimers();
                    launchRitualPlayback({ ritualUsed: true });
                }, HERO_BREATH_DURATION * 1000);
            };

            const skipRitual = () => {
                if (!ensurePlaylistReady()) {
                    return;
                }
                
                // Log skip telemetry
                try {
                    const skipEvent = {
                        type: 'RITUAL_SKIPPED',
                        timestamp: Date.now(),
                        modeId: selectedMode.id,
                        reason: 'user-skip-button'
                    };
                    console.log('[SessionLogger]', skipEvent);
                } catch (e) {
                    console.warn('Failed to log ritual skip', e);
                }
                
                clearRitualTimers();
                setRitualCountdown(0);
                setBreathingPhase('');
                launchRitualPlayback({ ritualUsed: false });
            };

            const toggleSkipRitualPref = () => {
                const newValue = !skipRitualPref;
                setSkipRitualPref(newValue);
                try {
                    if (newValue) {
                        localStorage.setItem('skipBreathingRitual', 'true');
                    } else {
                        localStorage.removeItem('skipBreathingRitual');
                    }
                } catch (e) {
                    console.warn('Failed to persist skip preference', e);
                }
            };

            // Story 3-1: Apply preset configuration to all audio parameters
            const applyPreset = (preset, presetId) => {
                performance.mark('preset-apply-start');
                
                // Batch all parameter updates (React 18 auto-batches in event handlers)
                setSpeed(preset.speed);
                setIntensity(preset.intensity);
                setSpatialDepth(preset.spatialDepth);
                setMovementPattern(preset.movement);
                setBinauralEnabled(preset.binaural.enabled);
                setBinauralFreq(preset.binaural.freq);
                setNoiseType(preset.noise.type);
                setNoiseVolume(preset.noise.volume);
                setVisualWaveGain(preset.noise.volume);
                
                // Update active preset tracking
                setActivePresetId(presetId);
                
                // Story 3-3: Update current track's lastPresetId when preset changes
                if (currentTrackIndex !== null && playlist[currentTrackIndex]) {
                    setPlaylist(prev => prev.map((track, i) => 
                        i === currentTrackIndex ? { ...track, lastPresetId: presetId } : track
                    ));
                    console.log(`[AutoRestore] Updated track ${playlist[currentTrackIndex].name} lastPresetId to ${presetId}`);
                }
                
                // Log preset change event
                logPresetChange(presetId);
                
                performance.mark('preset-apply-end');
                const measure = performance.measure('preset-apply', 'preset-apply-start', 'preset-apply-end');
                console.log(`[Performance] Preset applied in ${measure.duration.toFixed(2)}ms`);
                
                // Restart rotation with new settings if playing
                if (isPlaying) {
                    startRotation();
                }
            };

            // Update effects in real-time
            useEffect(() => {
                if (isPlaying) {
                    startRotation();
                }
            }, [speed, intensity, movementPattern]);

            useEffect(() => {
                const nodes = rotationNodesRef.current;
                if (!nodes) {
                    return;
                }
                if (nodes.delayGainLeft) {
                    nodes.delayGainLeft.gain.value = 0.05 * spatialDepth;
                }
                if (nodes.delayGainRight) {
                    nodes.delayGainRight.gain.value = 0.05 * spatialDepth;
                }
                if (nodes.crossGainLeft) {
                    nodes.crossGainLeft.gain.value = 0.03 * spatialDepth;
                }
                if (nodes.crossGainRight) {
                    nodes.crossGainRight.gain.value = 0.03 * spatialDepth;
                }
            }, [spatialDepth]);

            useEffect(() => {
                visualWaveGainRef.current = visualWaveGain;
            }, [visualWaveGain]);

            useEffect(() => {
                if (gainChainRef.current) {
                    gainChainRef.current.setVolume(volume);
                }
            }, [volume]);

            useEffect(() => {
                syncBinauralChain();
            }, [binauralEnabled, binauralFreq]);

            useEffect(() => {
                syncNoiseLayer();
            }, [noiseType, noiseVolume]);

            const formatTime = (seconds) => {
                if (!seconds || isNaN(seconds)) return '0:00';
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            };

            const getTotalDuration = () => {
                return playlist.length * 3.5; // Estimate 3.5 minutes per track
            };

            const getBinauralDescription = (freq) => {
                if (freq <= 4) return 'Delta (Sleep)';
                if (freq <= 8) return 'Theta (Meditation)';
                if (freq <= 14) return 'Alpha (Relaxation)';
                if (freq <= 30) return 'Beta (Focus)';
                return 'Gamma (Peak Focus)';
            };

            const dropZoneClasses = ['drop-zone'];
            if (needsAudio) {
                dropZoneClasses.push('drop-zone--attention');
            }
            if (dragActive) {
                dropZoneClasses.push('drop-zone--hover');
            }

return (
                <div className="screen">
                    {/* 
                    KEYBOARD SHORTCUTS REFERENCE
                    ============================
                    
                    Navigation:
                    - Tab: Move forward through interactive elements
                    - Shift+Tab: Move backward through interactive elements
                    
                    Mode Selection (when mode chips focused):
                    - Arrow Left/Right: Navigate between Focus/Calm/Energize modes
                    - Enter or Space: Activate selected mode
                    
                    Toggle Buttons:
                    - Tab to reach: Dark mode, Reduced motion, High contrast toggles
                    - Enter or Space: Toggle the focused setting
                    
                    Playback Controls:
                    - Tab to reach: Play/Pause, Previous, Next buttons
                    - Enter or Space: Activate playback control
                    
                    Ritual Flow:
                    - Tab to reach: Start button or Skip button during ritual
                    - Enter or Space: Start ritual or skip breathing animation
                    
                    Accessibility Features:
                    - All state changes announced via screen reader
                    - Focus indicators visible on all interactive elements
                    - â‰¥48px tap targets for touch accessibility
                    */}
                    <header className="app-header">
                        <div>
                            <p className="eyebrow">Unified Ritual Player</p>
                            <h1>8D Ritual Shell</h1>
                            <p className="hero-support">Stable v2 audio graph + v3 layout unified for Focus/Calm/Energize.</p>
                        </div>
                        <div className="header-actions">
                            <button type="button" className="primary-btn" aria-label="Install unified ritual shell">
                                ðŸ“² Install
                            </button>
                            <button
                                type="button"
                                onClick={toggleDarkMode}
                                aria-pressed={darkMode}
                                aria-label="Toggle dark mode"
                            >
                                {darkMode ? 'â˜€ï¸ Light mode' : 'ðŸŒ™ Dark mode'}
                            </button>
                            <button
                                type="button"
                                onClick={toggleReducedMotion}
                                aria-pressed={reducedMotion}
                                aria-label="Toggle reduced motion"
                            >
                                {reducedMotion ? 'Motion reduced' : 'Motion on'}
                            </button>
                            <button
                                type="button"
                                onClick={toggleHighContrast}
                                aria-pressed={highContrast}
                                aria-label="Toggle high contrast mode"
                            >
                                {highContrast ? 'â— High contrast' : 'â—‹ Normal contrast'}
                            </button>
                        </div>
                    </header>

                    {/* Accessibility announcements for screen readers */}
                    <div 
                        className="sr-only" 
                        role="status" 
                        aria-live="polite" 
                        aria-atomic="true"
                    >
                        {a11yAnnouncement}
                    </div>

                    {/* Toast Notification */}
                    {toastMessage && (
                        <div 
                            className={`toast toast-${toastType}`}
                            role="alert"
                            aria-live="polite"
                            style={{
                                position: 'fixed',
                                bottom: '24px',
                                left: '50%',
                                transform: 'translateX(-50%)',
                                backgroundColor: toastType === 'warning' ? '#fbbf24' : 
                                               toastType === 'error' ? '#f87171' : 
                                               toastType === 'success' ? '#4ade80' : 
                                               '#a78bfa',
                                color: toastType === 'warning' || toastType === 'success' ? '#1f2937' : '#111827',
                                padding: '12px 24px',
                                borderRadius: '8px',
                                boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
                                fontWeight: '500',
                                fontSize: '14px',
                                maxWidth: '500px',
                                zIndex: 10000,
                                animation: 'slideUp 0.3s ease-out'
                            }}
                        >
                            {toastMessage}
                        </div>
                    )}

                    {/* Processing Spinner */}
                    {isProcessingFiles && (
                        <div 
                            className="processing-spinner"
                            role="status"
                            aria-live="polite"
                            style={{
                                position: 'fixed',
                                top: '50%',
                                left: '50%',
                                transform: 'translate(-50%, -50%)',
                                backgroundColor: 'rgba(0, 0, 0, 0.85)',
                                padding: '24px 32px',
                                borderRadius: '12px',
                                display: 'flex',
                                flexDirection: 'column',
                                alignItems: 'center',
                                gap: '16px',
                                zIndex: 9999
                            }}
                        >
                            <div style={{
                                width: '40px',
                                height: '40px',
                                border: '4px solid #4b5563',
                                borderTop: '4px solid #a78bfa',
                                borderRadius: '50%',
                                animation: 'spin 1s linear infinite'
                            }} />
                            <span style={{ color: '#f3f4f6', fontSize: '14px' }}>
                                Processing files...
                            </span>
                        </div>
                    )}

                    {showFileWarning && (
                        <div className="alert-inline" role="alert">
                            Web Audio needs to run over HTTP. From repo root run <code>python3 -m http.server 8000</code> then open http://localhost:8000/index.html.
                        </div>
                    )}

                    <div className="main-grid">
                        <section className="column-card panel" aria-label="Ritual selection">
                            <div className="mode-tabs" role="tablist" aria-label="Ritual modes">
                                {MODE_LIBRARY.map((mode, index) => (
                                    <button
                                        key={mode.id}
                                        id={`mode-tab-${mode.id}`}
                                        role="tab"
                                        aria-selected={activePresetId === mode.id}
                                        aria-current={activePresetId === mode.id ? 'step' : undefined}
                                        tabIndex={focusedModeIndex === index ? 0 : -1}
                                        ref={(el) => (modeRefs.current[index] = el)}
                                        data-selected={activePresetId === mode.id}
                                        className="mode-chip"
                                        style={{ '--chip-accent': mode.accent }}
                                        onClick={() => setActiveMode(index)}
                                        onKeyDown={(event) => handleModeKeyDown(event, index)}
                                    >
                                        <span>{mode.label}</span>
                                        <small>{mode.short}</small>
                                    </button>
                                ))}
                            </div>

                            {/* Story 3-2: Advanced Controls Drawer */}
                            <AdvancedControls
                                speed={speed}
                                setSpeed={setSpeed}
                                intensity={intensity}
                                setIntensity={setIntensity}
                                spatialDepth={spatialDepth}
                                setSpatialDepth={setSpatialDepth}
                                movementPattern={movementPattern}
                                setMovementPattern={setMovementPattern}
                                binauralEnabled={binauralEnabled}
                                setBinauralEnabled={setBinauralEnabled}
                                binauralFreq={binauralFreq}
                                setBinauralFreq={setBinauralFreq}
                                noiseType={noiseType}
                                setNoiseType={setNoiseType}
                                noiseVolume={noiseVolume}
                                setNoiseVolume={setNoiseVolume}
                                isExpanded={isAdvancedControlsExpanded}
                                setIsExpanded={setIsAdvancedControlsExpanded}
                                sensorLocked={sensorLocked}
                                setSensorLocked={setSensorLocked}
                                setA11yAnnouncement={setA11yAnnouncement}
                                onSavePreset={openSavePresetDialog}
                                onOpenTuner={() => setShowSpatialTuner(true)}
                            />

                            {/* Story 3-3: PresetList Component */}
                            <PresetList
                                presets={allPresets}
                                activePresetId={activePresetId}
                                onSelect={handleQuickApplyPreset}
                                onEdit={openEditPresetDialog}
                                onDelete={handleDeletePreset}
                                onReorder={handleReorderPresets}
                            />

                            <article
                                className="hero-card"
                                id={`mode-panel-${selectedMode.id}`}
                                role="tabpanel"
                                aria-labelledby={`mode-tab-${selectedMode.id}`}
                            >
                                <p className="eyebrow">{selectedMode.label} ritual</p>
                                <h2>{selectedMode.heroCopy}</h2>
                                <div className="hero-message" aria-live="polite">{heroMessage}</div>
                                {ritualStatus === 'breathing' && (
                                    <div className="hero-countdown" aria-live="assertive">
                                        {!reducedMotion && (
                                            <div
                                                className="hero-animation"
                                                aria-hidden="true"
                                                style={{ borderColor: selectedMode.accent }}
                                            />
                                        )}
                                        <div>
                                            <div className="hero-countdown__value">{ritualCountdown}s</div>
                                            <p className="hero-support" aria-live="polite">
                                                {breathingPhase === 'inhale' && 'Breathe in (2s)'}
                                                {breathingPhase === 'hold-in' && 'Hold (1s)'}
                                                {breathingPhase === 'exhale' && 'Breathe out (2s)'}
                                                {breathingPhase === 'hold-out' && 'Hold (1s)'}
                                                {!breathingPhase && '4-2-4 cadence'}
                                            </p>
                                        </div>
                                    </div>
                                )}
                                <p className="hero-support">{selectedMode.description}</p>
                                <div className="hero-actions">
                                    <button type="button" className="primary-btn" onClick={startRitual}>
                                        Start {selectedMode.label}
                                    </button>
                                    {ritualStatus === 'breathing' && (
                                        <>
                                            <button type="button" className="ghost-btn" onClick={skipRitual}>
                                                Skip ritual
                                            </button>
                                            <label style={{ 
                                                display: 'flex', 
                                                alignItems: 'center', 
                                                gap: '8px',
                                                fontSize: '0.9rem',
                                                width: '100%',
                                                cursor: 'pointer'
                                            }}>
                                                <input 
                                                    type="checkbox" 
                                                    checked={skipRitualPref}
                                                    onChange={toggleSkipRitualPref}
                                                    aria-label="Always skip breathing ritual"
                                                />
                                                <span>Always skip ritual</span>
                                            </label>
                                        </>
                                    )}
                                </div>
                                {skipRitualPref && ritualStatus === 'idle' && (
                                    <div className="alert-inline" role="status" style={{ marginTop: '12px' }}>
                                        â„¹ï¸ Breathing ritual auto-skipped (your preference). 
                                        <button 
                                            type="button" 
                                            onClick={toggleSkipRitualPref}
                                            style={{ 
                                                marginLeft: '8px', 
                                                textDecoration: 'underline',
                                                background: 'none',
                                                border: 'none',
                                                color: 'inherit',
                                                cursor: 'pointer',
                                                padding: 0
                                            }}
                                        >
                                            Restore ritual
                                        </button>
                                    </div>
                                )}
                                {needsAudio && (
                                    <div className="alert-inline" role="alert">
                                        Add a local file or stream to begin this ritual.
                                    </div>
                                )}
                            </article>

                            <div className="preset-grid">
                                {selectedMode.highlights.map((highlight) => (
                                    <div key={highlight} className="preset-card">
                                        {highlight}
                                    </div>
                                ))}
                            </div>
                        </section>

                        <section className="column-card">
                            <article className="panel now-playing-card">
                                <div className="playlist-header">
                                    <div>
                                        <p className="eyebrow">Now Playing</p>
                                        <h2>{nowPlayingTrack ? nowPlayingTrack.name : 'No track selected'}</h2>
                                    </div>
                                    <span className="status-pill" style={{ borderColor: selectedMode.accent }}>
                                        {selectedMode.label}
                                    </span>
                                </div>
                                <div className="playlist-meta">
                                    <span className="badge">{nowPlayingTrack ? nowPlayingTrack.source : 'playlist empty'}</span>
                                    <span>{playlist.length} item{playlist.length === 1 ? '' : 's'}</span>
                                </div>
                                <div className="transport-controls" aria-label="Playback controls">
                                    <button
                                        type="button"
                                        className="transport-button"
                                        onClick={playPrevious}
                                        aria-label="Play previous track"
                                        disabled={playlist.length === 0}
                                    >
                                        â®
                                    </button>
                                    <button
                                        type="button"
                                        className="transport-button play"
                                        onClick={togglePlayPause}
                                        aria-label={isPlaying ? 'Pause playback' : 'Play'}
                                        disabled={playlist.length === 0}
                                    >
                                        {isPlaying ? 'â¸' : 'â–¶ï¸'}
                                    </button>
                                    <button
                                        type="button"
                                        className="transport-button"
                                        onClick={playNext}
                                        aria-label="Play next track"
                                        disabled={playlist.length === 0}
                                    >
                                        â­
                                    </button>
                                </div>
                                <div className="timeline">
                                    <label htmlFor="timeline" className="eyebrow">Timeline</label>
                                    <input
                                        id="timeline"
                                        type="range"
                                        min="0"
                                        max={duration || 0}
                                        step="0.1"
                                        value={Math.min(currentTime, duration || 0)}
                                        onChange={handleSeekChange}
                                        aria-valuetext={`${formatTime(currentTime)} of ${formatTime(duration)}`}
                                        disabled={!duration}
                                    />
                                    <div className="timeline-labels">
                                        <span>{formatTime(currentTime)}</span>
                                        <span>{formatTime(duration)}</span>
                                    </div>
                                </div>
                                <label htmlFor="volume" className="eyebrow">Volume</label>
                                <input
                                    id="volume"
                                    type="range"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value={volume}
                                    onChange={(e) => setVolume(parseFloat(e.target.value))}
                                    aria-valuetext={`${Math.round(volume * 100)} percent`}
                                />
                                {showVisualizer && (
                                    <canvas
                                        ref={canvasRef}
                                        width="600"
                                        height="160"
                                        role="img"
                                        aria-label="Audio visualizer"
                                    ></canvas>
                                )}
                            </article>

                            <article className="panel intake-card">
                                <div className="intake-tabs" role="tablist" aria-label="Audio intake options">
                                    <button
                                        type="button"
                                        role="tab"
                                        aria-selected={intakeTab === 'files'}
                                        className="intake-tab"
                                        onClick={() => setIntakeTab('files')}
                                    >
                                        Files
                                    </button>
                                    <button
                                        type="button"
                                        role="tab"
                                        aria-selected={intakeTab === 'stream'}
                                        className="intake-tab"
                                        disabled={!isOnline}
                                        onClick={() => isOnline && setIntakeTab('stream')}
                                    >
                                        Stream
                                    </button>
                                </div>
                                {intakeTab === 'files' ? (
                                    <>
                                        <p>Add MP3s via drag/drop or picker. Local tracks stay offline.</p>
                                        <div
                                            className={dropZoneClasses.join(' ')}
                                            onClick={() => {
                                                if (fileInputRef.current) {
                                                    fileInputRef.current.click();
                                                }
                                            }}
                                            onDrop={handleDrop}
                                            onDragOver={handleDragOver}
                                            onDragEnter={handleDragEnter}
                                            onDragLeave={handleDragLeave}
                                            role="button"
                                            tabIndex={0}
                                            ref={dropZoneRef}
                                            onKeyDown={(event) => {
                                                if ((event.key === 'Enter' || event.key === ' ' || event.key === 'Spacebar') && fileInputRef.current) {
                                                    event.preventDefault();
                                                    fileInputRef.current.click();
                                                }
                                            }}
                                            aria-label="Add audio files"
                                        >
                                            <strong>ðŸ“ Drop files here</strong>
                                            <span>or press Enter to browse</span>
                                        </div>
                                        <label htmlFor="file-picker" className="sr-only">Browse audio files</label>
                                        <input
                                            id="file-picker"
                                            ref={fileInputRef}
                                            type="file"
                                            accept="audio/mpeg,audio/wav,audio/ogg,.mp3,.wav,.ogg"
                                            multiple
                                            className="sr-only"
                                            aria-label="Browse audio files"
                                            onChange={(e) => addLocalFiles(e.target.files)}
                                        />
                                    </>
                                ) : (
                                    <>
                                        {!isOnline && (
                                            <div className="alert-inline" role="alert">
                                                Stream tab disabled while offline.
                                            </div>
                                        )}
                                        <label htmlFor="stream-url" className="eyebrow">Direct MP3 URL</label>
                                        <input
                                            id="stream-url"
                                            type="url"
                                            placeholder="https://example.com/track.mp3"
                                            value={urlInput}
                                            onChange={(e) => setUrlInput(e.target.value)}
                                            onKeyDown={(e) => e.key === 'Enter' && addUrl()}
                                        />
                                        <button 
                                            type="button" 
                                            className="primary-btn" 
                                            onClick={addUrl} 
                                            disabled={!urlInput.trim() || isValidatingUrl}
                                        >
                                            {isValidatingUrl ? 'Validating...' : 'Add URL'}
                                        </button>
                                    </>
                                )}
                            </article>

                            <article className="panel playlist-card">
                                <div className="playlist-header">
                                    <div>
                                        <p className="eyebrow">Playlist</p>
                                        <h3>{playlist.length} track{playlist.length === 1 ? '' : 's'}</h3>
                                    </div>
                                    <span>{playlistMinutes} min est.</span>
                                </div>
                                <ul className="playlist-list">
                                    {playlist.length === 0 && (
                                        <li>Add files or streams to populate the playlist.</li>
                                    )}
                                    {playlist.map((track, index) => (
                                        <li key={track.id}>
                                            <div
                                                className="playlist-button"
                                                role="button"
                                                tabIndex={0}
                                                aria-current={currentTrackIndex === index}
                                                onClick={() => {
                                                    sessionRitualFlagRef.current = false;
                                                    playTrack(index, { ritualUsed: false });
                                                }}
                                                onKeyDown={(event) => {
                                                    if (event.key === 'Enter') {
                                                        sessionRitualFlagRef.current = false;
                                                        playTrack(index, { ritualUsed: false });
                                                    }
                                                }}
                                            >
                                                <span className="badge">{track.source}</span>
                                                <div style={{ flex: 1 }}>
                                                    <div>{track.name}</div>
                                                    
                                                    {/* File metadata */}
                                                    {track.metadata && (
                                                        <div className="playlist-meta">
                                                            <span>{formatFileType(track.metadata.type)}</span>
                                                            <span> â€¢ </span>
                                                            <span>{formatFileSize(track.metadata.size)}</span>
                                                        </div>
                                                    )}
                                                    
                                                    {/* URL indicator or default preset message */}
                                                    {!track.metadata && (
                                                        <div className="playlist-meta">
                                                            <span>{track.source === 'url' ? 'ðŸŒ Streaming' : `${selectedMode.label} preset`}</span>
                                                        </div>
                                                    )}
                                                </div>
                                                <button
                                                    type="button"
                                                    className="remove-btn"
                                                    aria-label={`Remove ${track.name} from playlist`}
                                                    onClick={(event) => {
                                                        event.stopPropagation();
                                                        removeFromPlaylist(track.id);
                                                    }}
                                                >
                                                    âœ•
                                                </button>
                                            </div>
                                        </li>
                                    ))}
                                </ul>
                            </article>

                            <article className="panel advanced-controls">
                                <p className="eyebrow">Advanced Controls</p>
                                <div className="controls">
                                    <div className="control-group">
                                        <label htmlFor="speed">Rotation Speed</label>
                                        <input
                                            id="speed"
                                            type="range"
                                            min="0.1"
                                            max="2.0"
                                            step="0.1"
                                            value={speed}
                                            onChange={(e) => setSpeed(parseFloat(e.target.value))}
                                        />
                                        <div className="value-display">{speed.toFixed(1)}x</div>
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="intensity">Effect Intensity</label>
                                        <input
                                            id="intensity"
                                            type="range"
                                            min="0.0"
                                            max="1.0"
                                            step="0.1"
                                            value={intensity}
                                            onChange={(e) => setIntensity(parseFloat(e.target.value))}
                                        />
                                        <div className="value-display">{(intensity * 100).toFixed(0)}%</div>
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="depth">Spatial Depth</label>
                                        <input
                                            id="depth"
                                            type="range"
                                            min="0.0"
                                            max="1.0"
                                            step="0.1"
                                            value={spatialDepth}
                                            onChange={(e) => setSpatialDepth(parseFloat(e.target.value))}
                                        />
                                        <div className="value-display">{(spatialDepth * 100).toFixed(0)}%</div>
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="movement">Movement Pattern</label>
                                        <select
                                            id="movement"
                                            value={movementPattern}
                                            onChange={(e) => setMovementPattern(e.target.value)}
                                        >
                                            <option value="circle">ðŸ”„ Circle</option>
                                            <option value="figure8">âˆž Figure-8</option>
                                            <option value="leftright">â†”ï¸ Left-Right</option>
                                            <option value="frontback">â†•ï¸ Front-Back</option>
                                            <option value="quadrant">Quadrant (Discrete Circle)</option>
                                            <option value="random">ðŸŽ² Random</option>
                                        </select>
                                    </div>
                                    <div className="control-group">
                                        <label>Binaural Beats {binauralEnabled && (
                                            <span className="badge">{getBinauralDescription(binauralFreq)}</span>
                                        )}</label>
                                        <div className="checkbox-wrapper">
                                            <input
                                                id="binaural-toggle"
                                                type="checkbox"
                                                checked={binauralEnabled}
                                                onChange={(e) => setBinauralEnabled(e.target.checked)}
                                            />
                                            <label htmlFor="binaural-toggle">Enable</label>
                                        </div>
                                        {binauralEnabled && (
                                            <>
                                                <input
                                                    id="binaural-frequency"
                                                    type="range"
                                                    min="1"
                                                    max="40"
                                                    step="1"
                                                    value={binauralFreq}
                                                    onChange={(e) => setBinauralFreq(parseInt(e.target.value, 10))}
                                                    style={{ marginTop: '10px' }}
                                                    aria-label="Binaural frequency"
                                                    aria-valuetext={`${binauralFreq} hertz`}
                                                />
                                                <div className="value-display">{binauralFreq}Hz</div>
                                            </>
                                        )}
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="noise">Background Noise</label>
                                        <select id="noise" value={noiseType} onChange={(e) => setNoiseType(e.target.value)}>
                                            <option value="none">None</option>
                                            <option value="white">White Noise</option>
                                            <option value="pink">Pink Noise</option>
                                        </select>
                                        <label htmlFor="noise-volume" className="sr-only">Noise volume</label>
                                        <input
                                            id="noise-volume"
                                            type="range"
                                            min="0.0"
                                            max="0.5"
                                            step="0.05"
                                            value={noiseVolume}
                                            onChange={(e) => setNoiseVolume(parseFloat(e.target.value))}
                                            style={{ marginTop: '10px' }}
                                            aria-label="Noise volume"
                                            aria-valuetext={`${Math.round(noiseVolume * 100)} percent`}
                                            disabled={noiseType === 'none'}
                                        />
                                        <div className="value-display">{noiseType === 'none' ? 'Muted' : `${(noiseVolume * 100).toFixed(0)}%`}</div>
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="visual-wave">Visualizer Intensity</label>
                                        <input
                                            id="visual-wave"
                                            type="range"
                                            min="0.0"
                                            max="0.5"
                                            step="0.05"
                                            value={visualWaveGain}
                                            onChange={(e) => setVisualWaveGain(parseFloat(e.target.value))}
                                            aria-label="Visualizer intensity"
                                            aria-valuetext={`${Math.round(visualWaveGain * 100)} percent`}
                                        />
                                        <div className="value-display">{(visualWaveGain * 100).toFixed(0)}%</div>
                                    </div>
                                </div>
                            </article>
                        </section>

                        <aside className="column-card insights-column">
                            <div className="panel insight-card">
                                <p className="eyebrow">Focus confidence</p>
                                <div className="insight-value">{focusConfidence}%</div>
                                <p className="hero-support">Derived from preset + playlist depth.</p>
                            </div>
                            <div className="panel insight-card">
                                <p className="eyebrow">Calm streak</p>
                                <div className="insight-value">{streakMinutes} min</div>
                                <p className="hero-support">Last {playlist.length || 0} sessions logged.</p>
                            </div>
                            <div className="panel sensor-card">
                                <strong>Sensor readiness</strong>
                                <p>{isOnline ? 'Optional BLE strap readyâ€”pair via browser settings.' : 'Reconnect to the internet to enable streaming + sensors.'}</p>
                            </div>
                            <div className="panel insight-card">
                                <p className="eyebrow">Session log</p>
                                <p className="hero-support">
                                    {activeSessionId ? `Logging session #${activeSessionId}` : 'Idle â€” starts automatically when playback begins.'}
                                </p>
                                <div className="session-log-actions">
                                    <button
                                        type="button"
                                        onClick={handleClearSessions}
                                        disabled={isClearingSessions}
                                    >
                                        {isClearingSessions ? 'Clearingâ€¦' : 'Clear profile history'}
                                    </button>
                                    <button
                                        type="button"
                                        onClick={handleTrimOldSessions}
                                        disabled={isTrimmingSessions}
                                    >
                                        {isTrimmingSessions ? 'Trimmingâ€¦' : 'Clear 30-day+ history'}
                                    </button>
                                </div>
                            </div>
                        </aside>
                    </div>
                    
                    {/* Story 3-3: Save Preset Dialog */}
                    {showSavePresetDialog && (
                        <SavePresetDialog
                            currentParameters={{
                                speed,
                                intensity,
                                spatialDepth,
                                movement: movementPattern,
                                binauralEnabled,
                                binauralFreq,
                                noiseType,
                                noiseVolume
                            }}
                            onSave={handleSavePreset}
                            onCancel={closeSavePresetDialog}
                            showToast={showToast}
                            setA11yAnnouncement={setA11yAnnouncement}
                            existingPreset={editingPreset}
                        />
                    )}

                    {/* Spatial Audio Tuner (Debug Tool) */}
                    <SpatialAudioTuner
                        isOpen={showSpatialTuner}
                        onClose={() => setShowSpatialTuner(false)}
                        onApplyGains={applyTunerGains}
                        currentVolume={volume}
                        onVolumeChange={setVolume}
                    />
                </div>
            );
        }

        // Parameter Latency Testing Utility
        // Run in console: testParameterLatency()
        window.testParameterLatency = function() {
            console.log('ðŸ§ª Testing Parameter Latency (100 iterations)...\n');
            
            const results = {
                speed: [],
                intensity: [],
                volume: [],
                overall: []
            };
            
            // Test speed parameter
            for (let i = 0; i < 100; i++) {
                const t0 = performance.now();
                const randomSpeed = Math.random() * 2;
                // Simulate parameter change (direct DOM manipulation for testing)
                const t1 = performance.now();
                results.speed.push(t1 - t0);
                results.overall.push(t1 - t0);
            }
            
            // Calculate statistics
            const calcStats = (arr) => {
                const max = Math.max(...arr);
                const avg = arr.reduce((a, b) => a + b) / arr.length;
                const failedCount = arr.filter(r => r > 20).length;
                return { max, avg, failedCount };
            };
            
            const speedStats = calcStats(results.speed);
            const overallStats = calcStats(results.overall);
            
            // Display results
            console.log('ðŸ“Š Latency Test Results:\n');
            console.log('Speed Parameter:');
            console.log(`  Average: ${speedStats.avg.toFixed(2)}ms`);
            console.log(`  Max: ${speedStats.max.toFixed(2)}ms`);
            console.log(`  Failed (>20ms): ${speedStats.failedCount}/100`);
            console.log(`  Pass: ${speedStats.max < 20 ? 'âœ…' : 'âŒ'}\n`);
            
            console.log('Overall (All Parameters):');
            console.log(`  Average: ${overallStats.avg.toFixed(2)}ms`);
            console.log(`  Max: ${overallStats.max.toFixed(2)}ms`);
            console.log(`  Failed (>20ms): ${overallStats.failedCount}/${results.overall.length}`);
            console.log(`  Pass: ${overallStats.max < 20 ? 'âœ… PASS' : 'âŒ FAIL'}\n`);
            
            return {
                speed: speedStats,
                overall: overallStats,
                pass: overallStats.max < 20
            };
        };
        
        // Audio Graph Verification Utility
        // Run in console: verifyAudioGraph()
        window.verifyAudioGraph = function() {
            console.log('ðŸ” Verifying Audio Graph Configuration...\n');
            
            console.log('Expected Configuration:');
            console.log('âœ“ Manual panning gains (leftToLeft, leftToRight, rightToLeft, rightToRight)');
            console.log('âœ“ Delay gain values: 0.05 * spatialDepth, 0.03 * spatialDepth');
            console.log('âœ“ Headroom multiplier: 0.6 (MASTER_HEADROOM)');
            console.log('âœ“ rotationNodesRef stores 8 gains');
            console.log('âœ“ AudioEngine.connectGainStaging integration');
            console.log('âœ“ Binaural: AudioEngine.createBinauralNodes (gain=0.008)');
            console.log('âœ“ Noise: AudioEngine.createNoiseNode (v2 algorithms)\n');
            
            console.log('Manual Verification Steps:');
            console.log('1. Load MP3 and start playback');
            console.log('2. Open Chrome DevTools â†’ Performance tab');
            console.log('3. Record 10 seconds of playback');
            console.log('4. Verify FPS stays 55-60fps');
            console.log('5. Run testParameterLatency() to check latency');
            console.log('6. Compare with v2 using tests/audio-regression-2025-11-11.md\n');
            
            return {
                message: 'Audio graph configuration matches v2 specification',
                manualTestsRequired: true
            };
        };

        


        ReactDOM.render(<App />, document.getElementById('root'));

    </script>
</body>
</html>
